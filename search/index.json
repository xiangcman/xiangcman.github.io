[{"content":"初始化过程 当我们app收到choregrapher的vsync信号的时候，会给主线程发送一条消息， 告诉app需要绘制了，而此时发送是通过给主线程的message设置一个callback（runnable），所以会触发handler的dispatchmessage-\u0026gt;handleCallback，接着就是触发FrameDisplayEventReceiver的doframe方法，该方法会计算丢帧数，以及执行callbackqueue数组中的callbackqueue，也就执行到了我们的performTraversal方法，该方法里面会执行到measure，最后执行到recyclerview的onMeause，recyclerview的onMeasure中会判断自己的测量模式，如果是精确的模式，则不测量子item。\ntrace图如下： 接着走到recyclerview的onlayout，在onlayout里面触发dispatchlayout，该方法里面会判断state的step，默认是STEP_START，因此会触发dispatchLayoutStep1和dispatchLayoutStep2，在dispatchLayoutStep1中如果有动画要处理，则会触发layoutManager的onlayoutChildren\n有动画的条件是： 有表项新增或移除、有更改的时候。默认是没有动画要处理，紧接着来到了dispatchLayout2，该方法主要是触发了layoutManager.onLayoutChildren。 调用链如下： linearlayoutmanager.fill-\u0026gt;layoutmanager.layoutChunk-\u0026gt;layoutstate.next-\u0026gt;recycler.getviewforposition-\u0026gt;recycler.tryGeyViewHolderForPostionByDeadline-\u0026gt;adapter.createViewHolder-\u0026gt;adapter.bindViewHolder到这里一个holder的创建于bind过程就结束了，紧接着在layoutchunk中触发layoutmanager.addView和layoutmanager.measureChildWithMargin，到这里表项才会被加入到recyclerview中，但是此时不会刷新recyclerview。 上面说到的layoutchunk会在一个while循环中多次执行，直到recyclerview的空间没有了才不会执行，而layoutchunk又会走recycler.next去从缓存中拿viewholder，而此时缓存中没有viewholder，因此会走createviewholder和bindviewholder，所以一开始create和bind次数是一屏能展示多少个表项的次数。\n接着在dispatchlayout中会调用dispatchlayoutstep3，该方法里面主要是执行scrap缓存的释放，以及动画的执行\n到这里，测量和layout已经梳理完了，最后就剩draw了： draw里面基本没干什么，还是沿用了viewgroup的drawchild方法，绿色表示非系统方法，因此可以看出来recyclerview是重写了该方法： 总结： 初始化分为onmeasure阶段：如果recyclerview设置了固定宽高，则直接跳过测量，调用到mLayout中，如果不是固定宽高，则会走dispatchLayoutStep1，dispatchLayoutStep2。其中dispatchLayoutStep1是预布局处理，如果有动画要处理才会在该阶段调用到layout的onLayoutChildren。在dispatchLayoutStep2中处理表项的测量。 在onlayout阶段：会判断step还是不是start状态，如果是的话，则再次执行dispatchLayoutStep1和dispatchLayoutStep2。最后调用dispatchLayoutStep3用来做动画执行并释放相关资源。 在draw阶段基本什么都没做，dispatchDraw本身会调用到drawChild，recyclerview只是重写了该方法。\n滑动过程 滑动过程中会调用到scrollByInternal-\u0026gt;layoutmanager.scrollBy-\u0026gt;fill-\u0026gt;layoutchunck\nlayoutchunck里面会从缓存中取数据，如果有则命中，没有则走create和bind，接着划出屏幕的表项会先加入到cache缓存中，如果cache缓存满了，则重置该表项，加入到recyclerpool中，下次所以取的时候从recyclerpool根据viewtype取需要重新bind，不需要create，所以在滑动过程中create的次数是cache的大小次数，等到recyclerpool中有缓存的时候就不需要create了。\n在fill过程中，会找到划出屏幕的表项，然后先调用recycleByLayoutState，接着调用到了Linearlayoutmanager.recycleChildren，接着会触发recyclerview.removeAndRecycleViewAt方法，接着就触发了adapter.onViewDetachedFromWindow(viewHolder)，接着就把viewholder缓存到cache和recyclerpool中，对应的方法是recycler.recycleView-\u0026gt;recycleViewHolderInternal,其中cache缓存中默认是2个，如果大于2的话，会把最前面的那个给放到recyclerpool中，接着再把新的viewholder放进来。\n在fiil过程中，会通过LayoutState.next从缓存中获取viewholder，获取的时候会先判断是不是preLayout状态，如果是则从changeScrap缓存中获取，从changeScrap中获取缓存先通过position获取，如果用position获取不到，则再用id去获取（必须adapter设置setHasStableIds为true，并且adapter重写了getItemId）。如果没获取到则从attacheScrap和cache中获取，如果从attach和cache中找不到，则继续通过id从attachScrap中获取，如果还没获取到则从viewcacheExtension中去获取，如果还获取不到则再从recyclerpool中去获取，如果还获取不到则通过create来创建viewholder，接着走bind逻辑。\n所以整个缓存获取顺序： changeScrap(preLayout状态，先通过position获取，没获取到再通过id获取)-\u0026gt;attacheScrap-\u0026gt;cache-\u0026gt;attachScrap(id方式获取)-\u0026gt;viewcacheExtension-\u0026gt;recyclerpool-\u0026gt;createholder-\u0026gt;bindholder\n这就是layoutstate.next获取viewholder整个逻辑，上面哪些会触发createholder和bindholder\n如果从几个缓存中都拿不到viewholder，则会走createholder的逻辑。\n什么情况下会调用onBindViewHolder？ 不是bound状态 bound标志位：是在bindViewHolder的时候设置的，因此不是bound表示没有bind过。没有bind过有：1，createholder；2，从recyclerpool取的viewholder。 needsUpdate：该状态表示什么？什么时候才会是needUpdate()呢？\n在viewRangeUpdate设置的。猜测是在viewholder发生变化的时候设置的，验证猜想： recyclerview.processAdapterUpdatesAndSetAnimationFlags-\u0026gt;AdapterHelper.preProcess-\u0026gt;applyUpdate-\u0026gt;postponeAndUpdateViewHolders -\u0026gt;markViewHoldersUpdated-\u0026gt;viewRangeUpdate，所以在dispatchLayout1过程中给flag设置了update状态\nisInvalid：表示什么状态？什么时候赋值的？ 从缓存（attachScrap、cacheview）中获取viewholder的时候，如果发现type和holder的type不一致，则会校验不通过。或者设置了stableids为true的时候，如果adapter中的id和holder的id一致，则也通过。 所以结论就是，需要bound的条件：没有bound过（createholder的holder还没有bound过）；needupdate的，holder发生更新了。invalid，从attachscrap、cache获取后， 如果type不一致也需要重新bound。 更新表项 notifyItemChange(0)：更新表项第0的位置\n首先是进入页面创建了10个表项，然后更新后日志如下： 首先给我创建了索引为10的表项，也就是屏幕上不可见的，接着又创建了表项0，通过traceview分析： 整体看经历了rv的layout过程，分别对应了dispatchLayoutStep1、dispatchLayoutStep2、dispatchLayoutStep3。\ndispatchLayoutStep1 detachAndScrapAttachedViews 共经历了10次scrapOrRecycleView： 它是反向遍历页面上的view，然后添加到srap缓存中： 从scrapOrRecycleView的调用栈来看，是走了else部分，也就是往scrap缓存中加入viewholder。由于viewHolder的isInvalid为false，所以会走else。 scrap缓存分两种，attachScrap和changeScrap。不是update的会放到attachScrap中，所以我们更新第0个的时候会放到changeScrap中，在detach的时候由于是反向加入到scrap缓存中的，因此我们看第10个的trace调用： 从这里看第0个表项在detach的时候会加入到changeScrap中。 结论：在dispatchLayout1中，先将页面上可见的viewholder从页面上分离，然后将update的viewholder放入到changeScrap中，把非update的viewholder放入到attachScrap中。\nfill fill阶段发生了layoutChunk11次，而我们刚开始列表是初始化了10个表项，那么说明dispatchLayout1阶段添加了一个新的viewholder，关于这块我们可以给出结论，如果viewhodler被设置了remove或者update标记的时候，则会给列表添加一个新的viewholder。关于这块可以看：https://juejin.cn/post/6890288761783975950 在fill的while循环中会判断remainingSpace时候大于0，而每次layoutChunk过程中会将remainingSpace减小，而layoutChunkResult.mIgnoreConsumed就是判断是否要减小，意思是如果不忽略才会减小，那什么时候会忽略呢？ layoutChunk中判断viewholder如果是remove或者是change时候，才会忽略减小。所以我们会有11次的layoutChunk，而最后一次的layoutChunk会走createViewHolder，也就对应了上面的日志先添加了position=10的viewholder。从trace上看下： 结论： dispatchLayout1过程中，将第0个放入到changeScrap中，1-9放入到了attacheScrap中，并且创建了索引为10的viewhodler。\n注意： 在dispatchLayout1过程中，如果viewholder经过了addView之后，则会把它从changescrap或者是attachscrap缓存中移除，所以在dispatchlayout2过程中change和attach的缓存为空的。 其实在dispatchLayout2过程中添加viewholder的view时候也是要从scrap缓存中移除。\ndispatchLayoutStep2 detachAndScrapAttachedViews 由于在dispatchLayout1过程中创建了position=10的viewholder，因此会有11次，这11个里面第0个还是添加到了changeScrap中，1-10是添加到attachScrap中。\nfill 为什么此过程只有10次layoutChunck呢？这块其实还是回到remainingSpace的计算说起： 所以在dispatchLayout2过程中当添加到索引等于9的时候remainingSpace就为0了，所以索引等于10的时候添加不上，因此只会有10次layoutChunck。\nlayoutChunck 我们可以看到第0个走了createViewholder和bindViewholder： 是由于第0个viewholder被添加到了changeScrap缓存中，而1-9的viewholder添加到了attachScrap中，而changeScrap只会在pre-layout过程中才会生效： 所以可以看到上面日志中会走了position=0的createViewHolder和bindViewHolder。\n总结: 更新表项的时候，会经历dispatchLayout1，dispatchLayout2，其中在dispatchLayout1（pre-layout阶段）会先把可见的表项给回收到scrap缓存中，回收后，会把可见的表项从recyclerview中分离，其中需要变化的表项会加入到 changeScrap中（第1个表项），不变化的加入到attachScrap中（第2个到第10个表项）。接着在fill阶段会从scrap缓存中取表项，由于有表项更新，所以此时会去创建不可见的表项（第11个表项），最后会添加到recyclerview上。 在dispatchLayout2（post-layout阶段）同样会把dispatchLayout1添加进来的表项给添加到changeScrap（第1个表项）和attachScrap（第2个到第11个表项）缓存中，注意此时的表项会是11个表项。在fill阶段会去创建表项0， 因为post-layout阶段不会去取changeScrap中的viewholder，所以表项0会经历创建。\n删除表项 notifyItemRemove(0)\ndispatchLayout1 detachAndScrapAttachedViews 调用了10次scrapOrRecycleView 第0个调用scrapView添加到attachScrap缓存中 1-9的表项也是添加到attachScrap缓存中，这个可以从trace中看到。 fill 和update过程一样，在dispatchlayout1有11次layoutChunk，delete和update的viewholder不作为消费remainingSpace。 接着调用layoutstate.next获取viewholder，此时只有索引等于10的时候会去创建viewholder。注意了：此时创建完viewholder后，bind过程传的position=9： 在bind过程中会传入postion=10，而此时的mPostponedList中有一个op是remove类型的，所以postion会减一，因此它的postion是9： dispatchLayout2 detachAndScrapAttachedViews 此处scrapOrRecyclerview发生了11次，因为在dispatchLayout1创建了一个新的viewholder，11个viewholder都加入到了attachScrap缓存中。 fill layoutChunk调用了10次： 在第一个viewholder获取的时候获取到原来的第二个表项了，原来的第一个表项的position被置为-1了，所以我们0-9的表项都不会重新创建viewholder。也就对应上面的日志。 疑问： 此处的position赋值貌似都重新赋值了，因此我们看下是哪里重新赋值了： 当调用notifyItemRemove(0)的时候，在dispatchlayout1过程中会触发offsetPositionRecordsForRemove方法，该方法会通过remove的itemCount数重新给每一个页面上的viewhodler重新给赋上position的值，所以会看到上面的attachScrap缓存中最后一个viewholder的postion=-1了。 scrap缓存 在fill之前会把页面上的viewholder先detach掉，最终会调用到viewgroup的detachViewFromParent方法，removeView也会调用该方法，只不过viewholder的detach不会立马requestLayout。接着就是调用scrapView。 scrap缓存分两种，一种是attach、另外一种是change，如果viewholder是发生了变化（notifyItemChange），则会加入到change中，否则加入到attach中。接着在layoutChunk过程中，会从scrap缓存中找viewholder。 在dispatchLayout3过程中，会调用layout.removeAndRecycleScrapInt方法： 里面会调用recycler.clearScrap： 会清空scrap缓存。 总结：scrap缓存在每次layoutChild之前会先把页面的viewholder先放到scrap缓存中，在dispatchLayout3的时候，会把该缓存清空掉。\nAdapter.onViewAttachedToWindow 刚进入屏幕会触发onViewAttachedToWindow，从0-9都打印了。 从trace来看，初次每个viewholder都会经历onViewAttachedToWindow方法。\n下面看看什么时候不会调用onViewAttachedToWindow方法？ 每次在layoutChunk的时候，从缓存中去拿viewholder，如果从scrap缓存中拿到了，则不触发childHelper的addView，也就不会触发adapter.onViewAttachedToWindow；如果当前view的parent是当前recyclerview的时候，也不触发childhelper的addview。如果都不满足则触发adapter.onViewAttachedToWindow。\n滑动的时候是否触发？ 滑动过程中表项从不可见到可见会触发onViewAttachedToWindow，因为它不是从scrap缓存中获取到的，它是从cache缓存或者是recyclerpool中获取的。onViewAttachedToWindow触发不一定会触发oncreateViewHolder，也不一定会触发onBindViewholder。如果cache缓存和pool缓存中都没有该viewholder，则会触发oncreateViewHolder和onBindViewholder。如cache中有，则只触发onViewAttachedToWindow。如果从pool中拿到缓存，则会触发onBindViewholder和onViewAttachedToWindow。\n更新列表是否会触发？ 拿上面更新表项0来看，由于在dispatchLayout1(pre-layout)过程中会创建表项10，所以会经历表项10的oncreate和onbind，并且把它添加到rv中，所以会有一次的表项10的onViewAttachedToWindow，接着会在dispatchLayout2过程中会创建表项0（因为表项0存在了changeScrap缓存中），所以会走表项0的onViewAttachedToWindow。\nAdapter.onViewDetachedFromWindow 滑动过程中，划出屏幕的表项会调用onViewDetachedFromWindow。\nfindViewHolderForAdapterPosition和findViewHolderForLayoutPosition区别： 结论：正常情况下adapterPostion和layoutPosition是相等的，当有add、remove、move的时候两者是不一样的。adapterPostion会算上要改变的表项，比如上面我要删除第一个表项，那么拿到的表项就是第二个。而layoutPostion是页面最终呈现的表项，上面例子中等到post完后，才会真正的删除掉。所以post（绘制后）后layoutposition获取到的是原来的第二个表项。\nnotifydatasetChange问题 先是把页面上所有的都detach掉，然后又走了所有的viewholder的onbind过程，从索引为5的viewholder走了oncreateviewholder。下面看下trace： layout过程只走了dispatchLayout2，在里面走到了linearlayoutManager.onLayoutChildren，里面会触发fill。在fill之前会走detach逻辑，里面会反向遍历可见的子view，并调用scrapOrRecylerview： 每一个子view回收都走了removeViewAt: 此处由于所有的viewholder都是invalid状态了，因为在notifyDatasetChange在调用requestLayout之前把页面上的子view都设置成invalid状态了： 所以在fill之前都会调用removeViewAt，而该方法会触发onViewDetachedFromWindow，因此可以看到前面日志中先反向打印了9-\u0026gt;0的onViewDetachedFromWindow。接着会调用recycler.recycleViewHolderInternal，该方法是把viewholder加入到cache或者是recyclerpool中： 如果存在invalid状态，则会把viewholder加入到pool缓存中，trace验证下： 而pool缓存是5个，因此先把9-\u0026gt;5存到poo中时，发现pool满了，则把9给移除掉，因此最后只剩下5个viewholder在pool中。接着在layoutChunk阶段，会从缓存中拿viewholder的时候，只有pool中5个viewhold的缓存，取完一个remove掉一个，当索引为5的时候，pool中已经拿完了，因此5-9会去创建viewholder。\n参考： RecyclerView 缓存机制 | 如何复用表项？ RecyclerView 缓存机制 | 回收些什么？ RecyclerView 缓存机制 | 回收到哪去？ RecyclerView缓存机制 | scrap view 的生命周期\n","date":"2025-01-02T00:00:00Z","permalink":"https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/","title":"RecyclerView源码走读"},{"content":"suspendCoroutine 在android中无处不在获取view的宽高，而获取宽高是需要在view绘制完后才能获取，所以这是一个时机问题，通常通过view.post来获取，那么用协程如何形如同步获取宽高呢？下面来试试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 GlobalScope.launch { val wh = getViewWh(view) Log.d(TAG, \u0026#34;width:${wh.first}\u0026#34;) Log.d(TAG, \u0026#34;height:${wh.second}\u0026#34;) } Log.d(TAG, \u0026#34;outer coroutine\u0026#34;) private suspend fun getViewWh(view: View) = suspendCoroutine\u0026lt;Pair\u0026lt;Int, Int\u0026gt;\u0026gt; { continuation -\u0026gt; view.post { val width = view.width val height = view.height continuation.resume(Pair(width, height)) } } 日志如下：\n1 2 3 11:00:57.708 D outer coroutine 11:00:57.810 D width:1080 11:00:57.810 D height:2206 使用了suspendCoroutine方法，方法的返回值，是suspendCoroutine指定的泛型。 可以看到日志正常获取，下面来看看字节码是如何实现的： launch启动的时候，内部的协程代码块编译结果是SuspendCoroutineActivity$onCreate$1： 调用了SuspendCoroutineActivity的静态方法access$getViewWh：\n静态方法是直接调用了成员方法getViewWh，它是本次的重要实现：\n传进来的Continuation对应了SuspendCoroutineActivity$onCreate$1，它是传给了SafeContinuation，此处注意到调用了continuation的intercepted方法，它是continuation的扩展方法，它是在continuationImpl中实现了，它实际是看context中是否有dispatcher，这块在协程切换线程中讲过，它实际是生成了一个CoroutineDispatcher。\n接着看又调用了SuspendCoroutineActivity$getViewWh$2$1这个suspendLambda，并把SafeContinuation传进去了： 此处的Runnable就对应了post中的代码块，最终在run方法中调用了continuation的resumeWith方法，并把宽高回调出去了。此处的continuation是SafeContinuation，看下它的resumeWith方法： 此处的result默认值是UNDECIDED： 由于默认值是UNDECIDED，在上面getViewWh中先调用了safeContinuation的getOrThrow方法： 所以会给result设置上了COROUTINE_SUSPENDED标记，所以在第一个suspendLambda的invokeSuspend方法中能被挂起，等到执行safeContinuation的resumeWith的时候，第一个suspendLambda就恢复了。最终获取到结果，整个流程就结束。\nsuspendCoroutine的回调中还有一个resumeWithException方法，用于返回失败的结果，如果返回失败的时候，需要捕捉异常。\nsuspendCancellableCoroutine 它和suspendCoroutine区别是回调中是一个CancellableContinuationImpl，它提供了cancel方法，当cancel的时候，程序不会崩溃。它会把cancel的结果分发到delegate中，此处的delegate其实就是对应了GlobalScope.launch启动时的suspendLambda，最后它会分发到父job中。看下CancellableContinuationImpl的cancel方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public override fun cancel(cause: Throwable?): Boolean { _state.loop { state -\u0026gt; if (state !is NotCompleted) return false // false if already complete or cancelling // Active -- update to final state val update = CancelledContinuation(this, cause, handled = state is CancelHandler || state is Segment\u0026lt;*\u0026gt;) if (!_state.compareAndSet(state, update)) return@loop // retry on cas failure // Invoke cancel handler if it was present when (state) { is CancelHandler -\u0026gt; callCancelHandler(state, cause) is Segment\u0026lt;*\u0026gt; -\u0026gt; callSegmentOnCancellation(state, cause) } // Complete state update detachChildIfNonResuable() dispatchResume(resumeMode) // no need for additional cancellation checks return true } } 此处会构造出CancelledContinuation，它是CompletedExceptionally对象，这个其实就是协程异常的扩展类，最终把该对象设置到CancellableContinuationImpl的state上。 一路跟到DispatchedTask的dispatch方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 internal fun \u0026lt;T\u0026gt; DispatchedTask\u0026lt;T\u0026gt;.dispatch(mode: Int) { assert { mode != MODE_UNINITIALIZED } // invalid mode value for this method val delegate = this.delegate val undispatched = mode == MODE_UNDISPATCHED if (!undispatched \u0026amp;\u0026amp; delegate is DispatchedContinuation\u0026lt;*\u0026gt; \u0026amp;\u0026amp; mode.isCancellableMode == resumeMode.isCancellableMode) { // dispatch directly using this instance\u0026#39;s Runnable implementation val dispatcher = delegate.dispatcher val context = delegate.context if (dispatcher.isDispatchNeeded(context)) { dispatcher.dispatch(context, this) } else { resumeUnconfined() } } else { // delegate is coming from 3rd-party interceptor implementation (and does not support cancellation) // or undispatched mode was requested resume(delegate, undispatched) } } 此处会走dispatcher.dispatch逻辑，因为上面的GlobalScope.launch其实创建的dispatcher是一个Dispatcher.Default类型的。DispatchedTask是一个runnable接口，看下它的run方法： 最终也是通过continuation的resumeWithException方法回调出去，然后交给了父job去处理，此时的exception是一个CancellationException，其实上面的suspendCoroutine也可以通过resumeWithException回调一个CancellationException，程序也不会崩溃。\n参考：https://juejin.cn/post/7121517604644061192\n","date":"2024-12-30T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/","title":"协程如何优雅的处理异步回调"},{"content":"案例一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private fun demo1() { val handler = CoroutineExceptionHandler { coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;onCreate: CoroutineExceptionHandler:${throwable.message}\u0026#34;) } GlobalScope.launch(handler) { Log.d(TAG, \u0026#34;onCreate: parentJob start\u0026#34;) withContext(Dispatchers.IO) { throw RuntimeException(\u0026#34;runtime exception\u0026#34;) delay(1000) Log.d(TAG, \u0026#34;onCreate: withContext end\u0026#34;) } Log.d(TAG, \u0026#34;onCreate: parentJob end\u0026#34;) } } 先上日志：\n1 2 com.example.coroutinescopedemo D onCreate: parentJob start com.example.coroutinescopedemo D onCreate: CoroutineExceptionHandler:withContext runtime exception 异常能被launch指定的handler所捕捉。 分析： launch启动的协程用到的coroutineScope是一个StandaloneCoroutine，withContext启动的协程对应的coroutineScope是一个DispatchedCoroutine。 在withContext中发生异常的时候，首先会回调到DispatchedCoroutine的resumeWith，最终会走到finalizeFinishingState方法，该方法里面会判断是否存在异常，如果有异常会调用cancelParent方法：\n可以看到如果isScopedCoroutine为true的时候，cancelParent直接返回true，如果返回true，那么就不触发自己的上面的handleJobException，也就是把异常继续往上抛了。例子中也就是launch对应的StandaloneCoroutine。而在StandaloneCoroutine中不会去cancelParent，所以会把异常交给了handleJobException了，所以上面的launch中传入的CoroutineExceptionHandler能捕获到该异常。\n总结：如果子job中在处理异常的时候，cancelParent中如果isScopedCoroutine为true的时候，则不触发自己的handleJobException，也就是把异常交给了父job，如果父job不处理该异常，则会程序崩溃。\n案例二 上面代码如果把withContext中的异常通过try-catch住，父job就收不到该异常了： 子携程把异常catch住后，父协程的handler捕捉不到异常，并且父协程的invokeOnCompletion收不到异常，并且父协程之后的代码也能正常执行。\n案例三 子协程给context传递coroutineExceptionHandler： 子协程抛了异常，然后子协程也传了CoroutineExceptionHandler，但是子协程的CoroutineExceptionHandler不起作用，还是把异常传给了父协程。并且父协程的invokeOnCompletion收到了异常回调，而且发现父协程的invokeSuspend方法也没走完，所以onCreate: parentJob end没有输出。\n分析：前面已经分析过withContext开启的协程对应的coroutineScope是一个DispatchedCoroutine重写了isScopedCoroutine=true，如果它为true，cancelParent方法则返回true，那么它自己的handleJobException就不会触发，所以就不会走到自己的CoroutineExceptionHandler回调了。\n案例四 当子协程抛的是CancellationException，父协程捕捉不到该异常： 此处handler没有捕捉到异常，并且程序也没崩溃，这是因为在子协程把异常回调给父协程后，父协程对应的scope，也就是StandaloneCoroutine在cancelParent中判断是CancelationException，它直接返回true，所以不会调用handleJobException方法，而向外抛异常的正是该方法。所以当子协程抛出CancellationException时候不会使父协程崩溃。\n案例五 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 private fun demo2() { val handler = CoroutineExceptionHandler { coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;handler:${throwable.message}\u0026#34;) } val job = Job() val coroutineScope = CoroutineScope(job + handler) val job1 = coroutineScope.launch { delay(100) Log.d(TAG, \u0026#34;job1 end\u0026#34;) throw RuntimeException(\u0026#34;runtime exception\u0026#34;) } job1.invokeOnCompletion { Log.d(TAG, \u0026#34;job1 invokeOnCompletion:${it?.message}\u0026#34;) } val job2 = coroutineScope.launch { delay(200) Log.d(TAG, \u0026#34;job2 end\u0026#34;) } job2.invokeOnCompletion { Log.d(TAG, \u0026#34;job2 invokeOnCompletion:${it?.message}\u0026#34;) } val job3 = coroutineScope.launch { delay(300) Log.d(TAG, \u0026#34;job3 end\u0026#34;) } job3.invokeOnCompletion { Log.d(TAG, \u0026#34;job3 invokeOnCompletion:${it?.javaClass?.simpleName}\u0026#34;) Log.d(TAG, \u0026#34;job3 invokeOnCompletion:${it?.message}\u0026#34;) } } 日志如下：\n1 2 3 4 5 6 com.example.coroutinescopedemo D job1 end com.example.coroutinescopedemo D handler:runtime exception com.example.coroutinescopedemo D job2 invokeOnCompletion:Parent job is Cancelling com.example.coroutinescopedemo D job1 invokeOnCompletion:runtime exception com.example.coroutinescopedemo D job3 invokeOnCompletion:JobCancellationException com.example.coroutinescopedemo D job3 invokeOnCompletion:Parent job is Cancelling 数据结构:父协程的job启动了三个子协程，在job1中抛出异常，job2和job3收到了JobCancellationException。其中父job是一个JobImpl对象，在每个子协程启动过程中都会创建一个ChildHandleNode对象，其中job指向了父Job，也就是JobImpl，childJob指向了当前子job，也就是StandaloneCoroutine，最后在子Job中通过parentHandle指向了父job，state指向了InvokeOnCompletion(是通过invokeOnCompletion添加的)。父job中通过state指向了一个NodeList，每一个next节点指向了三个子job。\n异常处理:当第一个job发生异常后，会通知自己的state中的InvokeOnComplete接口，所以job1中收到了runtime exception的信息，它是原始的失败信息。接着会调用到job1的cancelParent逻辑，该方法中会调用到parentHandle的childCancelled逻辑，它是一个ChildHandleNode对象，在它的childCancelled方法中，会触发父job的childCancelled方法，最终会来到父job的cancelImpl方法。该方法里面会去取消子job，是通过遍历state节点，调用里面的每一个ChildHandleNode的invoke方法，在invoke里面会调用到childJob的parentCancelled方法，里面会给每一个job的state设置上JobCancellationException，当让第一个job由于已经有exception了，也就是原始exception，所以job2和job3会设置上JobCancellationException异常。接着子协程会递归调用notifyHandlers通知子协程发生异常了，直到没有子协程为止。 当所有的子协程处理完异常后，会调用到自己的CoroutineExceptionHandler的回调。当回调完后，会给自己的state添加异常，防止在resumeWith中往下执行逻辑。其中给state添加异常是通过Finishing.addExceptionLocked添加异常信息。\n子协程invokeOnCompletion接口回调执行时机？ 在异常处理阶段，父协程会调用到ChildHandleNode中的invoke方法，继而会触发childJob的parentCancelled方法，最终会在notifyHandlers中触发invokeOnCompletion的回调？\n子协程的job为什么在添加完异常后resumeWith不会被执行？ 在协程job中在执行resumeWith的时候，调用到tryMakeCompleting时，会判断state，如果不是Incomplete状态，则直接返回，不会往下执行。\n父协程在cancelImpl的时候除了取消子协程还做了什么？ 在取消完子协程的时候，给第一个child添加了ChildCompletion回调，该回调执行的时候会执行到continueCompleting，最终会回到自己处理异常的逻辑。\n案例六 把案例五中的Job()换成SupervisorJob()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 private fun demo3() { val handler = CoroutineExceptionHandler { coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;handler:${throwable.message}\u0026#34;) } val coroutineScope = CoroutineScope(SupervisorJob() + handler) val job1 = coroutineScope.launch { delay(100) Log.d(TAG, \u0026#34;job1 end\u0026#34;) throw RuntimeException(\u0026#34;runtime exception\u0026#34;) } job1.invokeOnCompletion { Log.d(TAG, \u0026#34;job1 invokeOnCompletion:${it?.message}\u0026#34;) } val job2 = coroutineScope.launch { delay(200) Log.d(TAG, \u0026#34;job2 end\u0026#34;) } job2.invokeOnCompletion { Log.d(TAG, \u0026#34;job2 invokeOnCompletion:${it?.message}\u0026#34;) } val job3 = coroutineScope.launch { delay(300) Log.d(TAG, \u0026#34;job3 end\u0026#34;) } job3.invokeOnCompletion { Log.d(TAG, \u0026#34;job3 invokeOnCompletion:${it?.javaClass?.simpleName}\u0026#34;) Log.d(TAG, \u0026#34;job3 invokeOnCompletion:${it?.message}\u0026#34;) } } 只是换了个job，job1还是一样收到了原始异常，job2和job3正常执行，并能执行完。按照上面分析，当job1发生异常的时候，会调用到cancelParent，它会分发到父job的childCancelled方法，而SupervisorJob重写了该方法直接返回false。所以异常不会分发到子协程中，当job1的cancelParent返回false的时候，会执行到handleJobException，而job1使用的context中的CoroutineExceptionHandler是使用的父job中指定的CoroutineExceptionHandler。因为context是plus叠加的方式。所以最后handler中收到了异常。\n以下的案例来自于https://juejin.cn/post/7049537608262615070\n案例七 结果：try-catch竟然捕获不住，程序直接抛异常了\n此处try-catch的位置不在子协程的SuspendInvoke位置，它是在主协程的launch位置，其实它是在invokeSuspend中调用内部launch的时候加了try-catch，对应的class代码如下：\n从字节码来看，只是启动子协程的时候给try-catch，从原理上分析，当子协程发生异常后，会调用父协程的cancelChild，在父job里面会调用到cancelParent，而父job(shi 也就是JobImpl)，它的parentHandle是空，所以cancelParent的方法返回false，因此会调用到handleJobException，而父job没有传handler，因此程序会崩溃。 上面的案例，其实可以理解为launch启动的协程中再启动一个lanuch协程，然后try-catch捕捉位置在外层lauch上，此时是捕捉不到异常的\n案例八 结果：此处不会发生异常，异常被exceptionHandler捕捉 因此当父job接收到异常后，会将异常传递到handleJobException方法中，而父job是有handler的，所以将异常回调到了handler中，程序不会崩溃。\n案例九 结果：程序崩溃了，不会被子协程的handler捕捉到异常\n因为当子协程异常的时候，会把异常抛给了父job，而父job又没有处理该异常，所以程序崩溃了\n案例十 结果：程序不会崩溃，异常被try catch捕获住，而不是被exceptionHandler捕获住。\n前面分析过当子协程发生异常后，会把异常分发给到父job，在父job中需要等子job都处理完异常了，才会往下走，该处逻辑主要体现在子job中添加了一个ChildCompletion节点到state中，在invoke中会执行到parent.continueCompletion方法： 此处的parent实际是coroutineScope启动的协程对应的job，它是ScopeCoroutine，看下它的continueCompleting实现： 最终会把结果回调给到了传递进来的continuation，也就是最外层launch启动的时候的SuspendLambda，最终会调用它的invokeSuspend方法： 所以最终被try-catch捕捉到异常。\n案例十一 结果：程序被内层launch指定的exceptionHandler捕捉了 supervisorScope用到的job是SupervisorCoroutine，它重写了childCancel方法，并返回false，所以当子job发生异常的时候，不会抛给父job，并执行自己的handleJobException方法，所以被自己的handler捕获到。\n案例十二 此时被外层launch的handler所捕捉，原因是异常抛给了父job。\n案例十三 此时被内层launch的handler所捕捉，原因是supervisorScope启动的协程不会往上抛，交给了子协程自己处理。\n","date":"2024-12-17T00:00:00Z","image":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AD%90%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/cover_hu17536845123992820283.jpg","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AD%90%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"协程中子协程异常处理"},{"content":"invokeOnCompletion监听协程状态 在了解协程的异常处理之前，先来熟悉下协程之间job是如何绑定关系，还是通过一个例子来熟悉他们之间的关系：\n1 2 3 4 5 6 7 8 private fun demo(){ val job = GlobalScope.launch { Log.d(TAG, \u0026#34;demo: launch代码\u0026#34;) } job.invokeOnCompletion { Log.d(TAG, \u0026#34;demo: invokeOnCompletion\u0026#34;) } } 执行结果：\n1 2 CoroutineJobActivity com.example.coroutinescopedemo D demo: launch代码 CoroutineJobActivity com.example.coroutinescopedemo D demo: invokeOnCompletion 可以看出来invokeOnCompletion是job执行完毕的回调。\n通过launch创建协程内部会构造一个StandaloneCoroutine，它就是一个job，并且launch返回的就是该job： StandaloneCoroutine继承自AbstractCoroutine： 因此parentHandle为NonDisposableHandle，然后方法结束。 此时执行完launch后，继续执行了job的invokeOnCompletion方法，它是一个抽象方法，实现方法在jobSupport类： 我们看下makeNode方法实现： 从调用链上看onCancelling传进来的是false，并且此时的handler还不是一个JobNode节点，所以会创建了一个InvokeOnCompletion对象，并把外面传进来的ComppletionHandler传到InvokeOnCompletion中，看下InvokeOnCompletion对象：\n1 2 3 4 5 private class InvokeOnCompletion( private val handler: CompletionHandler ) : JobNode() { override fun invoke(cause: Throwable?) = handler.invoke(cause) } InvokeOnCompletion是一个JobNode节点：\n1 2 3 4 5 6 7 8 9 10 internal abstract class JobNode : CompletionHandlerBase(), DisposableHandle, Incomplete { /** * Initialized by [JobSupport.makeNode]. */ lateinit var job: JobSupport override val isActive: Boolean get() = true override val list: NodeList? get() = null override fun dispose() = job.removeNode(this) override fun toString() = \u0026#34;$classSimpleName@$hexAddress[job@${job.hexAddress}]\u0026#34; } JobNode实现了CompletionHandlerBase抽象类：\n1 2 3 internal actual abstract class CompletionHandlerBase actual constructor() : LockFreeLinkedListNode(), CompletionHandler { actual abstract override fun invoke(cause: Throwable?) } 它也是实现了CompletionHandler接口，CompletionHandler是一个闭包，从上面继承以及JobNode实现来看，在它的invoke实现里面，会触发传进来的CompletionHandler的invoke实现，从实现来看其实这就是个静态代理的模式。\n结论： makeNode内部会返回一个InvokeOnCompletion对象，它是一个JobNode节点。\n回到上面的invokeOnComletion的实现，创建了InvokeOnCompletion后，会走到loopOnState的函数，它是遍历state，它的初始状态是一个Empty状态，并且state.isActive=true。所以最终把刚才创建的InvokeOnCompletion设置到了state上，并且返回了该InvokeOnCompletion。\n结论： 当调用了job的invokeOnCompletion方法后，会把外界创建好的CompletionHandler传给了InvokeCompletion，InvokeCompletion是一个JobNode，在它的invoke实现中，会回调到外界的CompletionHandler中。并且把创建的InvokeCompletion设置到当前job的state上了。\n协程体执行完job的执行： 在之前分析协程体其实是一个SuspendLambda，在它的invokeSuspend调用完后，会执行它的continuation的resumeWith方法，在上面例子中其实是StandaloneCoroutine，它是一个job，所以看下它的resumeWith实现：\n1 2 3 4 5 public final override fun resumeWith(result: Result\u0026lt;T\u0026gt;) { val state = makeCompletingOnce(result.toState()) if (state === COMPLETING_WAITING_CHILDREN) return afterResume(state) } 将协程体的结果传到了makeCompletingOnce方法中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 internal fun makeCompletingOnce(proposedUpdate: Any?): Any? { loopOnState { state -\u0026gt; val finalState = tryMakeCompleting(state, proposedUpdate) when { finalState === COMPLETING_ALREADY -\u0026gt; throw IllegalStateException( \u0026#34;Job $this is already complete or completing, \u0026#34; + \u0026#34;but is being completed with $proposedUpdate\u0026#34;, proposedUpdate.exceptionOrNull ) finalState === COMPLETING_RETRY -\u0026gt; return@loopOnState else -\u0026gt; return finalState // COMPLETING_WAITING_CHILDREN or final state } } } 轮训获取state，并调用了tryMakeCompleting方法： 从上面的分析知道state它是一个JobNode，它是一个InvokeCompletion，它不是一个ChildHandleNode，并且proposedUpdate不是CompletedExceptionally，所以会执行tryFinalizeSimpleState： 内部调用了completeStateFinalization方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private fun completeStateFinalization(state: Incomplete, update: Any?) { /* * Now the job in THE FINAL state. We need to properly handle the resulting state. * Order of various invocations here is important. * * 1) Unregister from parent job. */ parentHandle?.let { it.dispose() // volatile read parentHandle _after_ state was updated parentHandle = NonDisposableHandle // release it just in case, to aid GC } val cause = (update as? CompletedExceptionally)?.cause /* * 2) Invoke completion handlers: .join(), callbacks etc. * It\u0026#39;s important to invoke them only AFTER exception handling and everything else, see #208 */ if (state is JobNode) { // SINGLE/SINGLE+ state -- one completion handler (common case) try { state.invoke(cause) } catch (ex: Throwable) { handleOnCompletionException(CompletionHandlerException(\u0026#34;Exception in completion handler $state for $this\u0026#34;, ex)) } } else { state.list?.notifyCompletion(cause) } } 该方法中判断state是否是JobNode，如果是的话，会调用invoke方法。在上面分析过state是一个InvokeOnCompletion对象，在它的invoke里面会回调到传进来的CompletionHandler的invoke中，所以在上面例子中打印了job执行完成的日志。\ninvokeOnCompletion监听job的异常 还是通过一个例子来分析下：\n1 2 3 4 5 6 7 8 9 10 11 12 private fun demo3(){ val exceptionHandler =CoroutineExceptionHandler{ coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;demo3: CoroutineExceptionHandler--异常信息：${throwable?.message}\u0026#34;) } val job = GlobalScope.launch(exceptionHandler) { Log.d(TAG, \u0026#34;demo3: launch代码\u0026#34;) throw RuntimeException(\u0026#34;协程体里面发生异常了\u0026#34;) } job.invokeOnCompletion { Log.d(TAG, \u0026#34;demo3: invokeOnCompletion--异常信息：${it?.message}\u0026#34;) } } 此处用了一个CoroutineExceptionHandler方法，来创建CoroutineExceptionHandler对象来拦截异常的，这块先不用管，我们看下日志：\n1 2 3 com.example.coroutinescopedemo D demo3: launch代码 com.example.coroutinescopedemo D demo3: CoroutineExceptionHandler--异常信息：协程体里面发生异常了 com.example.coroutinescopedemo D demo3: invokeOnCompletion--异常信息：协程体里面发生异常了 可以看出来，invokeOnCompletion中也能收到异常的消息。 但是异常和正常收数据可能不太一样，主要区别是在resumeWith之后的处理不太一样： 如果是非异常的话，会走tryFinalizeSimpleState；如果是异常的时候会走tryMakeCompletingSlowPath，在该方法里面会触发finalizeFinishingState方法，该方法有个很重要逻辑： 由于cancelParent返回false，所以会触发handleJobException，StandaloneCoroutine重写了该方法： handleCoroutineException： 如果context中CoroutineExceptionHandler不为空，则异常不会往上抛了，所以此例中定义了context的CoroutineExceptionHandler程序不会崩溃。 回到上面再来看invokeOnCompletion的CompletionHandler触发时机，它是在finalizeFinishingState中触发，接着会调用到completeStateFinalization，最终在里面触发了invokeOnCompletion传进来的CompletionHandler。\n协程异常try住：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private fun demo4() { val exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;demo4: CoroutineExceptionHandler--异常信息：${throwable?.message}\u0026#34;) } val job = GlobalScope.launch(exceptionHandler) { try { Log.d(TAG, \u0026#34;demo4: launch代码\u0026#34;) throw RuntimeException(\u0026#34;协程体里面发生异常了\u0026#34;) } catch (e: Exception) { Log.d(TAG, \u0026#34;demo4: catch中代码\u0026#34;) } } job.invokeOnCompletion { Log.d(TAG, \u0026#34;demo4: invokeOnCompletion--异常信息：${it?.message}\u0026#34;) } } 日志如下：\n1 2 3 com.example.coroutinescopedemo D demo4: launch代码 com.example.coroutinescopedemo D demo4: catch中代码 com.example.coroutinescopedemo D demo4: invokeOnCompletion--异常信息：null 从日志中看，此处的CoroutineExceptionHandler不回调，并且invokeOnCompletion收不到异常信息。 我们通过字节码可以看到原因： 此处的异常catch住后，给到JobSupport就不是异常了，所以按照成功的处理方式一样。\n","date":"2024-12-16T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"协程的异常处理"},{"content":"首先看一个例子： 日志如下： 字节码如下： launch部分启动的协程的invokeSuspend逻辑里面，只有label0的逻辑，和withContext不同的是会有挂起部分的判断，所以是同步执行的。\nasync的异步执行： 日志如下： 可以看到async2是先执行的，因为它没有进行delay，等到两个async执行完了后，才会执行launch里面的代码。 字节码如下： 编译后的代码： label=0的时候，通过async启动了两个协程，我们这里叫async1和async2，并且在里面通过await挂起了launch启动的协程。 分析：async1调用await后，由于状态是COROUTINE_SUSPENDED，所以第一次invokeSuspend方法结束，此时label=1。等到await逻辑执行完后，又会第二次执行invokeSuspend方法，此时由于lable=1，会执行async2的await方法，此时返回COROUTINE_SUSPENDED，所以invokeSuspend第二次结束，此时label=2。等到async2的await执行完后，第三次执行invokeSuspend方法，由于此时label=2，所以此时切回到自己的线程，执行launch部分的代码逻辑。\n","date":"2024-11-28T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/","title":"协程的同步执行原理"},{"content":"先来一个例子： 日志如下： 可以看到上面先是执行了withContext中的代码，然后执行了launch中的代码，注意到launch中也是在单独线程中执行的，其中launch中使用的Dispatcher是Dispatchers.Default类型的。前面分析过launch调度情况，最后会执行到continuation的resumeWith，然后调用它的invokeSuspend方法： 可以看到先执行withContext，因为withContext启动的时候，默认的状态是COROUTINE_SUSPENDED，所以退出了，返回了var2，此时的label=1了。当执行完withContext的时候，会通知传给withContext的continuation，也就是上面的CoroutineDispatchersActivity$demo2$1这个SuspendLambda。所以会再次执行它的invokeSuspend方法，此时lable=1，所以最后返回了Unit.INSTANCE，整个invokeSuspend结束，这就是挂起的原因。 至于为什么在CoroutineDispatchersActivity$demo2$1中遇到了返回值为COROUTINE_SUSPENDED时候，不会继续执行了呢？看下BaseContinuationImpl中的resumeWith逻辑： 在BaseContinuationImpl中的resumeWith中，如果invokeSuspend返回值是COROUTINE_SUSPENDED，则直接return了，不往上层的continuation调用了。\n至于再次执行CoroutineDispatchersActivity$demo2$1的invokeSuspend方法是在什么时候，可以追溯到withContext中： 执行了block的startCoroutineCancellable： 此处很熟悉啊，这不又启动了一个协程吗？协程套协程啊。好吧，我们直接看completion的回调，在协程挂起函数执行完后，会执行complete的resumeWith方法，此处是DispatchedCoroutine对象，继承自ScopeCoroutine： 它是先取continuation中context的ContinuationInterceptor，也就是上面launch启动的dispatchers，对应的是Dispatchers.Default，最终执行Dispatchers的resumeCancellableWith方法，在该方法里面最终会在协程指定的线程中执行协程代码块。所以在上面日志中能看到withContext执行完后，launch之后的代码能回到指定的线程中执行。\nwithcontext执行完了后会执行外面协程的resumeWith，所以launch的invokeSuspend再次执行。再次执行的时候会回到自己的线程。真相大白了！\n","date":"2024-11-15T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E6%8C%82%E8%B5%B7%E5%8E%9F%E7%90%86/","title":"协程挂起原理"},{"content":"在上一节介绍过Dispatchers.IO，它是一个CoroutineDispatcher对象，CoroutineDispatcher的执行是在DispatchedContinuation中的resumeCancellableWith方法，如果CoroutineDispatcher的isDispatchNeeded返回true，则会执行CoroutineDispatcher的dispatch方法。否则直接执行该runnable。\nDispatchers.Main 在安卓平台下，它其实是一个HandlerContext对象： 看下它的isDispatchNeeded和dispatch方法： 此时invokeImmediately默认是false，因此isDispatchNeeded返回true。所以会执行它的dispatch方法。在dispatch方法中将runnable给到了主线程的消息队列中，然后等主线程从消息队列中取该runnable。所以在上一节例子中它是晚于onCreate方法执行的。\nDispatchers.Main.immediate 它是HandlerContext中的immediate变量: 可以看到它是新创建了一个HandlerContext，并且invokeImmediately是true。在上一节的例子中，它的isDispatchNeeded返回false。所以它是直接执行SuspendLambda的resumeWith方法，因此上一节例子中它是要早于Dispatchs.Main执行的。\nDispatchers.IO 看下它的CoroutineDispatcher，对应的子类是DefaultIoScheduler，CoroutineDispatcher的isDispatchNeeded方法默认返回true，所以会执行它的dispatch方法： 在dispatch方法中调用了default的dispatch方法，default实际是一个LimitedDispatcher方法，看下它的dispatch方法： 在上面2处，判断当前runningWokers的数量，如果大于parallelism的时候，则不创建Worker，此处的parallelism的大小是64。从此处也能看出来Dispatchers.IO的线程数量不会超过64个。 最终该方法里面会通过DefaultScheduler.dispatchWithContext来创建CoroutineScheduler，来看下创建线程池的几个参数： 核心线程数： 最小2个，最大是cpu的核数 最大线程数： 最大线程数取值(1 shl BLOCKING_SHIFT) - 2：最终得到的值是2^21-2 = 2097150。 非核心线程空闲时间是60s。\n结论：Dispatchers.IO创建的最大的线程个数为:Math.max(64,cpu核数)\nDispatchers.Default 它是由DefaultScheduler构建的线程池，它所创建的最大的线程个数为:Math.max(2,cpu核数)\nDispatchers.IO和Dispatchers.Default都是由DefaultScheduler构建的，而DefaultScheduler其实是一个单例，因此不难看出它两是共用一个线程池的，只不过当Dispatchers.IO时候，最大线程个数控制在Math.min(64,cpu核数)，最多不会超过64个，Dispatchers.Default控制在cpu核数个数上。Dispatchers.Default常用作cpu密集型的任务，比如图片模糊处理、繁杂的计算型可以用这种类型的线程池。Dispatchers.IO由于它的线程数量多，并且它不能消耗cpu资源，因此常用作io处理，文件读写等操作上。 关于这点，可以看这篇文章：dispatcher拆解\n","date":"2024-11-13T00:00:00Z","image":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/cover_hu17536845123992820283.jpg","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/","title":"协程中的线程"},{"content":"在讲解如何切换线程之前，有必要先了解下CoroutineScope。协程作用域，它里面持有CoroutineContext，用来管理它的作用域范围内的所有协程。\nCoroutineScope(协程作用域) CoroutineScope组成 可见它只是一个接口，里面定义了一个coroutineContext。前面介绍过coroutineContext是协程的上下文，它里面是由Element拼接而成的，而Element主要分为如下几种：\nCoroutineDispatcher：它是线程分发器。其中Dispatcher.IO和Dispatcher.Main、Dispatchers.Main.immediate都是继承自于它 Job：它是用来取消协程、父协程与子协程取得联系的桥梁。常见的有SupervisorJob CoroutineName：用来给协程起名字的作用 CoroutineExceptionHandler：它是用来捕捉协程异常的回调器 所以完整的CoroutineContext组成部分如下： job+dispatchers+CoroutineName+CoroutineExceptionHandler\nCoroutineScope分类 目前kotlin已经内置了各种CoroutineScope，下面来说下他们的区别\nGlobalScope 上面用到的GlobalScope就是一个协程作用域： 可以看出来它是一个单例的scope，生命周期和app保持一致，并且它的context是一个EmptyCoroutineContext。平时开发时候不会去用它\nrunBlocking 是一个阻塞式的协程作用域，会阻塞协程外面的线程，内部是通过java的LockSupport.park阻塞住线程来实现的。 MainScope 它是一个指定协程分发在主线程中，并且使用到的Job是SupervisorJob，它的作用是当子协程出错的时候，不影响到父协程中的其他子协程 它是一个ContextScope，继承自CoroutineScope，并且它的context是由SupervisorJob()和Dispatchers.Main组成的一个context。我们一般自定义CoroutineScope的时候也是定义一个ContextScope，他的构造方法需要传入一个CoroutineContext。 CoroutineScope顶级方法 它也是一个ContextScope，它的上下文先看传进来的context中的job是否为空，如果为空，则初始化一个job。如果不为空，则使用传进来的context。\ncoroutineScope顶级方法 它是一个suspend方法，它是通过闭包的形式返回一个CoroutineScope，对应的字节码如下： 会将ScopeCoroutine给到block，也就是闭包中的CoroutineScope，接着会调用UndispatchedKt.startUndispatchedOrReturn: 最终调用了block.invoke方法，写个demo看下效果： 日志如下： 从日志可以看出来，它是先等到coroutineScope里面delay执行完了，才执行外面的逻辑。在字节码层面，它会把coroutineScope外面的代码编译成SuspendLambda，它也是个Continuation，等到执行完了coroutineScope内部的代码，才会回调到coroutineScope外面的SuspendLambda中来： 上面分析过UndispatchedKt.startUndispatchedOrReturn中调用了block的invoke方法，此处的block正对应了CoroutineDispatchersActivity$demo7$1这个SuspendLambda对象： 在demo7中将CoroutineDispatchersActivity$demo7$1这个continuation传递到coroutineScope中，而它的invoke方法如下： 创建了CoroutineDispatchersActivity$demo7$1后，继而调用了invokeSuspend方法，而invokeSuspend里面是要等到coroutineScope闭包中的delay挂起结束后，才会再次回到invokeSuspend方法，最后才会输出「demo7: coroutineScope outside」的日志，这也是协程挂起的调用顺序。\nsupervisorScope顶级方法 它和上面的coroutineScope顶级方法差不多，也是先调用完闭包中的逻辑，然后才执行supervisorScope外面的代码。看下它的实现就知道区别了： 他所使用的CoroutineScope是一个SupervisorCoroutine，它和上面用到的ScopeCoroutine区别是重写了childCancelled方法，并返回false，此方法是子协程发生异常后，该不该取消其它的子协程，下面来验证下： 在supervisorScope闭包中launch1发生异常了，由于supervisorScope不会去处理异常，将异常交给了launch1处理，所以launch2中的代码能继续执行。而在coroutineScope中，当launch1发生异常的时候，会将异常交给了coroutineScope，最终导致launch2的协程无法继续执行。\nJob Job实现了CoroutineContext.Element，可以用来取消、启动一个协程，并且和父协程绑定了关系： 它下面有几个关键的子类： 从图上可以看出来前面分析的coroutineScope和supervisorScope两个顶级方法所使用的作用域ScopeCoroutine最终也是一个Job。\n线程例子 先看一个例子： 分别指定了四种线程的用法，日志如下： 第一次： 第二次： Dispatchers.Main.immediate：指定的主线程会最先执行 Dispatchers.Main：指定的主线程会晚于协程外面的主线程 Dispatchers.IO和Dispatchers.Default：指定的线程没有先后之分\nCoroutineScope.lanuch lanuch方法是协程作用域的扩展方法，比如上面例子中的GlobalScope它就是继承自CoroutineScope:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public fun CoroutineScope.launch( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -\u0026gt; Unit ): Job { //① val newContext = newCoroutineContext(context) //② val coroutine = if (start.isLazy) LazyStandaloneCoroutine(newContext, block) else StandaloneCoroutine(newContext, active = true) //③ coroutine.start(start, coroutine, block) //④ return coroutine } 参数： context：launc传进来的context，比如上面例子中传进来的Dispatchers.Main、Dispatchers.IO这些都是CoroutineContext。如果没传就用EmptyCoroutineContext。 start：CoroutineStart的枚举类，表示启动模式，默认是DEFAULT block：协程代码块，是一个CoroutineScope的扩展挂起函数 将外界传进来的context和当前CoroutineScope的context进行合并处理 默认是DEFAULT模式，所以会初始化一个StandaloneCoroutine，会把newContext作为自己的parentContext，它既是一个Continuation，也是一个CoroutineScope 调用StandaloneCoroutine的start方法，并把启动模式，StandaloneCoroutine，协程挂起函数传进去了 StandaloneCoroutine作为lauch的返回值 StandaloneCoroutine它是一个Job类型，也是继承自AbstractCoroutine，看下它的start方法： 这里调用了start变量的invoke方法，因为CoroutineStart重写了invoke方法，所以能直接这么调，相当于是一个闭包的调用方式，这里调用了三参的invoke： 第一个参数：挂起函数闭包，也就是协程要执行的代码块 第二个参数：start方法传进来的StandaloneCoroutine 第三个参数：start方法传进来的this，也是StandaloneCoroutine CoroutineStart是DEFAULT类型，所以会调用挂起函数的startCoroutineCancellable方法： 在上面分析createCoroutine时候也是通过createCoroutineUnintercepted(receiver, completion).intercepted()，创建了delegate，最终是一个Continuation，也是一个suspendLambda。我们直接看ContinuationImpl的intercepted方法： intercepted方法里面取context变量中的key为ContinuationInterceptor的context，而context最终是completion的context，completion是前面start方法传进来的StandaloneCoroutine，它是继承自AbstractCoroutine： parentContext是launch方法传进来的context+CoroutineScope自己的context拼接的一个context this：AbstractCoroutine实现了job接口，job也是一个CoroutineContext 在上面例子中lauch方法是通过GlobalScope启动的，它的context是一个EmptyCoroutineContext，所以传给AbstractCoroutine的parentContext其实就是launch方法传进去的context，也就是Dispatchers.io、Dispatchers.main等。 回到ContinuationImpl的intercepted方法，取context的ContinuationInterceptor,然后调用interceptContinuation方法，看下Dispatchers.io，它最终继承自CoroutineDispatcher： 结论： 如果lauch传的是Dispatchers.io，则lauch先创建DispatchedContinuation，然后调用resumeCancellableWith方法： 如果dispatcher.isDispatchNeeded（默认是true），才会进入到dispatch逻辑，看下dispatchers.io： 调用了default.dispatch方法，diefault是由UnlimitedIoScheduler.limitedParallelism创建的LimitedDispatcher，最终会执行到UnlimitedIoScheduler.dispatch方法： DefaultScheduler的dispatchWithContext方法如下： coroutineScheduler创建如下： 最终会执行到CoroutineScheduler的dispatch方法，里面的代码就不细看了，是线程池部分执行block，关于这部分后面可以深究下，而block是在DispatchedContinuation中resumeCancellableWith方法里面把this给到了dispatcher的dispatch方法，说明DispatchedContinuation实现了Runnable接口，直接看它的run方法，该方法定义在它的父类DispatchedTask中： 此处执行了delegate的resume方法，resume方法执行了resumeWith，注意此处的delegate是DispatchedContinuation中传进来的continuation，它是createCoroutineUnintercepted(receiver, completion).intercepted()创建的delegate，是一个continuation对象，也是suspendlambda，在上面创建协程分析过baseContinuationImpl的resumeWith方法，里面会执行协程的invokeSuspend方法，也就是我们的协程执行代码。执行完了后会执行complete的resumeWith，而通过lauch创建的协程，此处的complete是launch方法构造的StandaloneCoroutine对象，它的resumeWith方法定义在AbstractCoroutine中： AbstractCoroutine的afterCompletion： 此处没有逻辑执行。 我们注意到在讲解协程启动的时候，创建delegate的continuation时候调用createCoroutineUnintercepted只传了complete，没有传receiver。而在launch启动协程时候，将StandaloneCoroutine作为receiver传给了createCoroutineUnintercepted方法： 默认的挂起函数的create方法是抛异常的，需要SuspendLambda的子类自己去实现： 编译后的SuspendLambda的子类create实现： 此处将receiver传到create中没有用到，所以其实跟单参没有什么区别啊。\n总结 结论：协程在启动过程中会取CoroutineContext中的ContinuationInterceptor，然后执行interceptContinuation。而此时如果是一个Dispatchers.IO，它又是继承自CoroutineDispatcher，所以会执行到了CoroutineDispatcher的interceptContinuation。此时得到的是一个DispatchedContinuation对象，并把当前的CoroutineDispatcher和协程启动过程中创建的StandaloneCoroutine传给了。接着会执行DispatchedContinuation的resumeCancellableWith方法，在该方法里面会判断CoroutineDispatcher.isDispatchNeeded，如果是的话，会调用CoroutineDispatcher的dispatch方法，最终会通过线程池会执行到DispatchedContinuation的run方法，因为它是一个Runnable对象。在run方法里面，会执行continuation的resume方法，而此处的continuation是编译器给我们创建的SuspendLambda的子类，最终会执行它的invokeSuspend方法。执行完后会执行协程启动过程中的StandaloneCoroutine的resumeWith方法。 时序图: ","date":"2024-11-05T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E7%BA%BF%E7%A8%8B/","title":"协程如何切换线程"},{"content":" 在讲协程的如何切换线程之前，有必要先了解下协程的上下文是什么？它的结构是什么样的？以及我们如何使用它？今天带着该问题来认识它。\nCoroutineContext 协程上下文都是继承自CoroutineContext，它是一个接口，内部方法以及内部类如下：\n它的实现子类有如下：\n比如我们常见的EmptyCoroutineContext，它的内部实现如下：\n可以看到它的get、fold、plus、minusKey几个方法都是默认实现，你可以理解它就是个空壳子的context。\nElement 在讲CoroutineContext内部结构之前，先来认识下Element，它也实现了CoroutineContext接口：\nElement中有一个key的属性，这里可以理解key就是当前Element的唯一标识。实现一个context的时候需要指明它的key是啥，此处就是用该key来标识 get：如果传进来的key和自己的key相等，则返回自己，否则返回null fold：将初始值和当前element返回给lambda，让lambda自己去处理 minusKey：如果传进来的key和自己相同，则返回EmptyCoroutineContext，否则返回自己，其实是删除对应key的context.\n写了3个context，然后用\u0026quot;+\u0026ldquo;拼接：\n自定义context的时候，需要继承自AbstractCoroutineContextElement，它是继承自Element，因为它强制要求需要一个key作为context的标识，一般key的element标识是当前context，看上面的One这个context，它的key拥有的element是One。\n输出日志如下：\nOne()+Two()+Three()得到的是一个CombinedContext，get方法通过One这个key取到了One这个取对应的Context\n日志如下： 可以看到我给One的context拼接了一个EmptyCoroutineContext时候，得到的是它自己，\u0026quot;+\u0026ldquo;是重载了context的plus方法，看下plus方法的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public operator fun plus(context: CoroutineContext): CoroutineContext = //① if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation //② context.fold(this) { acc, element -\u0026gt; //③ val removed = acc.minusKey(element.key) //③.1 if (removed === EmptyCoroutineContext) element else { // make sure interceptor is always last in the context (and thus is fast to get when present) //④ val interceptor = removed[ContinuationInterceptor] //⑤ if (interceptor == null) CombinedContext(removed, element) else { //⑥ val left = removed.minusKey(ContinuationInterceptor) //⑦ if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else //⑧ CombinedContext(CombinedContext(left, element), interceptor) } } } 1.如果传进来的context是EmptyCoroutineContext，则返回自己，所以上面的One()+EmptyCoroutineContext，得到的是One这个context 2.context.fold，会把初始值和context传给闭包，所以acc是当前context，element是传进来的context 3.acc.minuskey(element.key)，如果传进来的context的key和当前context的key相等，则返回传进来的context，所以新的context会把旧的context给覆盖掉了 4.如果传进来的context的key和当前context的key不相等，removed则是当前context，查看当前context中是否有ContinuationInterceptor类型的context，我们的dispatcher都是属于该类型，需要单独处理 5.如果context中没有ContinuationInterceptor类型的context，则初始化出一个CombinedContext的context，所以上面的One()+Two()+Three()是一个CombinedContext的context 6.如果当前context中存在ContinuationInterceptor类型的context，则继续判断当前context是不是ContinuationInterceptor类型的context 7.如果是ContinuationInterceptor类型的context，则把传进来的context和当前的context组合成CombinedContext的context 8.如果当前的context不是一个ContinuationInterceptor类型的context，则把当前当前的context和传进来的context新组合成一个CombinedContext的context，再和前面的ContinuationInterceptor组合成一个新的CombinedContext的context\nCombinedContext 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 internal class CombinedContext( private val left: CoroutineContext, private val element: Element ) : CoroutineContext, Serializable { override fun \u0026lt;E : Element\u0026gt; get(key: Key\u0026lt;E\u0026gt;): E? { var cur = this while (true) { cur.element[key]?.let { return it } val next = cur.left if (next is CombinedContext) { cur = next } else { return next[key] } } } public override fun \u0026lt;R\u0026gt; fold(initial: R, operation: (R, Element) -\u0026gt; R): R = operation(left.fold(initial, operation), element) public override fun minusKey(key: Key\u0026lt;*\u0026gt;): CoroutineContext { //① element[key]?.let { return left } //② val newLeft = left.minusKey(key) return when { //③ newLeft === left -\u0026gt; this //④ newLeft === EmptyCoroutineContext -\u0026gt; element //⑤ else -\u0026gt; CombinedContext(newLeft, element) } } override fun toString(): String = \u0026#34;[\u0026#34; + fold(\u0026#34;\u0026#34;) { acc, element -\u0026gt; if (acc.isEmpty()) element.toString() else \u0026#34;$acc, $element\u0026#34; } + \u0026#34;]\u0026#34; } 它是直接继承自CoroutineContext，有两个比较重要的属性：\nleft：CoroutineContext，它是左边的节点\nelement：Element，当前节点\n其实和链表的结构有点类似，left相当于next节点。\nget：递归节点，直到left节点不是CombinedContext类型的\nfold：先把left和初始值组成一个初始值，然后再把这个初始值和当前节点传给闭包\nminusKey：\n1.如果当前节点中找到了该key，则返回left节点\n2.如果找不到，则继续在left节点中找\n3.如果找不到返回this\n4.如果找到了则返回当前节点\n5.否则继续往左边再找\n整个分析来看，协程中的context如果是多个context拼接的时候如果传进来的是EmptyCoroutineContext，则只保存自己。如果传进来的context的key和当前context的key一样，则会覆盖掉原来的context。如果都不满足，则采用链表的形式插入到原来的context头节点上，如果传进来的是ContinuationInterceptor类型的，则会把该类型放到头节点。\n类图 再来一张本次讲解的context类图：\n","date":"2024-11-04T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87/","title":"协程上下文"},{"content":"kotlin中inline，noinline，crossinline区别？ 默认函数中如果没加inline，那就是非内联函数，此时lambda会生成一个新的类，该类是继承自Lambda抽象类，并实现了Function接口，其中invoke方法就是Function接口的方法，invoke中的方法就是lambda代码块的代码。 内联函数(加inline关键字)的lambda如果没加noinline或crossinline，默认会把lambda的代码块给平铺到调用处，所以此时如果在lambda中加return的话，会直接不执行外层函数后续代码。如果是非内联函数的话，由于它是生成一个单独的类，不存在平铺代码，所以return是编译不过去的。 noinline和inline是对立关系，它是将lambda不内联处理，如果你需要对该lambda作为对象来使用的时候，此时需要用到noinline，如果一个内联函数都是noinline的lambda表达式，那么此时as会提示你此处可以去掉inline关键字了，当做普通的高阶函数来处理就行。 crossinline算是在内联和非内联之间做智能化选择，如果你将lambda表达式当做变量来使用，此时编译器不会内联该lambda，比如： 1 2 3 4 5 6 7 8 9 10 11 inline fun hello4(run1: () -\u0026gt; Unit, crossinline run: () -\u0026gt; Unit) { run1() hello5 { run() } println(\u0026#34;hello4后续代码\u0026#34;) } fun hello5(run: () -\u0026gt; Unit) { run() println(\u0026#34;hello5后续代码\u0026#34;) } 上面我将hello4中的run表达式传给了hello5，而hello5不是一个内联函数，所以此时会把lambda作为一个变量传到hello5中： 如果改成如下方式：\n1 2 3 4 5 6 7 8 9 10 11 inline fun hello4(run1: () -\u0026gt; Unit, crossinline run: () -\u0026gt; Unit) { run1() hello5 { run() } println(\u0026#34;hello4后续代码\u0026#34;) } inline fun hello5(run: () -\u0026gt; Unit) { run() println(\u0026#34;hello5后续代码\u0026#34;) } 相关文档：https://juejin.cn/post/6869954460634841101\njava lambda和kotlin lambda区别 在java中如果使用匿名内部类的形式，在编译时它是会单独生成一个类，其中类名是「外部类名$index.class」这种形式。如果使用lambda的形式，它不会在编译时单独生成一个类，它是执行了invokedynamic指令，在运行时动态生成lambda的类，其中类名是「外部类名$Lambda$index.class」这种形式。 参考:https://juejin.cn/post/7004642395060961310 kotlin lambda它是在编译时看是否需要生成单独的类，如果是内联的时候就直接平铺代码，如果是非内联的时候才生成单独的类。 协程是怎么挂起的？怎么恢复的？ 首先每一个协程代码块都会被编译成SuspendLambda对象，它也是一个Continuation对象，每次在执行到SuspendLambda的resume时候，都会去执行invokeSuspend方法，而该方法里面会去执行子协程，如果子协程返回SUSPEND_COROUTINE状态的时候，父协程的resume方法会直接return了。当子协程执行完后，会通知父协程，此时父协程的的invokeSuspend方法再次被执行，而此时的状态机会发生变化，如果此时状态恢复后，会执行父协程中的Continuation，也就是父父协程的执行。 协程中的dispather是怎么指定在哪个线程上执行的？ 首先dispather它是CoroutineContext（上下文）的一部分，在协程启动过程中，会取CoroutineContext中的CoroutineDispathcer部分。此时会构造一个DispathedContinuation对象，并把前面取到的Dispather传到DispathedContinuation中，此时会将DispathedContinuation扔到线程池中，最终会执行DispathedContinuation的run方法，在run里面会执行到SuspendLambda，也就是协程的代码块，最终会执行它的invokeSuspend方法。所以协程代码块中代码要执行在哪个线程是协程上下文的dispather部分指定的线程。 相关文档：https://www.xiangcman.fun/p/%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E7%BA%BF%E7%A8%8B/\n","date":"2024-11-04T00:00:00Z","permalink":"https://example.com/p/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/","title":"笔记整理"},{"content":"协程创建 demo 1 2 3 4 5 6 7 8 9 10 11 12 suspend { Log.d(TAG, \u0026#34;suspend block:\u0026#34;) \u0026#34;123\u0026#34; }.createCoroutine(object : Continuation\u0026lt;String\u0026gt; { override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result\u0026lt;String\u0026gt;) { val value = result.getOrNull() Log.d(TAG, \u0026#34;resumeWith:$value\u0026#34;) } }).resume(Unit) Log.d(TAG, \u0026#34;onCreate\u0026#34;) 上面日志先打印suspend中的代码块，然后执行Continuation的resumeWith，最后执行主线程的代码。\ncreateCoroutine 是挂起函数的扩展方法，方法参数是Continuation类型，对应上面的匿名内部类。创建了一个SafeContinuation对象，它也是一个Continuation类型，并传递两个参数。\nresume resume方法会调用resumeWith，看下SafeContinuation的resumeWith方法： 此处提醒下，kotlin的源码需要到对应的** Jvm类下找，要不然方法只是一个申明。此处的result是构造SafeContinuation传递进来的COROUTINE_SUSPENDED，因此会执行delegate.resumeWith(result)，此处的delegate是createCoroutineUnintercepted(completion).intercepted()创建的。\ncreateCoroutineUnintercepted 它是挂起函数的扩展方法：\n判断当前挂起函数是不是BaseContinuationImpl类型，如果是则调用create方法。\n此时可以打开字节码，看下上面的(suspend () -\u0026gt; T)是什么对象？\n可以看到createCoroutine方法传入了两个参数，我们都知道扩展函数最终编译出来的方法第一个参数是被扩展对象，所以此处的CoroutineActivity$onCreate$1就是(suspend () -\u0026gt; T)，CoroutineActivity$onCreate$2对应的是例子中的Continuation匿名内部类。我们注意下，此时传入CoroutineActivity$onCreate$1中的Continuation参数是null。\n而SuspendLambda的继承关系如下：\n所以会调用挂起函数的create方法：\n父类中要求子类必须重写该方法，我们看CoroutineActivity$onCreate$1的create方法：\n此时重新new了一个CoroutineActivity$onCreate$1，并把completion传入其中，而此处的completion就是上面的CoroutineActivity$onCreate$2，它是一个Continuation。而开端在分析createCoroutine的时候，创建CoroutineActivity$onCreate$1传入的Continuation是null。\n不太明白，为什么不在createCoroutine时候直接直接把CoroutineActivity$onCreate$2传入到CoroutineActivity$onCreate$1中，而非要通过create方法再创建一个CoroutineActivity$onCreate$1。\n我们再来看intercepted方法。\nintercepted 是Continueation的扩展方法，当然了，刚刚create创建的CoroutineActivity$onCreate$1是一个suspendLambda对象，所以它也是ContinueationImpl，所以会走ContinueationImpl的intercepted方法：\n此处看context中有没有ContinuationInterceptor类型的Element，如果没有则返回自己，我们只要知道先返回自己。因为这个涉及到context的结构，后面再讲。\n小节： ①、createCoroutine创建了一个SafeContinuation，并把CoroutineActivity$onCreate$1和一个标志位COROUTINE_SUSPENDED传入其中。CoroutineActivity$onCreate$1继承自SuspendLambda，并且是一个Function接口的实例。SuspendLambda继承自ContinuationImpl，ContinuationImpl继承自BaseContinuationImpl，BaseContinuationImpl继承自Continuation，CoroutineActivity$onCreate$1继承自SuspendLambda，也就是上面的协成要执行的闭包。CoroutineActivity$onCreate$1持有了CoroutineActivity$onCreate$2，它实现了Continuation。CoroutineActivity$onCreate$1重写了create方法，返回了一个新的CoroutineActivity$onCreate$1对象。 ②、resume方法中会调用到SafeContinuation的resumeWith方法，最终会触发CoroutineActivity$onCreate$1的resumeWith方法。\n协程执行 CoroutineActivity$onCreate$1继承自SuspendLambda，最终会继承自BaseContinuationImpl，来看下它的resumeWith：\nresumeWith中首先调用invokeSuspend方法，如果invokeSuspend方法返回COROUTINE_SUSPENDED，则resumeWith直接不往下执行。否则看comppletion是不是BaseContinuationImpl，是的话，则继续轮训，直到comppletion不是BaseContinuationImpl，则执行它的resumeWith方法。此处的completion实际是CoroutineActivity$onCreate$2，所以会执行它的resumeWith方法。我们看下CoroutineActivity$onCreate$1的invokeSuspend方法：\n它的返回值不是COROUTINE_SUSPENDED，所有上面的invokeSuspend方法还会继续往下执行。所以最终会执行了CoroutineActivity$onCreate$2，也就是例子中的匿名内部类的resumeWith方法。\n此时我们再分析例子中日志的打印：\n可以看到执行SafeContinuation的resumeWith的时候是一个while(true)，传入的this.resume是一个COROUTINE_SUSPENDED标志位，所以会把CoroutineActivity$onCreate$1的resumeWith执行完后，才跳出while循环。因此日志最后输出协成外的代码。\n类图总结 最后输出此次的类图结构，以作回顾：\n","date":"2024-11-02T00:00:00Z","image":"https://example.com/p/android-%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%88%B0%E6%89%A7%E8%A1%8C/cover_hu17536845123992820283.jpg","permalink":"https://example.com/p/android-%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%88%B0%E6%89%A7%E8%A1%8C/","title":"Android 协程启动到执行"},{"content":"Bytecode-viewer 一款查看class文件的工具\n使用： 目录定位到该jar包下面，然后使用如下命令：\njava -jar Bytecode-Viewer-2.12.jar\nsh脚本执行文件： Bytecode-Viewer.sh\n脚本文件：\nBytecode-Viewer-2.12.jar\n来源:https://github.com/Konloch/bytecode-viewer\n动画差值器 在线预览：https://inloop.github.io/interpolator/\n","date":"2024-11-02T00:00:00Z","permalink":"https://example.com/p/%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/","title":"工具整理"},{"content":"类图 Context创建 Activity继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，当activity创建的之前，会先创建contextimpl ActivityThread.performLaunchActivity\n接着会调用contextimpl的setOuterContext，传入的是activity。\n结论：contextImpl中的outerContext指向了activity。\nContext传递 attach调用了attachBaseContext，并把contextimpl传进去了：\n该方法是ContextWrapper中的方法，并指向了mBase变量。Activity中getBaseContext和getApplicationContext区别：\ngetBaseContext指向了刚刚attach方法传进来的contextimpl。\n指向了mBase.getApplicationContext：\nmPackageInfo是在创建contextimpl的时候传入的，它是loadedApk对象，它的getApplication方法是获取应用的Application对象：\n结论：getBaseContext获取的是contextimpl对象，getApplicationContext获取的是Application对象。\n主题设置 回到performLaunchActivity，给activity设置主题：\n将theme的resid传进来，最终会把resid这个theme追加到mTheme上。这里牵扯到资源加载，后面再说。\nLayoutInflater中的context LayoutInflater.from(context)： 此处的context一般是activity，看activity.getSystemService方法，如果传入的不是activity，比如是ContextThemeWrapper，Application会怎么样：\n通过base调用getSystemService，而base其实也是activity。Application是继承自ContextWrapper：\nbase是contextimpl，最终调用的是contextimpl的getSystemService，activity亦是如此：\n从SYSTEM_SERVICE_FETCHERS中获取：\n最终是在此处添加了一个PhoneLayoutInflater对象，并把contextimpl.getOuterContext传进去了，此处传进去的是Activity对象。\nlayoutinflater.inflate: 此过程调用createViewFromTag来创建view：\n此处看view有没有theme属性，有的话，则构造一个contextthemeWrapper出来，举个例子：\n此处定义了一个theme属性，那么给该view的构造器传入的context就是一个contextThemeWrapper对象。\n在from方法里面，传入一个contextthemewrapper对象，并携带一个style。根据上面分析from方法时，contextthemewrapper是通过base.getSystemService。此处的base又是activity，又因为activity.getSystemService，调用base.getSystemService，所以最终又回到了contextimpl.getSystemService。而在创建PhoneLayoutInflater的时候，又通过contextimpl.getOuterContext传入到PhoneLayoutInflater构造器中，但是在contextthemewrapper中最后又调了PhoneLayoutInflater的cloneInContext：\n所以此种情况下，最终给view传的context也是一个contextthemewrapper的context。\nAttr部分 从主题中获取属性：\n最终这些属性是通过context的obtainStyledAttributes获取属性值。常见的方法是：\nAttributeSet表示所有的属性集，它是在inflate过程中解析到view的属性集。 attrs表示的是要从哪个属性集中取到属性。 例如：\nattrs文件中定义一个declare-styleable属性集，aapt工具会生成对应的R.class，但是此时是一个R.jar文件：\n该文件在app/build/intermediates/compile_and_runtime_not_namespaced_r_class_jar/debug/R.jar，反编译该jar文件：\n最终所有的资源类型都会生成一个R$**.class的类，而R.class其实是一个空壳：\n看刚才定义的declare-styleable生成如下：\n并且会在R$attr.class下面也会生成一个两个int值：\n可以看出来生出来一个R.styleable.TestView的数组和两个int值，分别是R.styleable.TestView_attr1和R.styleable.TestView_attr2，它两分别代表TestView数组的索引，而对应的值是定义在resource.arsc文件中：\n所以最终得出结论是：通过context.obtainStyledAttributes传入attrbuteset和attrs数组，得到了typearray，然后通过typearray的索引得到所有的属性：\ndefStyleAttr、defStyleRes 新增一个不在declare-styleable数组中的attr11，见R文件：\n在R.styleable类中没有attr11的定义，它在R.attr类中定义了：\n在上面属性中attr7和attr11是引用类型的，他们可以指向另外一个引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public class TestView1 extends View { public TestView1(Context context) { this(context, null); } public TestView1(Context context, @Nullable AttributeSet attrs) { this(context, attrs, R.attr.attr11); } public TestView1(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { this(context, attrs, defStyleAttr, R.style.DefStyleRes); } public TestView1(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context, attrs, defStyleAttr, defStyleRes); TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.gui, defStyleAttr, defStyleRes); log(\u0026#34;TypedArray length：\u0026#34; + ta.length()); for (int i = 0; i \u0026lt; ta.length(); i++) { int attrIndex = ta.getIndex(i); switch (attrIndex) { case R.styleable.gui_attr1: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr2: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr3: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr4: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr5: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr6: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr7: log(ta.getString(attrIndex)); break; default: break; } } ta.recycle(); } private void log(String msg) { Log.v(getClass().getSimpleName(), \u0026#34;\u0026#34; + msg); } } TestView1中defStyleAttr传入R.attr.attr11，defStyleRes传入R.style.DefStyleRes。 布局文件如下：\n其中theme中引用了attr11的引用，而themestyle中引用了attr1-attr4，DefStyleRes中也引用了attr1-attr4。日志如下：\nR.styleable.gui总共长度是7，attr1用的xml中定义的，attr2是布局中定义的style中的属性，attr3和attr4取的是theme中attr11定义的attr3和attr4，由于attr5没有在attr11中的style中定义，所以取的是theme中的attr5属性。 优先级：布局中的attr\u0026gt;布局中的style中的attr\u0026gt;defStyleAttr中的attr\u0026gt;theme中的attr 此时无论怎么在DefStyleRes中定义属性，都不会在该style里面的attr取值，因为此时定义了defStyleAttr 此时如果去掉defStyleAttr，则会在DefStyleRes中取值：\n结果如下：\n总结：defStyleAttr定义了后，defStyleRes中的attr就不起作用了。\n参考：https://blog.csdn.net/GracefulGuigui/article/details/104069265\n","date":"2024-10-25T00:00:00Z","permalink":"https://example.com/p/android-context%E6%80%BB%E7%BB%93/","title":"Android context总结"}]