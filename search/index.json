[{"content":"Glide中缓存分为内存缓存和磁盘缓存，而内存缓存又分为当前活跃的缓存和未使用的缓存，磁盘缓存分为解码后的缓存以及原始缓存。前面流程中介绍过解码和编码，这里面介绍过如何保存的，那获取是什么样的，我们这节就分析下。\n一级缓存 在Glide主流程中有提到过内存缓存，在主流程中都是按照加载网络数据进行分析的，我们从Engine的load方法开始讲解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class Engine{ public \u0026lt;R\u0026gt; LoadStatus load( GlideContext glideContext, Object model, Key signature, int width, int height, Class\u0026lt;?\u0026gt; resourceClass, Class\u0026lt;R\u0026gt; transcodeClass, Priority priority, DiskCacheStrategy diskCacheStrategy, Map\u0026lt;Class\u0026lt;?\u0026gt;, Transformation\u0026lt;?\u0026gt;\u0026gt; transformations, boolean isTransformationRequired, boolean isScaleOnlyOrNoTransform, Options options, boolean isMemoryCacheable, boolean useUnlimitedSourceExecutorPool, boolean useAnimationPool, boolean onlyRetrieveFromCache, ResourceCallback cb, Executor callbackExecutor) { EngineKey key = keyFactory.buildKey( model, signature, width, height, transformations, resourceClass, transcodeClass, options); EngineResource\u0026lt;?\u0026gt; memoryResource = loadFromMemory(key, isMemoryCacheable, startTime); } } 先通过KeyFactory的buildKey创建一个缓存的key，model是load方法传进来的参数，宽和高是加载的图片尺寸。resourceClass在上一节中解码时候获取LoadPath介绍过，它主要影响到过滤DecodePath，默认是Object.class，可以通过RequestOptions的decodeTypeOf方法设置。transformations是load方法传进来的参数类型，比如默认传进来一个url，则transformations是一个Drawable.class。signature是一个签名参数，默认是EmptySignature，可以通过RequestOptions的signatureOf方法进行设置。options可以配置一些参数，比如解码方式等。此处使用EngineKeyFactory的buildKey直接构建，也是一种工厂模式，只不过此处不需要外界进行构建，所以直接通过普通类创建EngineKey。接着看下loadFromMemory方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private EngineResource\u0026lt;?\u0026gt; loadFromMemory( EngineKey key, boolean isMemoryCacheable, long startTime) { if (!isMemoryCacheable) { return null; } EngineResource\u0026lt;?\u0026gt; active = loadFromActiveResources(key); if (active != null) { return active; } EngineResource\u0026lt;?\u0026gt; cached = loadFromCache(key); if (cached != null) { return cached; } return null; } isMemoryCacheable表示内存缓存是否可使用，如果可使用，调用过loadFromActiveResources方法获取一级缓存：\n1 2 3 4 5 6 7 8 private final ActiveResources activeResources; private EngineResource\u0026lt;?\u0026gt; loadFromActiveResources(Key key) { EngineResource\u0026lt;?\u0026gt; active = activeResources.get(key); if (active != null) { active.acquire(); } return active; } 通过ActiveResources的get方法获取一级缓存：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 final Map\u0026lt;Key, ResourceWeakReference\u0026gt; activeEngineResources = new HashMap\u0026lt;\u0026gt;(); synchronized EngineResource\u0026lt;?\u0026gt; get(Key key) { ResourceWeakReference activeRef = activeEngineResources.get(key); if (activeRef == null) { return null; } EngineResource\u0026lt;?\u0026gt; active = activeRef.get(); if (active == null) { cleanupActiveReference(activeRef); } return active; } void cleanupActiveReference(@NonNull ResourceWeakReference ref) { synchronized (this) { activeEngineResources.remove(ref.key); if (!ref.isCacheable || ref.resource == null) { return; } } EngineResource\u0026lt;?\u0026gt; newResource = new EngineResource\u0026lt;\u0026gt;( ref.resource, /* isMemoryCacheable= */ true, /* isRecyclable= */ false, ref.key, listener); listener.onResourceReleased(ref.key, newResource); } 在get方法中先从activeEngineResources这个map中获取ResourceWeakReference，它是一个弱引用，里面存储的对象是EngineResource：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 static final class ResourceWeakReference extends WeakReference\u0026lt;EngineResource\u0026lt;?\u0026gt;\u0026gt; { final Key key; final boolean isCacheable; Resource\u0026lt;?\u0026gt; resource; ResourceWeakReference( @NonNull Key key, @NonNull EngineResource\u0026lt;?\u0026gt; referent, @NonNull ReferenceQueue\u0026lt;? super EngineResource\u0026lt;?\u0026gt;\u0026gt; queue, boolean isActiveResourceRetentionAllowed) { super(referent, queue); this.key = Preconditions.checkNotNull(key); this.resource = referent.isMemoryCacheable() \u0026amp;\u0026amp; isActiveResourceRetentionAllowed ? Preconditions.checkNotNull(referent.getResource()) : null; isCacheable = referent.isMemoryCacheable(); } void reset() { resource = null; clear(); } } 在get方法中如果若引用没有获取到，则返回null，如果获取到，则继续获取弱引用中的对象（EngineResource），如果弱引用中的对象为空，则调用cleanupActiveReference方法，在该方法里面通过弱引用中的key将该弱引用从map中移除掉，并回调onResourceReleased方法。\n弱引用有个特点，如果在GC的时候，发现弱引用包装的对象没有强引用指向的时候，此时对象只被弱引用所引用了，变成”弱可达“，下一次GC时，弱引用指向的对象被立即回收。比如下面代码：\n1 2 Object obj = new Object(); WeakReference\u0026lt;Object\u0026gt; weakRef = new WeakReference\u0026lt;\u0026gt;(obj); 此时对象生命周期： •\t有一个 强引用（obj） •\t有一个 弱引用（weakRef）\n对象不会被回收，因为有强引用。 当obj = null时，此时： •\t对象只被弱引用引用 •\t变成了 “弱可达”（Weakly reachable） 下一阶段就是GC回收弱引用指向的对象。 GC 动作： 1.\tGC 扫描弱引用所引用的对象 2.\t发现其没有强引用 → 立即清除对象 3.\tweakRef.get() 返回 null 4.\t同时将 weakRef 放入 ReferenceQueue（如果你创建了的话） 下一阶段：弱引用本身仍存在，但已经失效\n1 weakRef.get() == null 弱引用对象（WeakReference 实例）本身不会被立即回收，它只是不再指向有效对象。\n所以上面当弱引用所指向的对象为空的时候，说明EngineResource已经被回收了。该从下一个缓存取了。若找到了，调用EngineResource的acquire：\n1 2 3 4 5 6 7 8 class EngineResource{ synchronized void acquire() { if (isRecycled) { throw new IllegalStateException(\u0026#34;Cannot acquire a recycled resource\u0026#34;); } ++acquired; } } 二级缓存 它表示当前图片正在使用的次数，后面会用到，知道当前给acquired累加次数就行。接着回到上面Engine的loadFromMemory方法，如果在一级缓存中找不到，接着调用了loadFromCache方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private EngineResource\u0026lt;?\u0026gt; loadFromCache(Key key) { EngineResource\u0026lt;?\u0026gt; cached = getEngineResourceFromCache(key); if (cached != null) { cached.acquire(); activeResources.activate(key, cached); } return cached; } private final MemoryCache cache; private EngineResource\u0026lt;?\u0026gt; getEngineResourceFromCache(Key key) { Resource\u0026lt;?\u0026gt; cached = cache.remove(key); final EngineResource\u0026lt;?\u0026gt; result; if (cached == null) { result = null; } else if (cached instanceof EngineResource) { result = (EngineResource\u0026lt;?\u0026gt;) cached; } else { result = new EngineResource\u0026lt;\u0026gt;( cached, /* isMemoryCacheable= */ true, /* isRecyclable= */ true, key, /* listener= */ this); } return result; } 此处从cache中取Resource，如果取到了返回EngineResource，此处的cache是LruResourceCache对象，它是LruCache实现的。可以看到它是获取的时候直接remove掉了，紧接着调用acquire，并把缓存放到一级缓存中(activeResources.activate)。\n","date":"2025-12-01T16:47:20+08:00","permalink":"http://xiangcman.xyz/p/glide%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B/","title":"Glide缓存流程"},{"content":"LoadData相关讲解 glide编码流程主要是通过ModelLoader、LoadData等类进行完成的，下面先介绍这几个类的类图关系：\nModelLoader 是用来构建LoadData，而LoadData中对应了不同的DataFetcher，DataFetcher是最终加载数据层。\n在上一节中介绍过SourceGenerator在startNext方法中fetcher是HttpUrlFetcher，以及在获取到数据后，进行保存到磁盘，然后调用了DataCacheGenerator的startNext方法，然后在里面用到了ByteBufferFetcher，它们都是怎么来的呢？下面通过源码分析如何获取的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class SourceGenerator{ public void startNext(){ loadData = null; boolean started = false; while (!started \u0026amp;\u0026amp; hasNextModelLoader()) { loadData = helper.getLoadData().get(loadDataListIndex++); if (loadData != null \u0026amp;\u0026amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource()) || helper.hasLoadPath(loadData.fetcher.getDataClass()))) { started = true; startNextLoad(loadData); } } } } 在SourceGenerator的startNext方法中有上面代码，首先通过hasNextModelLoader方法判断有没有合适的LoadData：\n1 2 3 private boolean hasNextModelLoader() { return loadDataListIndex \u0026lt; helper.getLoadData().size(); } 判断当前索引是否小于helper获取的loadData的数量，helper是DecodeHelper辅助类，它是在DecodeJob中初始化的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 List\u0026lt;LoadData\u0026lt;?\u0026gt;\u0026gt; getLoadData() { if (!isLoadDataSet) { isLoadDataSet = true; loadData.clear(); List\u0026lt;ModelLoader\u0026lt;Object, ?\u0026gt;\u0026gt; modelLoaders = glideContext.getRegistry().getModelLoaders(model); for (int i = 0, size = modelLoaders.size(); i \u0026lt; size; i++) { ModelLoader\u0026lt;Object, ?\u0026gt; modelLoader = modelLoaders.get(i); LoadData\u0026lt;?\u0026gt; current = modelLoader.buildLoadData(model, width, height, options); if (current != null) { loadData.add(current); } } } return loadData; } glideContext是glide统一的上下文，它继承自ContextWrapper，是在Glide对象初始化的时候创建的，接着调用了getRegistry方法，该方法的定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public final class GlideSuppliers { public interface GlideSupplier\u0026lt;T\u0026gt; { T get(); } private GlideSuppliers() {} public static \u0026lt;T\u0026gt; GlideSupplier\u0026lt;T\u0026gt; memorize(final GlideSupplier\u0026lt;T\u0026gt; supplier) { return new GlideSupplier\u0026lt;T\u0026gt;() { private volatile T instance; @Override public T get() { if (instance == null) { synchronized (this) { if (instance == null) { instance = Preconditions.checkNotNull(supplier.get()); } } } return instance; } }; } } public class GlideContext{ private final GlideSupplier\u0026lt;Registry\u0026gt; registry; public GlideContext(@NonNull Context context,@NonNull GlideSupplier\u0026lt;Registry\u0026gt; registry) { super(context.getApplicationContext()); this.registry = GlideSuppliers.memorize(registry); } public Registry getRegistry() { return registry.get(); } } getRegistry方法中是调用了GlideContext的registry变量的get方法，而registry变量是通过GlideSuppliers.memorize构建的，GlideSupplier是一个接口，定义了get方法，而在GlideSuppliers.memorize方法中返回的GlideSupplier对象中重写的get方法是通过memorize方法supplier参数的get来获取的。也就是说创建GlideSupplier对象交给了外界来创建。为什么在memorize方法中不直接返回supplier.get()呢？而需要在memorize包装一个匿名的GlideSupplier，这是因为在业务层多处调用GlideContext的getRegistry方法，如果在memorize方法中直接调用supplier.get()，那么每次返回新的Registry实例，所以在memorize方法中定义了一个匿名的GlideSupplier，在它的get方法里面通过双重加锁来控制单一的Registry实例。外界传进来的GlideSupplier是在创建Glide对象的时候构建的：\n1 2 3 4 Glide(@NonNull Context context) { GlideSupplier\u0026lt;Registry\u0026gt; registry = RegistryFactory.lazilyCreateAndInitializeRegistry(this, manifestModules, annotationGeneratedModule); glideContext =new GlideContext(context,registry); } 外界传进来的GlideSupplier是通过RegistryFactory.lazilyCreateAndInitializeRegistry来创建的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 static GlideSupplier\u0026lt;Registry\u0026gt; lazilyCreateAndInitializeRegistry(){ return createAndInitRegistry(glide, manifestModules, annotationGeneratedModule); } static Registry createAndInitRegistry( Glide glide, List\u0026lt;GlideModule\u0026gt; manifestModules, @Nullable AppGlideModule annotationGeneratedModule) { BitmapPool bitmapPool = glide.getBitmapPool(); ArrayPool arrayPool = glide.getArrayPool(); Context context = glide.getGlideContext().getApplicationContext(); GlideExperiments experiments = glide.getGlideContext().getExperiments(); Registry registry = new Registry(); initializeDefaults(context, registry, bitmapPool, arrayPool, experiments); initializeModules(context, glide, registry, manifestModules, annotationGeneratedModule); return registry; } 这样将Registry的初始化交给了RegistryFactory来创建，所有的配置收拢到一块，更加聚合。回到上面DecodeHelper的getLoadData方法，接着调用了Registry的getModelLoaders方法：\n1 2 3 public \u0026lt;Model\u0026gt; List\u0026lt;ModelLoader\u0026lt;Model, ?\u0026gt;\u0026gt; getModelLoaders(@NonNull Model model) { return modelLoaderRegistry.getModelLoaders(model); } modelLoaderRegistry是在Registry中初始化的，看下它的getModelLoaders方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public \u0026lt;A\u0026gt; List\u0026lt;ModelLoader\u0026lt;A, ?\u0026gt;\u0026gt; getModelLoaders(@NonNull A model) { List\u0026lt;ModelLoader\u0026lt;A, ?\u0026gt;\u0026gt; modelLoaders = getModelLoadersForClass(getClass(model)); int size = modelLoaders.size(); boolean isEmpty = true; List\u0026lt;ModelLoader\u0026lt;A, ?\u0026gt;\u0026gt; filteredLoaders = Collections.emptyList(); for (int i = 0; i \u0026lt; size; i++) { ModelLoader\u0026lt;A, ?\u0026gt; loader = modelLoaders.get(i); if (loader.handles(model)) { if (isEmpty) { filteredLoaders = new ArrayList\u0026lt;\u0026gt;(size - i); isEmpty = false; } filteredLoaders.add(loader); } } return filteredLoaders; } private synchronized \u0026lt;A\u0026gt; List\u0026lt;ModelLoader\u0026lt;A, ?\u0026gt;\u0026gt; getModelLoadersForClass( @NonNull Class\u0026lt;A\u0026gt; modelClass) { List\u0026lt;ModelLoader\u0026lt;A, ?\u0026gt;\u0026gt; loaders = cache.get(modelClass); if (loaders == null) { loaders = Collections.unmodifiableList(multiModelLoaderFactory.build(modelClass)); cache.put(modelClass, loaders); } return loaders; } 在getModelLoaders通过model的Class类型，调用了getModelLoadersForClass方法，在该方法里面从cache里面取拿ModelLoader集合，它是包装map的ModelLoaderCache类，首次为空，接着调用了multiModelLoaderFactory.build(modelClass)把loaders放到cache中。注意下，该方法中使用Collections.unmodifiableList包装了一层集合，该集合不允许进行添加元素，主要是为了不让后续添加新的ModelLoader，防止在边遍历的时候会有其他地方添加元素而产生ConcurrentModificationException异常。并且此处使用了cache缓存，下次直接从该map中取该model下的ModelLoader集合，无需再次进行构建。看下该方法怎么获取loaders的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 synchronized \u0026lt;Model\u0026gt; List\u0026lt;ModelLoader\u0026lt;Model, ?\u0026gt;\u0026gt; build(@NonNull Class\u0026lt;Model\u0026gt; modelClass) { try { List\u0026lt;ModelLoader\u0026lt;Model, ?\u0026gt;\u0026gt; loaders = new ArrayList\u0026lt;\u0026gt;(); for (Entry\u0026lt;?, ?\u0026gt; entry : entries) { if (alreadyUsedEntries.contains(entry)) { continue; } if (entry.handles(modelClass)) { alreadyUsedEntries.add(entry); loaders.add(this.\u0026lt;Model, Object\u0026gt;build(entry)); alreadyUsedEntries.remove(entry); } } return loaders; } catch (Throwable t) { alreadyUsedEntries.clear(); throw t; } } entries是Entry对象的集合，注意了上面使用了alreadyUsedEntries集合标记Entry有没有被构建，比如在构建a这个modelLoader中又去构建b这个modelLoader，而在b中又去构建a，这就导致循环构建，此时通过该集合能解决这个循环依赖问题，以及解决重复构建的问题，比如在a中需要构建b，那下次构建b的时候就无需再次构建了。Entry对象里面存储了modelClass、dataClass、modelLoaderFactory：\n1 2 3 4 5 private static class Entry\u0026lt;Model, Data\u0026gt; { private final Class\u0026lt;Model\u0026gt; modelClass; @Synthetic final Class\u0026lt;Data\u0026gt; dataClass; @Synthetic final ModelLoaderFactory\u0026lt;? extends Model, ? extends Data\u0026gt; factory; } 而entries集合中的Entry元素是在上面分析Registry对象创建过程中的RegistryFactory中添加进来的：\n1 2 3 4 5 6 7 8 9 public class RegistryFactory{ private static void initializeDefaults(Registry registry){ registry .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory\u0026lt;String\u0026gt;()) .append(String.class, InputStream.class, new StringLoader.StreamFactory()) .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory()) .append(String.class, AssetFileDescriptor.class, new StringLoader.AssetFileDescriptorFactory()) } } append方法三个参数对应分别对应了上面Entry对象的modelClass、dataClass、ModelLoaderFactory，所以在上面multiModelLoaderFactory的build方法中遍历entries时候，通过entry的handles(modelClass)来进行过滤：\n1 2 3 public boolean handles(@NonNull Class\u0026lt;?\u0026gt; modelClass) { return this.modelClass.isAssignableFrom(modelClass); } 如果传进来的是String类型，则会过滤出上面4个通过append方法构建的Entry对象，接着会调用multiModelLoaderFactory的build(entry)方法：\n1 2 3 private \u0026lt;Model, Data\u0026gt; ModelLoader\u0026lt;Model, Data\u0026gt; build(@NonNull Entry\u0026lt;?, ?\u0026gt; entry) { return (ModelLoader\u0026lt;Model, Data\u0026gt;) Preconditions.checkNotNull(entry.factory.build(this)); } 通过entry的factory的build方法创建ModelLoader，上面4个entry的factory分别是 DataUrlLoader.StreamFactory 、 StringLoader.StreamFactory 、 StringLoader.FileDescriptorFactory 、 StringLoader.AssetFileDescriptorFactory ，分别调用它们的build方法创建不同的ModelLoader:\n1 2 3 public ModelLoader\u0026lt;Model, InputStream\u0026gt; build(@NonNull MultiModelLoaderFactory multiFactory) { return new DataUrlLoader\u0026lt;\u0026gt;(opener); } 所以返回了4个ModelLoader分别是DataUrlLoader、StringLoader、StringLoader、StringLoader。继续回到ModelLoaderRegistry的getModelLoaders方法，接着通过ModelLoader的handles(modelClass)来过滤，DataUrlLoader的handles方法如下：\n1 2 3 4 5 private static final String DATA_SCHEME_IMAGE = \u0026#34;data:image\u0026#34;; @Override public boolean handles(@NonNull Model model) { return model.toString().startsWith(DATA_SCHEME_IMAGE); } DataUrlLoader中必须要求model是以 data:image 开头才行，而StringLoader的handles(modelClass)如下：\n1 2 3 4 @Override public boolean handles(@NonNull String model) { return true; } 所以modelLoaderRegistry的getModelLoaders方法返回后面3个StringLoader了。继续回到DecodeJob的getLoadData方法，获取到3个ModelLoader后，继续调用它们的buildLoadData方法来获取LoadData，它们都是StringLoader，来看下它的buildLoadData方法：\n1 2 3 4 5 6 7 8 9 @Override public LoadData\u0026lt;Data\u0026gt; buildLoadData( @NonNull String model, int width, int height, @NonNull Options options) { Uri uri = parseUri(model); if (uri == null || !uriLoader.handles(uri)) { return null; } return uriLoader.buildLoadData(uri, width, height, options); } 首先将model转化成uri，然后调用uriLoader.handles(uri)过滤，在StringLoader中的uriLoader是一个MultiModelLoader(继承自ModelLoader，这其实就是个代理模式，将创建LoadData交给了外界传来的ModelLoader)，它是在创建StringLoader的时候传进来的，比如第一个StringLoader创建如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 public static class StreamFactory implements ModelLoaderFactory\u0026lt;String, InputStream\u0026gt; { @NonNull @Override public ModelLoader\u0026lt;String, InputStream\u0026gt; build(@NonNull MultiModelLoaderFactory multiFactory) { return new StringLoader\u0026lt;\u0026gt;(multiFactory.build(Uri.class, InputStream.class)); } } public synchronized \u0026lt;Model, Data\u0026gt; ModelLoader\u0026lt;Model, Data\u0026gt; build( @NonNull Class\u0026lt;Model\u0026gt; modelClass, @NonNull Class\u0026lt;Data\u0026gt; dataClass) { try { List\u0026lt;ModelLoader\u0026lt;Model, Data\u0026gt;\u0026gt; loaders = new ArrayList\u0026lt;\u0026gt;(); boolean ignoredAnyEntries = false; for (Entry\u0026lt;?, ?\u0026gt; entry : entries) { if (alreadyUsedEntries.contains(entry)) { ignoredAnyEntries = true; continue; } if (entry.handles(modelClass, dataClass)) { alreadyUsedEntries.add(entry); loaders.add(this.\u0026lt;Model, Data\u0026gt;build(entry)); alreadyUsedEntries.remove(entry); } } if (loaders.size() \u0026gt; 1) { return factory.build(loaders, throwableListPool); } else if (loaders.size() == 1) { return loaders.get(0); } else { if (ignoredAnyEntries) { return emptyModelLoader(); } else { throw new NoModelLoaderAvailableException(modelClass, dataClass); } } } catch (Throwable t) { alreadyUsedEntries.clear(); throw t; } } public boolean handles(@NonNull Class\u0026lt;?\u0026gt; modelClass, @NonNull Class\u0026lt;?\u0026gt; dataClass) { return handles(modelClass) \u0026amp;\u0026amp; this.dataClass.isAssignableFrom(dataClass); } static class Factory { @NonNull public \u0026lt;Model, Data\u0026gt; MultiModelLoader\u0026lt;Model, Data\u0026gt; build( @NonNull List\u0026lt;ModelLoader\u0026lt;Model, Data\u0026gt;\u0026gt; modelLoaders, @NonNull Pool\u0026lt;List\u0026lt;Throwable\u0026gt;\u0026gt; throwableListPool) { return new MultiModelLoader\u0026lt;\u0026gt;(modelLoaders, throwableListPool); } } 上面MultiModelLoaderFactory的build两参(modelClass和dataClass)和前面介绍的单参build方法其实类似，只不过这里可能会创建一个MultiModelLoader，其实这里就是ModelLoader的依赖构建。直接看三个StringLoader的构建结果：\nStringLoader:uriLoader = MultiModelLoader(modelLoaders= [DataUrlLoader, AssetUriLoader, MediaStoreImageThumbLoader, MediaStoreVideoThumbLoader, QMediaStoreUriLoader, UriLoader, UrlUriLoader, UrlUriLoader]) StringLoader:uriLoader = MultiModelLoader(modelLoaders= [QMediaStoreUriLoader, UriLoader]) StringLoader:uriLoader = MultiModelLoader(modelLoaders= [ResourceUriLoader, AssetUriLoader, UriLoader]) 所以经过StringLoader的uriLoader(MultiModelLoader)的handles方法过滤：\n1 2 3 4 5 6 7 8 9 @Override public boolean handles(@NonNull Model model) { for (ModelLoader\u0026lt;Model, Data\u0026gt; modelLoader : modelLoaders) { if (modelLoader.handles(model)) { return true; } } return false; } 遍历modelLoaders，然后调用每一个modelLoader的handles方法，最终只有第一个StringLoader通过，是因为UrlUriLoader的handles方法通过：\n1 2 3 4 5 6 7 8 public class UrlUriLoader\u0026lt;Data\u0026gt; implements ModelLoader\u0026lt;Uri, Data\u0026gt; { private static final Set\u0026lt;String\u0026gt; SCHEMES = Collections.unmodifiableSet(new HashSet\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;))); @Override public boolean handles(@NonNull Uri uri) { return SCHEMES.contains(uri.getScheme()); } } 继续回到StringLoader的buildLoadData方法，接着会调用uriLoader.buildLoadData的方法，也就是MultiModelLoader的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public LoadData\u0026lt;Data\u0026gt; buildLoadData( @NonNull Model model, int width, int height, @NonNull Options options) { Key sourceKey = null; int size = modelLoaders.size(); List\u0026lt;DataFetcher\u0026lt;Data\u0026gt;\u0026gt; fetchers = new ArrayList\u0026lt;\u0026gt;(size); for (int i = 0; i \u0026lt; size; i++) { ModelLoader\u0026lt;Model, Data\u0026gt; modelLoader = modelLoaders.get(i); if (modelLoader.handles(model)) { LoadData\u0026lt;Data\u0026gt; loadData = modelLoader.buildLoadData(model, width, height, options); if (loadData != null) { sourceKey = loadData.sourceKey; fetchers.add(loadData.fetcher); } } } return !fetchers.isEmpty() \u0026amp;\u0026amp; sourceKey != null ? new LoadData\u0026lt;\u0026gt;(sourceKey, new MultiFetcher\u0026lt;\u0026gt;(fetchers, exceptionListPool)) : null; } 最终交给了UrlUriLoader的buildLoadData方法获取LoadData：\n1 2 3 4 5 public LoadData\u0026lt;Data\u0026gt; buildLoadData( @NonNull Uri uri, int width, int height, @NonNull Options options) { GlideUrl glideUrl = new GlideUrl(uri.toString()); return urlLoader.buildLoadData(glideUrl, width, height, options); } 它又交给了urlLoader的buildLoadData方法获取LoadData，此处的urlLoader实际是HttpGlideUrlLoader，它是在UrlUriLoader创建的时候获取的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public LoadData\u0026lt;InputStream\u0026gt; buildLoadData( @NonNull GlideUrl model, int width, int height, @NonNull Options options) { GlideUrl url = model; if (modelCache != null) { url = modelCache.get(model, 0, 0); if (url == null) { modelCache.put(model, 0, 0, model); url = model; } } int timeout = options.get(TIMEOUT); return new LoadData\u0026lt;\u0026gt;(url, new HttpUrlFetcher(url, timeout)); } 所以最终的LoadData是此处创建的，fetcher是HttpUrlFetcher。\n为什么Glide在创建ModelLoader的时候不直接在registry阶段不直接把对应的ModelLoader组装成Entry，而要通过ModelLoaderFactory来创建ModelLoader？ 上面说过ModelLoader的创建可能依赖其它的ModelLoader，如果把ModelLoader直接创建出来，相当于把依赖的ModelLoader也创建出来了，这样会把一些不使用的ModelLoader也创建出来了，结果就是创建一些无用的ModelLoader出来，那样内存也会增加很大，而用ModelLoaderFactory的形式注册，只需要注册一个空的ModelLoaderFactory就行，内存上得到控制。\nInputStream到文件 在前面分析加载流程的时候，讲过SourceGenerator获取到InputStream后，将该InputStream保存到本地文件中，这个过程涉及到一次编码，然后将文件转成byteBuffer后，完成bitmap的解码，最后将bitmap又进行一次编码，这一次是对缩放后的图片进行编码。我们先看下SourceGenerator中如何将InputStream保存到本地文件，首先看下SourceGenerator的startNext方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class SourceGenerator{ public boolean startNext() { if (dataToCache != null) { Object data = dataToCache; dataToCache = null; boolean isDataInCache = cacheData(data); if (!isDataInCache) { return true; } } if (sourceCacheGenerator != null \u0026amp;\u0026amp; sourceCacheGenerator.startNext()) { return true; } } } HttpUrlFetcher回调到SourceGenerator后，dataToCache就不为空了，所以会调用cacheData(InputStream)保存到本地磁盘：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private boolean cacheData(Object dataToCache) throws IOException { DataRewinder\u0026lt;Object\u0026gt; rewinder = helper.getRewinder(dataToCache); Object data = rewinder.rewindAndGet(); Encoder\u0026lt;Object\u0026gt; encoder = helper.getSourceEncoder(data); DataCacheWriter\u0026lt;Object\u0026gt; writer = new DataCacheWriter\u0026lt;\u0026gt;(encoder, data, helper.getOptions()); DataCacheKey newOriginalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature()); DiskCache diskCache = helper.getDiskCache(); diskCache.put(newOriginalKey, writer); if (diskCache.get(newOriginalKey) != null) { originalKey = newOriginalKey; sourceCacheGenerator = new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, this); return true; } return false; } helper是DecodeHelper，调用了getRewinder方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class DecodeHelper{ \u0026lt;T\u0026gt; DataRewinder\u0026lt;T\u0026gt; getRewinder(T data) { return glideContext.getRegistry().getRewinder(data); } } public class Registry{ public \u0026lt;X\u0026gt; DataRewinder\u0026lt;X\u0026gt; getRewinder(@NonNull X data) { return dataRewinderRegistry.build(data); } } public class DataRewinderRegistry{ private final Map\u0026lt;Class\u0026lt;?\u0026gt;, DataRewinder.Factory\u0026lt;?\u0026gt;\u0026gt; rewinders = new HashMap\u0026lt;\u0026gt;(); public synchronized \u0026lt;T\u0026gt; DataRewinder\u0026lt;T\u0026gt; build(@NonNull T data) { DataRewinder.Factory\u0026lt;T\u0026gt; result = (DataRewinder.Factory\u0026lt;T\u0026gt;) rewinders.get(data.getClass()); if (result == null) { for (DataRewinder.Factory\u0026lt;?\u0026gt; registeredFactory : rewinders.values()) { if (registeredFactory.getDataClass().isAssignableFrom(data.getClass())) { result = (DataRewinder.Factory\u0026lt;T\u0026gt;) registeredFactory; break; } } } if (result == null) { result = (DataRewinder.Factory\u0026lt;T\u0026gt;) DEFAULT_FACTORY; } return result.build(data); } } DataRewinder是一个接口，这里获取DataRewinder类似上面介绍的ModelLoader，上面是将Entry装载到MultiModelLoaderFactory中，而此处是将 DataRewinder.Factory 放到DataRewinderRegistry中，通过比较class类型得到DataRewinder，最终得到一个 InputStreamRewinder ，接着调用了rewindAndGet方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public final class InputStreamRewinder implements DataRewinder\u0026lt;InputStream\u0026gt; { // 5MB. private static final int MARK_READ_LIMIT = 5 * 1024 * 1024; private final RecyclableBufferedInputStream bufferedStream; @Synthetic public InputStreamRewinder(InputStream is, ArrayPool byteArrayPool) { bufferedStream = new RecyclableBufferedInputStream(is, byteArrayPool); bufferedStream.mark(MARK_READ_LIMIT); } @NonNull @Override public InputStream rewindAndGet() throws IOException { bufferedStream.reset(); return bufferedStream; } } 在初始化InputStreamRewinder时候，将传进来的InputStream包装成RecyclableBufferedInputStream，相较于java中的BufferedInputStream，它是一个从byteArrayPool中申请byte[]数组的流，并且申请的默认byte[]数组大小是64KB，每次在扩容的时候，不是通过new byte[]的形式申请内存，而是通过byteArrayPool获取，申请到新的内存后会将旧的内存放到byteArrayPool中。基于以上特性能看出来，RecyclableBufferedInputStream是一个内存能循环利用的字节输入流，减少了GC。\nDataRewinder类图：\n接着通过DecodeHelper的getSourceEncoder方法获取到Encoder，跟上面获取DataRewinder是一样的，它是通过Registry到EncoderRegistry，然后也是比较传进来的class类型是不是注册的class子类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class Registry { public \u0026lt;X\u0026gt; Encoder\u0026lt;X\u0026gt; getSourceEncoder(@NonNull X data) { Encoder\u0026lt;X\u0026gt; encoder = encoderRegistry.getEncoder((Class\u0026lt;X\u0026gt;) data.getClass()); if (encoder != null) { return encoder; } } } public class EncoderRegistry { private final List\u0026lt;Entry\u0026lt;?\u0026gt;\u0026gt; encoders = new ArrayList\u0026lt;\u0026gt;(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) @Nullable public synchronized \u0026lt;T\u0026gt; Encoder\u0026lt;T\u0026gt; getEncoder(@NonNull Class\u0026lt;T\u0026gt; dataClass) { for (Entry\u0026lt;?\u0026gt; entry : encoders) { if (entry.handles(dataClass)) { return (Encoder\u0026lt;T\u0026gt;) entry.encoder; } } return null; } private static final class Entry\u0026lt;T\u0026gt; { private final Class\u0026lt;T\u0026gt; dataClass; final Encoder\u0026lt;T\u0026gt; encoder; Entry(@NonNull Class\u0026lt;T\u0026gt; dataClass, @NonNull Encoder\u0026lt;T\u0026gt; encoder) { this.dataClass = dataClass; this.encoder = encoder; } boolean handles(@NonNull Class\u0026lt;?\u0026gt; dataClass) { return this.dataClass.isAssignableFrom(dataClass); } } } 所以最终Encoder是一个StreamEncoder，回到上面的cacheData方法，DecodeHelper的getDiskCache方法会通过LazyDiskCacheProvider的getDiskCache方法返回DiskCache：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 private static class LazyDiskCacheProvider implements DecodeJob.DiskCacheProvider { private final DiskCache.Factory factory; private volatile DiskCache diskCache; @Override public DiskCache getDiskCache() { if (diskCache == null) { synchronized (this) { if (diskCache == null) { diskCache = factory.build(); } if (diskCache == null) { diskCache = new DiskCacheAdapter(); } } } return diskCache; } } 从此处看先通过 DiskCache.Factory 的build方法创建DiskCache，如果没有创建成功， 则返回DiskCacheAdapter。此处的DiskCache. Factory是在GlideBuilder中初始化Glide时候初始化的，它是InternalCacheDiskCacheFactory，它是继承自DiskLruCacheFactory，看下它的build方法：\n1 2 3 4 5 6 7 8 9 10 11 @Override public DiskCache build() { File cacheDir = cacheDirectoryGetter.getCacheDirectory(); if (cacheDir == null) { return null; } if (cacheDir.isDirectory() || cacheDir.mkdirs()) { return DiskLruCacheWrapper.create(cacheDir, diskCacheSize); } return null; } 可以看到最终是通过DiskLruCacheWrapper的create方法来创建DiskCache：\n1 2 3 public static DiskCache create(File directory, long maxSize) { return new DiskLruCacheWrapper(directory, maxSize); } 所以上面cacheData中diskCache是一个DiskLruCacheWrapper对象。最终通过DiskLruCacheWrapper的put方法来保存到文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Override public void put(Key key, Writer writer) { String safeKey = safeKeyGenerator.getSafeKey(key); DiskLruCache diskCache = getDiskCache(); Value current = diskCache.get(safeKey); if (current != null) { return; } DiskLruCache.Editor editor = diskCache.edit(safeKey); if (editor == null) { throw new IllegalStateException(\u0026#34;Had two simultaneous puts for: \u0026#34; + safeKey); } File file = editor.getFile(0); if (writer.write(file)) { editor.commit(); } editor.abortUnlessCommitted(); } 首先通过GlideUrl获取唯一key，因为此处是保存原始文件，所以是url作为唯一key，如果能找到本地图片，则不进行保存。接着获取该文件的editor：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public Editor edit(String key) throws IOException { return edit(key, ANY_SEQUENCE_NUMBER); } private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException { checkNotClosed(); Entry entry = lruEntries.get(key); if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER \u0026amp;\u0026amp; (entry == null || entry.sequenceNumber != expectedSequenceNumber)) { return null; // Value is stale. } if (entry == null) { entry = new Entry(key); lruEntries.put(key, entry); } else if (entry.currentEditor != null) { return null; // Another edit is in progress. } Editor editor = new Editor(entry); entry.currentEditor = editor; // Flush the journal before creating files to prevent file leaks. journalWriter.append(DIRTY); journalWriter.append(\u0026#39; \u0026#39;); journalWriter.append(key); journalWriter.append(\u0026#39;\\n\u0026#39;); flushWriter(journalWriter); return editor; } 在上面edit方法中，判断期望的序列号如果不是默认序列号并且entry为空或者已经保存成功了则直接返回null。下面就是创建Editor和Entry的过程。创建完Editor后就是使用writer的write方法保存图片的输入流了。此处的writer是DataCacheWriter：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class DataCacheWriter\u0026lt;DataType\u0026gt; implements DiskCache.Writer { private final Encoder\u0026lt;DataType\u0026gt; encoder; private final DataType data; private final Options options; DataCacheWriter(Encoder\u0026lt;DataType\u0026gt; encoder, DataType data, Options options) { this.encoder = encoder; this.data = data; this.options = options; } @Override public boolean write(@NonNull File file) { return encoder.encode(data, file, options); } } 会调用encoder的encode方法，可以看出来这是编码的核心，上面分析过encoder是StreamEncoder：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public boolean encode(@NonNull InputStream data, @NonNull File file, @NonNull Options options) { byte[] buffer = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class); boolean success = false; OutputStream os = new FileOutputStream(file); int read; while ((read = data.read(buffer)) != -1) { os.write(buffer, 0, read); } os.close(); success = true; byteArrayPool.put(buffer); return success; } 这就是编码的核心了，通过从字节池子中获取一个临时的byte数组，每次从输入流中读取，读取后通过输出流将buffer数组写到文件中，写完后，并回收该byte数组。\nDiskCache类图:\n在上面类图中DiskLruCacheFactory专门用来创建DiskLruCacheWrapper的，它是实现了DiskCache接口，实际上保存数据是DiskLruCache类，DiskLruCacheFactory需要CacheDirectoryGetter接口获取保存的目录，所以InternalCacheDiskCacheFactory实现类中传给DiskLruCacheFactory一个CacheDirectoryGetter的匿名内部类，将内存存储的路径传给父类。 解码过程 解码前：获取ByteBufferFetcher 保存原始图片到本地后，就是bitmap编码了，在之前的glide加载流程介绍过，回到SourceGenerator的startNext方法，调完cacheData后，就会调用DataCacheGenerator的startNext方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 //SourceGenerator的startNext方法 public boolean startNext() { if (dataToCache != null) { } if (sourceCacheGenerator != null \u0026amp;\u0026amp; sourceCacheGenerator.startNext()) { return true; } } //DataCacheGenerator的startNext方法 public boolean startNext() { while (modelLoaders == null || !hasNextModelLoader()) { sourceIdIndex++; if (sourceIdIndex \u0026gt;= cacheKeys.size()) { return false; } Key sourceId = cacheKeys.get(sourceIdIndex); Key originalKey = new DataCacheKey(sourceId, helper.getSignature()); cacheFile = helper.getDiskCache().get(originalKey); if (cacheFile != null) { this.sourceKey = sourceId; modelLoaders = helper.getModelLoaders(cacheFile); modelLoaderIndex = 0; } } loadData = null; boolean started = false; while (!started \u0026amp;\u0026amp; hasNextModelLoader()) { ModelLoader\u0026lt;File, ?\u0026gt; modelLoader = modelLoaders.get(modelLoaderIndex++); loadData = modelLoader.buildLoadData( cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions()); if (loadData != null \u0026amp;\u0026amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) { started = true; loadData.fetcher.loadData(helper.getPriority(), this); } } return started; } 上面和前面介绍的HttpUrlFetcher获取是一样的过程，只不过此处传进去的model是File类型，能匹配到Model是File类型有如下几个：\n1 2 3 4 append(File.class, ByteBuffer.class, new ByteBufferFileLoader.Factory()) append(File.class, InputStream.class, new FileLoader.StreamFactory()) append(File.class, ParcelFileDescriptor.class, new FileLoader.FileDescriptorFactory()) append(File.class, File.class, UnitModelLoader.Factory.\u0026lt;File\u0026gt;getInstance()) 这几个ModelLoader的handles方法都返回true，接着调用ModelLoader的buildLoadData获取LoadData，ByteBufferFileLoader的buildLoadData：\n1 2 3 4 5 6 public class ByteBufferFileLoader implements ModelLoader\u0026lt;File, ByteBuffer\u0026gt; { public LoadData\u0026lt;ByteBuffer\u0026gt; buildLoadData( @NonNull File file, int width, int height, @NonNull Options options) { return new LoadData\u0026lt;\u0026gt;(new ObjectKey(file), new ByteBufferFetcher(file)); } } FileLoader的buildLoadData：\n1 2 3 4 5 6 7 public class FileLoader\u0026lt;Data\u0026gt; implements ModelLoader\u0026lt;File, Data\u0026gt; { @Override public LoadData\u0026lt;Data\u0026gt; buildLoadData( @NonNull File model, int width, int height, @NonNull Options options) { return new LoadData\u0026lt;\u0026gt;(new ObjectKey(model), new FileFetcher\u0026lt;\u0026gt;(model, fileOpener)); } } UnitModelLoader的buildLoadData：\n1 2 3 4 5 6 public class UnitModelLoader\u0026lt;Model\u0026gt; implements ModelLoader\u0026lt;Model, Model\u0026gt; { public LoadData\u0026lt;Model\u0026gt; buildLoadData( @NonNull Model model, int width, int height, @NonNull Options options) { return new LoadData\u0026lt;\u0026gt;(new ObjectKey(model), new UnitFetcher\u0026lt;\u0026gt;(model)); } } 回到前面DataCacheGenerator的startNext方法，获取到LoadData后，通过DecodeHelper的hasLoadPath是否为true：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 boolean hasLoadPath(Class\u0026lt;?\u0026gt; dataClass) { return getLoadPath(dataClass) != null; } \u0026lt;Data\u0026gt; LoadPath\u0026lt;Data, ?, Transcode\u0026gt; getLoadPath(Class\u0026lt;Data\u0026gt; dataClass) { return glideContext.getRegistry().getLoadPath(dataClass, resourceClass, transcodeClass); } public \u0026lt;Data, TResource, Transcode\u0026gt; LoadPath\u0026lt;Data, TResource, Transcode\u0026gt; getLoadPath( @NonNull Class\u0026lt;Data\u0026gt; dataClass, @NonNull Class\u0026lt;TResource\u0026gt; resourceClass, @NonNull Class\u0026lt;Transcode\u0026gt; transcodeClass) { LoadPath\u0026lt;Data, TResource, Transcode\u0026gt; result = loadPathCache.get(dataClass, resourceClass, transcodeClass); List\u0026lt;DecodePath\u0026lt;Data, TResource, Transcode\u0026gt;\u0026gt; decodePaths = getDecodePaths(dataClass, resourceClass, transcodeClass); if (decodePaths.isEmpty()) { result = null; } else { result = new LoadPath\u0026lt;\u0026gt;( dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool); } loadPathCache.put(dataClass, resourceClass, transcodeClass, result); return result; } 通过getDecodePaths获取到已注册的DecodePath：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 private \u0026lt;Data, TResource, Transcode\u0026gt; List\u0026lt;DecodePath\u0026lt;Data, TResource, Transcode\u0026gt;\u0026gt; getDecodePaths( @NonNull Class\u0026lt;Data\u0026gt; dataClass, @NonNull Class\u0026lt;TResource\u0026gt; resourceClass, @NonNull Class\u0026lt;Transcode\u0026gt; transcodeClass) { List\u0026lt;DecodePath\u0026lt;Data, TResource, Transcode\u0026gt;\u0026gt; decodePaths = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Class\u0026lt;TResource\u0026gt;\u0026gt; registeredResourceClasses = decoderRegistry.getResourceClasses(dataClass, resourceClass); for (Class\u0026lt;TResource\u0026gt; registeredResourceClass : registeredResourceClasses) { List\u0026lt;Class\u0026lt;Transcode\u0026gt;\u0026gt; registeredTranscodeClasses = transcoderRegistry.getTranscodeClasses(registeredResourceClass, transcodeClass); for (Class\u0026lt;Transcode\u0026gt; registeredTranscodeClass : registeredTranscodeClasses) { List\u0026lt;ResourceDecoder\u0026lt;Data, TResource\u0026gt;\u0026gt; decoders = decoderRegistry.getDecoders(dataClass, registeredResourceClass); ResourceTranscoder\u0026lt;TResource, Transcode\u0026gt; transcoder = transcoderRegistry.get(registeredResourceClass, registeredTranscodeClass); @SuppressWarnings(\u0026#34;PMD.AvoidInstantiatingObjectsInLoops\u0026#34;) DecodePath\u0026lt;Data, TResource, Transcode\u0026gt; path = new DecodePath\u0026lt;\u0026gt;( dataClass, registeredResourceClass, registeredTranscodeClass, decoders, transcoder, throwableListPool); decodePaths.add(path); } } return decodePaths; } public synchronized \u0026lt;T, R\u0026gt; List\u0026lt;Class\u0026lt;R\u0026gt;\u0026gt; getResourceClasses( @NonNull Class\u0026lt;T\u0026gt; dataClass, @NonNull Class\u0026lt;R\u0026gt; resourceClass) { List\u0026lt;Class\u0026lt;R\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (String bucket : bucketPriorityList) { List\u0026lt;Entry\u0026lt;?, ?\u0026gt;\u0026gt; entries = decoders.get(bucket); if (entries == null) { continue; } for (Entry\u0026lt;?, ?\u0026gt; entry : entries) { if (entry.handles(dataClass, resourceClass) \u0026amp;\u0026amp; !result.contains((Class\u0026lt;R\u0026gt;) entry.resourceClass)) { result.add((Class\u0026lt;R\u0026gt;) entry.resourceClass); } } } return result; } 到这里后，我们需要熟悉bucketPriorityList和decoders，bucketPriorityList是分组信息，decoders是在Registry初始化注册进来的一些Entry集合表。在上面传进来的dataClass是ModelLoaders中创建的LoadData的fetcher中指定的getDataClass，resourceClass默认是Object.class：\n从上面debug数据可以看出来，传进来的dataClass是 java.nio.ByteBuffer ，resourceClass是 java.lang.Object ，因为在拿到第一个ByteBufferFileLoader创建的LoadData中所创建的Fetcher是ByteBufferFetcher，它的getDataClass方法如下：\n1 2 3 4 5 6 private static final class ByteBufferFetcher implements DataFetcher\u0026lt;ByteBuffer\u0026gt; { @Override public Class\u0026lt;ByteBuffer\u0026gt; getDataClass() { return ByteBuffer.class; } } 通过上面的getResourceClasses中entry的handle(dataClass, resourceClass)进行过滤出dataClass为 java.nio.ByteBuffer 的Entry来，所以会返回 android.graphics.drawable.Drawable 、 com.bumptech.glide.load.resource.gif.GifDrawable 、 android.graphics.drawable.Bitmap 、 android.graphics.drawable.BitmapDrawable 这四种resourceClass。回到上面的getDecodePaths方法，registeredResourceClasses指向这四种class，接着遍历该集合。调用transcoderRegistry.getTranscodeClasses(registeredResourceClass, transcodeClass)，registeredTranscodeClasses会获取到对应resourceClass的TranscodeClasses，然后继续遍历registeredTranscodeClasses，获取每一个resourceClass的decoders，最后构建DecodePath添加到集合中返回，这里列出4种ResourceClass的DecodePath情况：\nandroid.graphics.drawable.Drawable : DecodePath(dataClass= java.nio.ByteBuffer , registeredResourceClass= android.graphics.drawable.Drawable , registeredTranscodeClass= android.graphics.drawable.Drawable , decoders=[AnimatedImageDecoder$ByteBufferAnimatedImageDecoder、ByteBufferGifDecoder、BitmapDrawableDecoder、BitmapDrawableDecoder], transcoder=UnitTranscoder) com.bumptech.glide.load.resource.gif.GifDrawable : DecodePath(dataClass= java.nio.ByteBuffer , registeredResourceClass= com.bumptech.glide.load.resource.gif.GifDrawable , registeredTranscodeClass= ByteBufferGifDecoder], transcoder=UnitTranscoder) android.graphics.drawable.Bitmap : DecodePath(dataClass= java.nio.ByteBuffer , registeredResourceClass= android.graphics.drawable.Bitmap , registeredTranscodeClass= ByteBufferBitmapDecoder], transcoder=UnitTranscoder) android.graphics.drawable.BitmapDrawable : DecodePath(dataClass= java.nio.ByteBuffer , registeredResourceClass= android.graphics.drawable.BitmapDrawable , registeredTranscodeClass= BitmapDrawableDecoder、BitmapDrawableDecoder], transcoder=UnitTranscoder) 最终在Registry的getLoadPath方法中将返回的decodePaths构建成LoadPath，并添加到loadPathCache中，所以在上面DataCacheGenerator中loadData.fetcher是一个ByteBufferFetcher。 解码前：将File转化成ByteBuffer 在解码前需要将File转化成ByteBuffer，而没有直接通过File转化成Bitmap，原因有如下几点：\nGlide 解码框架是基于 “Data → ByteBuffer/InputStream → Resource” 的模型设计 File → BitmapFactory 解码是顺序 I/O，不能 random access 需要 Rewind（重读）—— File 做不到，ByteBuffer 支持 支持 GIF、WebP 等复杂格式，必须使用 ByteBuffer Glide 要支持 Transformation（圆角、裁剪、缩放）等 decode 前后处理 Glide 的缓存结构使用的是字节缓存，不是文件缓存（除磁盘缓存） 来看下ByteBufferFetcher的loadData实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Override public void loadData( @NonNull Priority priority, @NonNull DataCallback\u0026lt;? super ByteBuffer\u0026gt; callback) { ByteBuffer result = ByteBufferUtil.fromFile(file); callback.onDataReady(result); } public static ByteBuffer fromFile(@NonNull File file) throws IOException { RandomAccessFile raf = null; FileChannel channel = null; long fileLength = file.length(); raf = new RandomAccessFile(file, \u0026#34;r\u0026#34;); channel = raf.getChannel(); return channel.map(FileChannel.MapMode.READ_ONLY, 0, fileLength).load(); } 首先获取RandomAccessFile的FileChannel，让你使用 NIO（New I/O）高速文件通道，让你能对文件进行更快、更底层的操作，然后通过map方法将file内容映射到内存，从而不像普通io一样read/write那样系统调用，不需要用户态内核态拷贝，返回的MappedByteBuffer 是内存映射文件，对 ByteBuffer 的操作就是在直接修改文件内容。比如下面通过put方法给指定位置插入字符的事例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int insertPos = 3; byte value = (byte) \u0026#39;9\u0026#39;; RandomAccessFile raf = new RandomAccessFile(\u0026#34;./test.txt\u0026#34;, \u0026#34;rw\u0026#34;); FileChannel channel = raf.getChannel(); long oldLen = channel.size(); long newLen = oldLen + 1; // 1. 扩展文件长度 raf.setLength(newLen); // 2. 重新 map 全文件区域 MappedByteBuffer buffer = channel.map( FileChannel.MapMode.READ_WRITE, 0, newLen ); // 3. 从后往前移动数据（避免覆盖） for (long i = oldLen - 1; i \u0026gt;= insertPos; i--) { byte b = buffer.get((int) i); buffer.put((int) (i + 1), b); } // 4. 插入新的字节 buffer.put(insertPos, value); channel.close(); raf.close(); 开始解码 转化成ByteBuffer就回到了DecodeJob的decodeFromRetrievedData方法，这个在Glide加载图片流程中有讲到，在该方法里面调用了decodeFromData方法：\n1 2 3 4 5 private \u0026lt;Data\u0026gt; Resource\u0026lt;R\u0026gt; decodeFromData( DataFetcher\u0026lt;?\u0026gt; fetcher, Data data, DataSource dataSource) throws GlideException { Resource\u0026lt;R\u0026gt; result = decodeFromFetcher(data, dataSource); return result; } 此处的data是上面说到的ByteBuffer，dataSource是ByteBufferFetcher的getDataSource方法返回的DataSource. LOCAL。继续看decodeFromFetcher方法：\n1 2 3 4 5 private \u0026lt;Data\u0026gt; Resource\u0026lt;R\u0026gt; decodeFromFetcher(Data data, DataSource dataSource) throws GlideException { LoadPath\u0026lt;Data, ?, R\u0026gt; path = decodeHelper.getLoadPath((Class\u0026lt;Data\u0026gt;) data.getClass()); return runLoadPath(data, dataSource, path); } 又回到了上面说的LoadPath获取部分，上面分析过loadPathCache会构建一个LoadPath，里面放了4个DataPath，loadPathCache的dataClass是 ByteBuffer.class ，resourceClass是 java.lang.Object.class ，transcodeClass是 Drawable.class ，result就是刚刚上面说的4个DataPath。接着调用runLoadPath方法：\n1 2 3 4 5 6 7 8 private \u0026lt;Data, ResourceType\u0026gt; Resource\u0026lt;R\u0026gt; runLoadPath( Data data, DataSource dataSource, LoadPath\u0026lt;Data, ResourceType, R\u0026gt; path) throws GlideException { Options options = getOptionsWithHardwareConfig(dataSource); DataRewinder\u0026lt;Data\u0026gt; rewinder = glideContext.getRegistry().getRewinder(data); return path.load( rewinder, options, width, height, new DecodeCallback\u0026lt;ResourceType\u0026gt;(dataSource)); } 此处的rewinder和上面InputStreamRewinder获取类似，只不过这里的data是一个ByteBuffer.class类型，它获取到的是ByteBufferRewinder对象，然后调用LoadPath的load方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 public Resource\u0026lt;Transcode\u0026gt; load( DataRewinder\u0026lt;Data\u0026gt; rewinder, @NonNull Options options, int width, int height, DecodePath.DecodeCallback\u0026lt;ResourceType\u0026gt; decodeCallback) throws GlideException { return loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables); } //LoadPath.loadWithExceptionList private Resource\u0026lt;Transcode\u0026gt; loadWithExceptionList( DataRewinder\u0026lt;Data\u0026gt; rewinder, @NonNull Options options, int width, int height, DecodePath.DecodeCallback\u0026lt;ResourceType\u0026gt; decodeCallback, List\u0026lt;Throwable\u0026gt; exceptions) throws GlideException { Resource\u0026lt;Transcode\u0026gt; result = null; for (int i = 0, size = decodePaths.size(); i \u0026lt; size; i++) { DecodePath\u0026lt;Data, ResourceType, Transcode\u0026gt; path = decodePaths.get(i); result = path.decode(rewinder, width, height, options, decodeCallback); if (result != null) { break; } } return result; } //DecodePath.decode public Resource\u0026lt;Transcode\u0026gt; decode( DataRewinder\u0026lt;DataType\u0026gt; rewinder, int width, int height, @NonNull Options options, DecodeCallback\u0026lt;ResourceType\u0026gt; callback) throws GlideException { Resource\u0026lt;ResourceType\u0026gt; decoded = decodeResource(rewinder, width, height, options); Resource\u0026lt;ResourceType\u0026gt; transformed = callback.onResourceDecoded(decoded); return transcoder.transcode(transformed, options); } //DecodePath.decodeResource private Resource\u0026lt;ResourceType\u0026gt; decodeResource( DataRewinder\u0026lt;DataType\u0026gt; rewinder, int width, int height, @NonNull Options options) throws GlideException { return decodeResourceWithList(rewinder, width, height, options, exceptions); } //DecodePath.decodeResourceWithList private Resource\u0026lt;ResourceType\u0026gt; decodeResourceWithList( DataRewinder\u0026lt;DataType\u0026gt; rewinder, int width, int height, @NonNull Options options, List\u0026lt;Throwable\u0026gt; exceptions) throws GlideException { Resource\u0026lt;ResourceType\u0026gt; result = null; for (int i = 0, size = decoders.size(); i \u0026lt; size; i++) { ResourceDecoder\u0026lt;DataType, ResourceType\u0026gt; decoder = decoders.get(i); DataType data = rewinder.rewindAndGet(); if (decoder.handles(data, options)) { data = rewinder.rewindAndGet(); result = decoder.decode(data, width, height, options); } if (result != null) { break; } } return result; } 最终通过DecodePath的decode方法进行解码Bitmap，上面说过LoadPath中存在4种DecodePath，最终调用到DecodePath的decodeResourceWithList，该方法里面会调用前面会遍历DecodePath中的decoders集合，然后调用ResourceDecoder的decode方法，那么直接看前面分析过有哪些decoder，比如第一个decoder是AnimatedImageDecoder$ByteBufferAnimatedImageDecoder，首先来看下它的handles方法：\n1 2 3 4 5 private final AnimatedImageDecoder delegate; public boolean handles(@NonNull ByteBuffer source, @NonNull Options options) throws IOException { return delegate.handles(source); } 此处的delegate是AnimatedImageDecoder，看下它的handles方法：\n1 2 3 boolean handles(ByteBuffer byteBuffer) throws IOException { return isHandled(ImageHeaderParserUtils.getType(imageHeaderParsers, byteBuffer)); } ImageHeaderParserUtils的getType方法是获取图片是PNG、WEBP等格式的方法，它是通过ByteBuffer相应位置的字节进行判断，imageHeaderParsers是DefaultImageHeaderParser和ExifInterfaceImageHeaderParser的集合，关于这部分就不用展开说了，后面会单独说如何获取图片的格式。再来看下isHandled方法：\n1 2 3 4 private boolean isHandled(ImageType imageType) { return imageType == ImageType.ANIMATED_WEBP || (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.S \u0026amp;\u0026amp; imageType == ImageType.ANIMATED_AVIF); } 如果图片是带动画的webp或者是ANIMATED_AVIF格式才会使用该decoder进行解码。最终在BUCKET=\u0026ldquo;BitmapDrawable\u0026rdquo;，dataClass=ByteBuffer.class，resourceClass=BitmapDrawable.class, decoder=BitmapDrawableDecoder，它的handles和decode如下：\n1 2 3 4 5 6 7 8 9 10 11 12 private final ResourceDecoder\u0026lt;DataType, Bitmap\u0026gt; decoder; @Override public boolean handles(@NonNull DataType source, @NonNull Options options) throws IOException { return decoder.handles(source, options); } @Override public Resource\u0026lt;BitmapDrawable\u0026gt; decode( @NonNull DataType source, int width, int height, @NonNull Options options) throws IOException { Resource\u0026lt;Bitmap\u0026gt; bitmapResource = decoder.decode(source, width, height, options); return LazyBitmapDrawableResource.obtain(resources, bitmapResource); } 此处的decoder实际一个ByteBufferBitmapDecoder：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** Decodes {@link android.graphics.Bitmap Bitmaps} from {@link java.nio.ByteBuffer ByteBuffers}. */ public class ByteBufferBitmapDecoder implements ResourceDecoder\u0026lt;ByteBuffer, Bitmap\u0026gt; { private final Downsampler downsampler; public ByteBufferBitmapDecoder(Downsampler downsampler) { this.downsampler = downsampler; } @Override public boolean handles(@NonNull ByteBuffer source, @NonNull Options options) { return downsampler.handles(source); } @Override public Resource\u0026lt;Bitmap\u0026gt; decode( @NonNull ByteBuffer source, int width, int height, @NonNull Options options) throws IOException { return downsampler.decode(source, width, height, options); } } 类的注释也写得很清楚，Bitmap from ByteBuffers。\n我们来看下Downsampler的handles和decode方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public boolean handles(@SuppressWarnings(\u0026#34;unused\u0026#34;) ByteBuffer byteBuffer) { // We expect downsampler to handle any available type Android supports. return true; } public Resource\u0026lt;Bitmap\u0026gt; decode( ByteBuffer buffer, int requestedWidth, int requestedHeight, Options options) throws IOException { return decode( new ImageReader.ByteBufferReader(buffer, parsers, byteArrayPool), requestedWidth, requestedHeight, options, EMPTY_CALLBACKS); } 接着调用另外一个decode方法，注意此时创建的ImageReader是ByteBufferReader对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 private Resource\u0026lt;Bitmap\u0026gt; decode( ImageReader imageReader, int requestedWidth, int requestedHeight, Options options, DecodeCallbacks callbacks) throws IOException { //从字节池子里面获取默认大小的字节数组 byte[] bytesForOptions = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class); //从池子里面获取Options BitmapFactory.Options bitmapFactoryOptions = getDefaultOptions(); //设置一个临时可选的缓冲区(byte[])，用于解码 Bitmap 时作为 中间读写缓冲 bitmapFactoryOptions.inTempStorage = bytesForOptions; DecodeFormat decodeFormat = options.get(DECODE_FORMAT); PreferredColorSpace preferredColorSpace = options.get(PREFERRED_COLOR_SPACE); DownsampleStrategy downsampleStrategy = options.get(DownsampleStrategy.OPTION); boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS); boolean isHardwareConfigAllowed = options.get(ALLOW_HARDWARE_CONFIG) != null \u0026amp;\u0026amp; options.get(ALLOW_HARDWARE_CONFIG); try { Bitmap result = decodeFromWrappedStreams( imageReader, bitmapFactoryOptions, downsampleStrategy, decodeFormat, preferredColorSpace, isHardwareConfigAllowed, requestedWidth, requestedHeight, fixBitmapToRequestedDimensions, callbacks); return BitmapResource.obtain(result, bitmapPool); } finally { releaseOptions(bitmapFactoryOptions); byteArrayPool.put(bytesForOptions); } } 首先从池子中创建一个64KB的字节数组，然后从池子中获取一个默认的Options，接着将前面获取到的byte数组给到Options的inTempStorage，它的作用是给一个临时的缓冲区，用于解码bitmap时作为中间读写缓冲，如果不设置，系统每次解码时会自己new一个临时byte[]来用，该缓冲区主要在以下场景会用到：\n读取图片头(Header) 比如检测是否 PNG/JPEG/WebP、宽高、是否有 alpha 等。 读取压缩数据块（如 JPEG 的 MCUs） JPEG 解码时会分段读取压缩内容，需要一个临时缓冲。 从流中读取数据时作为 I/O buffer 例如 InputStream → Skia 的内部解码器需要 buffer 装载部分数据。 接着调用了decodeFromWrappedStreams方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 private Bitmap decodeFromWrappedStreams( ImageReader imageReader, BitmapFactory.Options options, DownsampleStrategy downsampleStrategy, DecodeFormat decodeFormat, PreferredColorSpace preferredColorSpace, boolean isHardwareConfigAllowed, int requestedWidth, int requestedHeight, boolean fixBitmapToRequestedDimensions, DecodeCallbacks callbacks) throws IOException { long startTime = LogTime.getLogTime(); int[] sourceDimensions = getDimensions(imageReader, options, callbacks, bitmapPool); int sourceWidth = sourceDimensions[0]; int sourceHeight = sourceDimensions[1]; String sourceMimeType = options.outMimeType; int orientation = imageReader.getImageOrientation(); int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation); boolean isExifOrientationRequired = TransformationUtils.isExifOrientationRequired(orientation); int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? (isRotationRequired(degreesToRotate) ? sourceHeight : sourceWidth) : requestedWidth; int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? (isRotationRequired(degreesToRotate) ? sourceWidth : sourceHeight) : requestedHeight; ImageType imageType = imageReader.getImageType(); calculateScaling( imageType, imageReader, callbacks, bitmapPool, downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, targetWidth, targetHeight, options); calculateConfig( imageReader, decodeFormat, isHardwareConfigAllowed, isExifOrientationRequired, options, targetWidth, targetHeight); boolean isKitKatOrGreater = Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.KITKAT; if ((options.inSampleSize == 1 || isKitKatOrGreater) \u0026amp;\u0026amp; shouldUsePool(imageType)) { int expectedWidth; int expectedHeight; if (sourceWidth \u0026gt;= 0 \u0026amp;\u0026amp; sourceHeight \u0026gt;= 0 \u0026amp;\u0026amp; fixBitmapToRequestedDimensions \u0026amp;\u0026amp; isKitKatOrGreater) { expectedWidth = targetWidth; expectedHeight = targetHeight; } else { float densityMultiplier = isScaling(options) ? (float) options.inTargetDensity / options.inDensity : 1f; int sampleSize = options.inSampleSize; int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize); int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize); expectedWidth = Math.round(downsampledWidth * densityMultiplier); expectedHeight = Math.round(downsampledHeight * densityMultiplier); } if (expectedWidth \u0026gt; 0 \u0026amp;\u0026amp; expectedHeight \u0026gt; 0) { setInBitmap(options, bitmapPool, expectedWidth, expectedHeight); } } if (preferredColorSpace != null) { if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.P) { boolean isP3Eligible = preferredColorSpace == PreferredColorSpace.DISPLAY_P3 \u0026amp;\u0026amp; options.outColorSpace != null \u0026amp;\u0026amp; options.outColorSpace.isWideGamut(); options.inPreferredColorSpace = ColorSpace.get(isP3Eligible ? ColorSpace.Named.DISPLAY_P3 : ColorSpace.Named.SRGB); } else if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { options.inPreferredColorSpace = ColorSpace.get(ColorSpace.Named.SRGB); } } Bitmap downsampled = decodeStream(imageReader, options, callbacks, bitmapPool); callbacks.onDecodeComplete(bitmapPool, downsampled); Bitmap rotated = null; if (downsampled != null) { downsampled.setDensity(displayMetrics.densityDpi); rotated = TransformationUtils.rotateImageExif(bitmapPool, downsampled, orientation); if (!downsampled.equals(rotated)) { bitmapPool.put(downsampled); } } return rotated; } 首先通过getDimensions方法获取图片的原始宽高：\n1 2 3 4 5 6 7 8 9 10 11 private static int[] getDimensions( ImageReader imageReader, BitmapFactory.Options options, DecodeCallbacks decodeCallbacks, BitmapPool bitmapPool) throws IOException { options.inJustDecodeBounds = true; decodeStream(imageReader, options, decodeCallbacks, bitmapPool); options.inJustDecodeBounds = false; return new int[] {options.outWidth, options.outHeight}; } 在读取宽高前给Options的inJustDecodeBounds设置为true，获取完后，然后设置为false，这里是只读取图片的宽高，不进行解码加载到内存中。接着调用了decodeStream方法：\n1 2 3 4 5 6 7 8 9 private static Bitmap decodeStream( ImageReader imageReader, BitmapFactory.Options options, DecodeCallbacks callbacks, BitmapPool bitmapPool) throws IOException { result = imageReader.decodeBitmap(options); return result; } 此处调用了ByteBufferReader的decodeBitmap：\n1 2 3 4 5 6 7 8 9 10 11 public Bitmap decodeBitmap(Options options) { return BitmapFactory.decodeStream(stream(), /* outPadding= */ null, options); } private InputStream stream() { return ByteBufferUtil.toStream(ByteBufferUtil.rewind(buffer)); } public static InputStream toStream(@NonNull ByteBuffer buffer) { return new ByteBufferStream(buffer); } 此处将ByteBuffer包装成ByteBufferStream的流，Glide自定义了一个bytebuffer的输入流。有兴趣的可以看看实现，这里就不展开了，获取到图片的原始宽高后，判断图片有没有进行旋转，如果有的话，则重新计算目标宽高，否则还是之前的目标宽高，接着调用calculateScaling方法来设置采样和缩放信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 private static void calculateScaling( ImageType imageType, ImageReader imageReader, DecodeCallbacks decodeCallbacks, BitmapPool bitmapPool, DownsampleStrategy downsampleStrategy, int degreesToRotate, int sourceWidth, int sourceHeight, int targetWidth, int targetHeight, BitmapFactory.Options options) throws IOException { int orientedSourceWidth = sourceWidth; int orientedSourceHeight = sourceHeight; final float exactScaleFactor = downsampleStrategy.getScaleFactor( orientedSourceWidth, orientedSourceHeight, targetWidth, targetHeight); SampleSizeRounding rounding = downsampleStrategy.getSampleSizeRounding( orientedSourceWidth, orientedSourceHeight, targetWidth, targetHeight); int outWidth = round(exactScaleFactor * orientedSourceWidth); int outHeight = round(exactScaleFactor * orientedSourceHeight); int widthScaleFactor = orientedSourceWidth / outWidth; int heightScaleFactor = orientedSourceHeight / outHeight; int scaleFactor = rounding == SampleSizeRounding.MEMORY ? Math.max(widthScaleFactor, heightScaleFactor) : Math.min(widthScaleFactor, heightScaleFactor); int powerOfTwoSampleSize; // BitmapFactory does not support downsampling wbmp files on platforms \u0026lt;= M. See b/27305903. if (Build.VERSION.SDK_INT \u0026lt;= 23 \u0026amp;\u0026amp; NO_DOWNSAMPLE_PRE_N_MIME_TYPES.contains(options.outMimeType)) { powerOfTwoSampleSize = 1; } else { powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor)); if (rounding == SampleSizeRounding.MEMORY \u0026amp;\u0026amp; powerOfTwoSampleSize \u0026lt; (1.f / exactScaleFactor)) { powerOfTwoSampleSize = powerOfTwoSampleSize \u0026lt;\u0026lt; 1; } } options.inSampleSize = powerOfTwoSampleSize; int powerOfTwoWidth; int powerOfTwoHeight; if (imageType == ImageType.JPEG) { int nativeScaling = Math.min(powerOfTwoSampleSize, 8); powerOfTwoWidth = (int) Math.ceil(orientedSourceWidth / (float) nativeScaling); powerOfTwoHeight = (int) Math.ceil(orientedSourceHeight / (float) nativeScaling); int secondaryScaling = powerOfTwoSampleSize / 8; if (secondaryScaling \u0026gt; 0) { powerOfTwoWidth = powerOfTwoWidth / secondaryScaling; powerOfTwoHeight = powerOfTwoHeight / secondaryScaling; } } else if (imageType == ImageType.PNG || imageType == ImageType.PNG_A) { powerOfTwoWidth = (int) Math.floor(orientedSourceWidth / (float) powerOfTwoSampleSize); powerOfTwoHeight = (int) Math.floor(orientedSourceHeight / (float) powerOfTwoSampleSize); } else if (imageType.isWebp()) { if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.N) { powerOfTwoWidth = Math.round(orientedSourceWidth / (float) powerOfTwoSampleSize); powerOfTwoHeight = Math.round(orientedSourceHeight / (float) powerOfTwoSampleSize); } else { powerOfTwoWidth = (int) Math.floor(orientedSourceWidth / (float) powerOfTwoSampleSize); powerOfTwoHeight = (int) Math.floor(orientedSourceHeight / (float) powerOfTwoSampleSize); } } else if (orientedSourceWidth % powerOfTwoSampleSize != 0 || orientedSourceHeight % powerOfTwoSampleSize != 0) { int[] dimensions = getDimensions(imageReader, options, decodeCallbacks, bitmapPool); powerOfTwoWidth = dimensions[0]; powerOfTwoHeight = dimensions[1]; } else { powerOfTwoWidth = orientedSourceWidth / powerOfTwoSampleSize; powerOfTwoHeight = orientedSourceHeight / powerOfTwoSampleSize; } double adjustedScaleFactor = downsampleStrategy.getScaleFactor( powerOfTwoWidth, powerOfTwoHeight, targetWidth, targetHeight); if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.KITKAT) { options.inTargetDensity = adjustTargetDensityForError(adjustedScaleFactor); options.inDensity = getDensityMultiplier(adjustedScaleFactor); } if (isScaling(options)) { options.inScaled = true; } else { options.inDensity = options.inTargetDensity = 0; } } 首先通过downsampleStrategy.getScaleFactor获取缩放比，默认FitCenter：\n1 2 3 4 5 6 7 8 private static class FitCenter extends DownsampleStrategy { @Override public float getScaleFactor( int sourceWidth, int sourceHeight, int requestedWidth, int requestedHeight) { float widthPercentage = requestedWidth / (float) sourceWidth; float heightPercentage = requestedHeight / (float) sourceHeight; return Math.min(widthPercentage, heightPercentage); } 需要宽高比上原始宽高的比取小的比例，比如在前面分析过一张544*184图片，imageView的宽高设置的wrap_content，获取到的requestedWidth和requestedHeight在小米10上是2206，所以getScaleFactor获取到的宽比例要小，差不多是4的样子。所以第一次算出来的exactScaleFactor是4，继续调用downsampleStrategy.getSampleSizeRounding是保质量还是保内存。在小米10上是保质量。然后算出outWidth和outWidth，它们是表示缩放后的大小，通过 sourceWidth*exactScaleFactor 算出来的，高也是如此。然后算出宽高各自的缩放比，只不过这里缩放比是取整，然后存储到widthScaleFactor和heightScaleFactor中，然后判断是保质量还是内存，如果是保内存，则取widthScaleFactor和heightScaleFactor中的大值，如果是保质量，则取它两的小值。将结果给到scaleFactor变量，最后计算采样率：\n1 2 int powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor)); options.inSampleSize = powerOfTwoSampleSize; Integer.highestOneBit是对某一个整数取2的n次幂，比如5的话，它的二进制是101，那么取最高位的1，其余位都是0，所以是4，最后将该数给到options的inSampleSize设置采样率。因为采样率取值是2的n次幂。那剩下的缩放该怎么办呢？交给了density来进行精度缩放，下面来看下下半部分的缩放：\nJPEG 先交给libjpeg-turbo进行原生缩放，缩放最大是8，并且使用了ceil向上取整，继续判断如果目标缩放大于8的话，则剩余的缩放交给skia进行缩放 PNG png类就比较简单了，直接获取任意采样后的大小，然后交给了skia进行缩放，此时是向下取整 WebP 和上面的png类似，也是获取任意采样后的大小，不过分版本是四舍五入还是向下取整 原始宽/采样不能整除或者原始高/采样不能整除 继续decode一次获取采样后的宽高，剩余交给skia进行缩放 接着再一次获取采样后的比例，获取到比例后，设置options的inTargetDensity和inDensity进行精确缩放，在底层做skia缩放的时候，会通过inTargetDensity/inDensity得到一个缩放比，但是这两个数都是一个整数，那么怎么保证两个整数相除得到的比例是最终的adjustedScaleFactor(float类型)，下面看下Glide是如何算inTargetDensity和inDensity： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 options.inTargetDensity = adjustTargetDensityForError(adjustedScaleFactor);//计算最小误差的targetDensity options.inDensity = getDensityMultiplier(adjustedScaleFactor);//inDensity使用一个很大的分母 private static int adjustTargetDensityForError(double adjustedScaleFactor) { int densityMultiplier = getDensityMultiplier(adjustedScaleFactor); int targetDensity = round(densityMultiplier * adjustedScaleFactor); float scaleFactorWithError = targetDensity / (float) densityMultiplier; double difference = adjustedScaleFactor / scaleFactorWithError; return round(difference * targetDensity); } private static int getDensityMultiplier(double adjustedScaleFactor) { return (int) Math.round( Integer.MAX_VALUE * (adjustedScaleFactor \u0026lt;= 1D ? adjustedScaleFactor : 1 / adjustedScaleFactor)); } getDensityMultiplier方法是得到一个目标比例的分母，可以看出来它是一个很大的数，那自然而然，targetDensity(第一次的实际density)就是densityMultiplier(分母)*adjustedScaleFactor(目标比例)。然后得到实例比例(scaleFactorWithError)，再看预期比例(adjustedScaleFactor)和实际比例(scaleFactorWithError)相隔多少倍，然后把这个差的倍数补上到第一次算的实际density(targetDensity)就得到最小误差的density，上面就是整个缩放的逻辑了。\n再回到上面decode中的calculateConfig，它主要是通过判断是否有alpha通道来得到一个合适的解码方式:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private void calculateConfig( ImageReader imageReader, DecodeFormat format, boolean isHardwareConfigAllowed, boolean isExifOrientationRequired, BitmapFactory.Options optionsWithScaling, int targetWidth, int targetHeight) { if (format == DecodeFormat.PREFER_ARGB_8888 || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) { optionsWithScaling.inPreferredConfig = Bitmap.Config.ARGB_8888; return; } boolean hasAlpha = imageReader.getImageType().hasAlpha(); optionsWithScaling.inPreferredConfig = hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565; if (optionsWithScaling.inPreferredConfig == Config.RGB_565) { optionsWithScaling.inDither = true; } } 在Glide中format默认是 DecodeFormat.PREFER_ARGB_8888 ，如果要设置的话，通过注解可以配置，所以Glide优先是使用 Bitmap.Config.ARGB_8888 , 如果默认不是 DecodeFormat.PREFER_ARGB_8888 ，判断图片是否带透明信息，如果带的话，也是设置成 Bitmap.Config.ARGB_8888 ，否则是 Bitmap.Config.RGB_565 。scale和config处理完事后，最后就是options的inBitmap处理了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 float densityMultiplier = isScaling(options) ? (float) options.inTargetDensity / options.inDensity : 1f; int sampleSize = options.inSampleSize; int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize); int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize); expectedWidth = Math.round(downsampledWidth * densityMultiplier); expectedHeight = Math.round(downsampledHeight * densityMultiplier); if (expectedWidth \u0026gt; 0 \u0026amp;\u0026amp; expectedHeight \u0026gt; 0) { setInBitmap(options, bitmapPool, expectedWidth, expectedHeight); } private static void setInBitmap( BitmapFactory.Options options, BitmapPool bitmapPool, int width, int height) { @Nullable Bitmap.Config expectedConfig = null; if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { if (options.inPreferredConfig == Config.HARDWARE) { return; } expectedConfig = options.outConfig; } if (expectedConfig == null) { expectedConfig = options.inPreferredConfig; } // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe. options.inBitmap = bitmapPool.getDirty(width, height, expectedConfig); } 计算最终的宽高，然后调用setInBitmap方法，在该方法里面通过bitmapPool中找到合适的bitmap，这样在解码的时候，可以用该bitmap的内存进行解码，不需要重复创建新内存，从而减少内存抖动。所有都完事后，最后就是再一次调用decodeStream将流转化成bitmap，然后回调给上层，整个解码完成。\n编码过程 编码和解码是一个对立的关系，在主流程中讲过解码完成后，先后会回调到DecodeJob的onResourceDecoded和notifyEncodeAndRelease方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;Z\u0026gt; Resource\u0026lt;Z\u0026gt; onResourceDecoded(DataSource dataSource, @NonNull Resource\u0026lt;Z\u0026gt; decoded) { boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey); if (diskCacheStrategy.isResourceCacheable( isFromAlternateCacheKey, dataSource, encodeStrategy)) { final Key key; switch (encodeStrategy) { case SOURCE: key = new DataCacheKey(currentSourceKey, signature); break; case TRANSFORMED: key = new ResourceCacheKey( decodeHelper.getArrayPool(), currentSourceKey, signature, width, height, appliedTransformation, resourceSubClass, options); break; } LockedResource\u0026lt;Z\u0026gt; lockedResult = LockedResource.obtain(transformed); deferredEncodeManager.init(key, encoder, lockedResult); result = lockedResult; } } private void notifyEncodeAndRelease( Resource\u0026lt;R\u0026gt; resource, DataSource dataSource, boolean isLoadedFromAlternateCacheKey) { if (deferredEncodeManager.hasResourceToEncode()) { deferredEncodeManager.encode(diskCacheProvider, options); } onEncodeComplete(); } 在onResourceDecoded回调中首先通过DiskCacheStrategy的isResourceCacheable判断解码后是否可以编码，主要是看对应的DiskCacheStrategy是否可以编码，默认是DiskCacheStrategy. AUTOMATIC，它的isResourceCacheable方法如下：\n1 2 3 4 5 6 7 @Override public boolean isResourceCacheable( boolean isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy) { return ((isFromAlternateCacheKey \u0026amp;\u0026amp; dataSource == DataSource.DATA_DISK_CACHE) || dataSource == DataSource.LOCAL) \u0026amp;\u0026amp; encodeStrategy == EncodeStrategy.TRANSFORMED; } isFromAlternateCacheKey表示是否能从LoadData中找到对应的sourceKey，如果从网络或从磁盘中找到原图的话，则currentSourceKey是一个GlideUrl的key，它是能从LoadData找得到的，所以isFromAlternateCacheKey为false，如果从网络返回的图片dataSource是REMOTE，如果是从磁盘中找到原图dataSource是DATA_DISK_CACHE，所以deferredEncodeManager的init方法不会调用，也就不会导致notifyEncodeAndRelease中调用deferredEncodeManager的encode，也就不会进行编码，如果我们将RequestOptions中的diskCacheStrategy换成DiskCacheStrategy. ALL就能实现编码，那我们看下DeferredEncodeManager的encode方法：\n1 2 3 4 5 void encode(DiskCacheProvider diskCacheProvider, Options options) { diskCacheProvider .getDiskCache() .put(key, new DataCacheWriter\u0026lt;\u0026gt;(encoder, toEncode, options)); } diskCacheProvider在上面解码的时候提过它是一个LazyDiskCacheProvider，在Engine中初始化的。在它里面是通过 DiskCache.Factory 的build方法创建DiskCache，在GlideBuilder的build方法中初始化的是InternalCacheDiskCacheFactory的 DiskCache.Factory ，最终创建的DiskLruCacheWrapper，从名字看它是一个包装类，实际干活的是DiskLruCache，它是glide内部实现的LRU算法的磁盘缓存类。这个跟上面的解码之前将InputStream保存到本地磁盘，也就是原图保存是一样的。最终会走到DataCacheWriter的write方法：\n1 2 3 4 5 6 class DataCacheWriter\u0026lt;DataType\u0026gt; implements DiskCache.Writer { @Override public boolean write(@NonNull File file) { return encoder.encode(data, file, options); } } encoder是在上面onResourceDecoded方法中从Registry的resourceEncoderRegistry中根据Resource的getResourceClass返回的Class取到的，如果解码返回一个Bitmap的话，那么此时得到的是一个BitmapEncoder：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public static final Option\u0026lt;Integer\u0026gt; COMPRESSION_QUALITY = Option.memory(\u0026#34;com.bumptech.glide.load.resource.bitmap.BitmapEncoder.CompressionQuality\u0026#34;, 90); public boolean encode( @NonNull Resource\u0026lt;Bitmap\u0026gt; resource, @NonNull File file, @NonNull Options options) { final Bitmap bitmap = resource.get(); Bitmap.CompressFormat format = getFormat(bitmap, options); int quality = options.get(COMPRESSION_QUALITY); boolean success = false; OutputStream os = null; OutputStream os = new FileOutputStream(file); if (arrayPool != null) { os = new BufferedOutputStream(os, arrayPool); } bitmap.compress(format, quality, os); success = true; return success; } private Bitmap.CompressFormat getFormat(Bitmap bitmap, Options options) { Bitmap.CompressFormat format = options.get(COMPRESSION_FORMAT); if (format != null) { return format; } else if (bitmap.hasAlpha()) { return Bitmap.CompressFormat.PNG; } else { return Bitmap.CompressFormat.JPEG; } } 默认的编码质量是90，并且默认的编码格式是如果图片带有透明通道则采用PNG无损压缩，否则使用JPEG有损压缩。如果字节池子存在，则构建一个BufferedOutputStream的输出流，它使用的byte数组来自于字节池子中的，默认字节大小是64KB的缓冲区，每次byte数组达到了64KB的时候，进行同步到底层的FileOutStream中。因为底层的FileOutputStream每次write都会触发一次系统调用，系统调用成本高，多次小块写入会产生：写入时间变长、CPU降速、磁盘碎片、整体编码耗时增加。同时BufferedOutputStream使用的是字节池子中的字节数组，降低GC的触发。\n","date":"2025-11-19T11:49:00+08:00","permalink":"http://xiangcman.xyz/p/glide%E7%BC%96%E8%A7%A3%E7%A0%81%E6%B5%81%E7%A8%8B/","title":"Glide编解码流程"},{"content":"面向对象 类的定义 1 2 3 4 5 6 7 class Student: def study(self, course_name): print(f\u0026#39;学生正在学习{course_name}.\u0026#39;) def play(self): print(f\u0026#39;学生正在玩游戏.\u0026#39;) 上面定义了一个类，类中定义了两个成员方法，方法的第一个参数表示当前类的对象。\n对象的创建 1 2 3 4 5 stu1 = Student() stu2 = Student() print(stu1) # \u0026lt;__main__.Student object at 0x10ad5ac50\u0026gt; print(stu2) # \u0026lt;__main__.Student object at 0x10ad5acd0\u0026gt; print(hex(id(stu1)), hex(id(stu2))) # 0x10ad5ac50 0x10ad5acd0 其中print中打印了stu1和stu2对象的在内存中的地址，用的是16进制表示的。用id方法也可以获取一个对象的16进制的值。和print中打印的地址是保持一致的。\n对象的方法调用 1 Student.study(stu1, \u0026#39;Python程序设计\u0026#39;) # 学生正在学习Python程序设计. 通过类名.方法的时候，第一个参数需要传入对象，第二个参数是方法的参数。\n1 stu1.study(\u0026#39;Python程序设计\u0026#39;) # 学生正在学习Python程序设计. 成员方法也可以通过对象来调用方法，其中方法的参数直接是成员方法的参数。同理play方法调用如下：\n1 2 Student.play(stu2) # 学生正在玩游戏. stu2.play() # 学生正在玩游戏. 类的初始化方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Student: \u0026#34;\u0026#34;\u0026#34;学生\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, age): \u0026#34;\u0026#34;\u0026#34;初始化方法\u0026#34;\u0026#34;\u0026#34; self.name = name self.age = age def study(self, course_name): \u0026#34;\u0026#34;\u0026#34;学习\u0026#34;\u0026#34;\u0026#34; print(f\u0026#39;{self.name}正在学习{course_name}.\u0026#39;) def play(self): \u0026#34;\u0026#34;\u0026#34;玩耍\u0026#34;\u0026#34;\u0026#34; print(f\u0026#39;{self.name}正在玩游戏.\u0026#39;) # 调用Student类的构造器创建对象并传入初始化参数 stu1 = Student(\u0026#39;张三\u0026#39;, 44) stu2 = Student(\u0026#39;李四\u0026#39;, 25) stu1.study(\u0026#39;Python程序设计\u0026#39;) # 张三正在学习Python程序设计. stu2.play() # 李四正在玩游戏. 在初始化方法中直接给类的成员变量赋值，并且也初始化了name和age属性。并且此时的属性是公开的，能在外部访问。\n属性的可见性 1 2 3 4 5 6 7 8 9 10 11 12 13 class Student: def __init__(self, name, age): self.__name = name self.__age = age def study(self, course_name): print(f\u0026#39;{self.__name}正在学习{course_name}.\u0026#39;) stu = Student(\u0026#39;张三\u0026#39;, 20) stu.study(\u0026#39;Python程序设计\u0026#39;) print(stu.__name) # AttributeError: \u0026#39;Student\u0026#39; object has no attribute \u0026#39;__name\u0026#39; 还是上面的例子，将name和age属性给改为私有的了，直接给属性前面加下划线就可以了。\n文件操作 文件的读取 1 2 3 file = open(\u0026#34;file/1.txt\u0026#34;,\u0026#34;r\u0026#34;,encoding=\u0026#39;utf-8\u0026#39;) print(file.read()) file.close() 上面第一个参数是文件的路径，第二个参数是读的权限，第三个参数指定编码方式。\n文件按行读取 1 2 3 4 5 6 7 8 9 10 file = open(\u0026#39;file/1.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) for line in file: print(line, end=\u0026#39;\u0026#39;) file.close() file = open(\u0026#39;file/1.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) lines = file.readlines() for line in lines: print(line, end=\u0026#39;\u0026#39;) file.close() 上面两个方式都可以按行读取。\n文件的写入 1 2 3 4 5 6 file = open(\u0026#39;file/2.txt\u0026#39;, \u0026#39;a\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) file.write(\u0026#39;床前明月光，\u0026#39;) file.write(\u0026#39;\\n疑是地上霜\u0026#39;) file.write(\u0026#39;\\n举头望明月\u0026#39;) file.write(\u0026#39;\\n低头思故乡\u0026#39;) file.close() 异常处理 异常捕获 1 2 3 4 5 6 7 8 9 10 11 12 13 file = None try: file = open(\u0026#39;test.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) print(file.read()) except FileNotFoundError: print(\u0026#39;无法打开指定的文件!\u0026#39;) except LookupError: print(\u0026#39;指定了未知的编码!\u0026#39;) except UnicodeDecodeError: print(\u0026#39;读取文件时解码错误!\u0026#39;) finally: if file: file.close() 上面演示了文件读取时候的异常捕捉，如果文件找不到则会抛FileNotFoundError异常，如果未指定编码格式，则会报LookupError异常，如果文件读取时候的编码格式和写入时候的编码格式不一致就会报UnicodeDecodeError异常。\n自定义异常抛出 1 2 3 4 5 6 7 8 9 10 11 class InputError(ValueError): \u0026#34;\u0026#34;\u0026#34;自定义异常类型\u0026#34;\u0026#34;\u0026#34; pass def fac(num): \u0026#34;\u0026#34;\u0026#34;求阶乘\u0026#34;\u0026#34;\u0026#34; if num \u0026lt; 0: raise InputError(\u0026#39;只能计算非负整数的阶乘\u0026#39;) if num in (0, 1): return 1 return num * fac(num - 1) 通过raise抛出异常，然后在使用fac函数的时候捕捉异常：\n1 2 3 4 try: print(f\u0026#39;{num}! = {fac(num)}\u0026#39;) except InputError as err: print(err) ","date":"2025-11-01T21:35:52+08:00","permalink":"http://xiangcman.xyz/p/python%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E4%BA%8C/","title":"Python常见语法二"},{"content":"变量 变量类型 1 2 3 4 5 6 7 8 a = 100 b = 123.45 c = \u0026#39;hello, world\u0026#39; d = True print(type(a)) # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; print(type(b)) # \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; print(type(c)) # \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; print(type(d)) # \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; 通过type来看变量的类型。\n变量转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 a = 100 b = 123.45 c = \u0026#39;123\u0026#39; d = \u0026#39;100\u0026#39; e = \u0026#39;123.45\u0026#39; f = \u0026#39;hello, world\u0026#39; g = True print(float(a)) # int类型的100转成float，输出100.0 print(int(b)) # float类型的123.45转成int，输出123 print(int(c)) # str类型的\u0026#39;123\u0026#39;转成int，输出123 print(int(c, base=16)) # str类型的\u0026#39;123\u0026#39;按十六进制转成int，输出291 print(int(d, base=2)) # str类型的\u0026#39;100\u0026#39;按二进制转成int，输出4 print(float(e)) # str类型的\u0026#39;123.45\u0026#39;转成float，输出123.45 print(bool(f)) # str类型的\u0026#39;hello, world\u0026#39;转成bool，输出True print(int(g)) # bool类型的True转成int，输出1 print(chr(a)) # int类型的100转成str，输出\u0026#39;d\u0026#39; print(ord(\u0026#39;d\u0026#39;)) # str类型的\u0026#39;d\u0026#39;转成int，输出100 算术运算 1 2 3 4 5 6 print(321 / 12) # 除法运算，输出26.75，跟java中整除不像 print(321 // 12) # 整除运算，输出26 print(321 % 12) # 求模运算，输出9 print(2 ** 3) # 幂次运算，2的3次方 # 海象运算符 print((a := 10)) # 10 小数表示法 1 2 3 f = float(input(\u0026#39;请输入华氏温度: \u0026#39;)) c = (f - 32) / 1.8 print(\u0026#39;%.1f华氏度 = %.1f摄氏度\u0026#39; % (f, c)) 解释：此处使用%.1f来格式化一个浮点类型的数，并且保留小数点1位。还有中格式化表示法：\n1 2 3 f = float(input(\u0026#39;请输入华氏温度: \u0026#39;)) c = (f - 32) / 1.8 print(f\u0026#39;{f:.1f}华氏度 = {c:.1f}摄氏度\u0026#39;) 前面用f开头，表示里面有格式化的操作，用{f:.1f}来代替f的值，并且保留小数点1位，同理c变量也是一样。\n分支 分支判断 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 height = float(input(\u0026#39;身高(cm)：\u0026#39;)) weight = float(input(\u0026#39;体重(kg)：\u0026#39;)) bmi = weight / (height / 100) ** 2 print(f\u0026#39;{bmi = :.1f}\u0026#39;) if bmi \u0026lt; 18.5: print(\u0026#39;你的体重过轻！\u0026#39;) elif bmi \u0026lt; 24: print(\u0026#39;你的身材很棒！\u0026#39;) elif bmi \u0026lt; 27: print(\u0026#39;你的体重过重！\u0026#39;) elif bmi \u0026lt; 30: print(\u0026#39;你已轻度肥胖！\u0026#39;) elif bmi \u0026lt; 35: print(\u0026#39;你已中度肥胖！\u0026#39;) else: print(\u0026#39;你已重度肥胖！\u0026#39;) match case表示法： 1 2 3 4 5 6 7 8 9 10 11 status_code = int(input(\u0026#39;响应状态码: \u0026#39;)) match status_code: case 400: description = \u0026#39;Bad Request\u0026#39; case 401: description = \u0026#39;Unauthorized\u0026#39; case 403: description = \u0026#39;Forbidden\u0026#39; case 404: description = \u0026#39;Not Found\u0026#39; case 405: description = \u0026#39;Method Not Allowed\u0026#39; case 418: description = \u0026#39;I am a teapot\u0026#39; case 429: description = \u0026#39;Too many requests\u0026#39; case _: description = \u0026#39;Unknown Status Code\u0026#39; print(\u0026#39;状态码描述:\u0026#39;, description) 循环 循环 1 2 3 4 5 6 7 8 \u0026#34;\u0026#34;\u0026#34; 每隔1秒输出一次“hello, world”，持续1小时 \u0026#34;\u0026#34;\u0026#34; import time for i in range(3600): print(\u0026#39;hello, world\u0026#39;) time.sleep(1) i的值是从0到3599。 不要i变量的时候，可以用如下写法：\n1 2 3 for _ in range(3600): print(\u0026#39;hello, world\u0026#39;) time.sleep(1) 1 2 3 4 total = 0 for i in range(2, 101, 2): total += i print(total) range方法第一个参数是起始值，第二个参数是终止值，第三个参数是步长。其余的while循环，break和continue和java一样的用法。\n列表 列表的定义 1 2 3 4 5 6 items1 = [35, 12, 99, 68, 55, 35, 87] items2 = [\u0026#39;Python\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;Go\u0026#39;, \u0026#39;Kotlin\u0026#39;] items3 = [100, 12.3, \u0026#39;Python\u0026#39;, True] print(items1) # [35, 12, 99, 68, 55, 35, 87] print(items2) # [\u0026#39;Python\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;Go\u0026#39;, \u0026#39;Kotlin\u0026#39;] print(items3) # [100, 12.3, \u0026#39;Python\u0026#39;, True] 列表使用[]来初始化，可以有重复值。\n使用list定义列表 1 2 3 4 items4 = list(range(1, 10)) items5 = list(\u0026#39;hello\u0026#39;) print(items4) # [1, 2, 3, 4, 5, 6, 7, 8, 9] print(items5) # [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;] 使用list()来初始化一个列表。\n列表相加 1 2 3 4 5 6 7 items5 = [35, 12, 99, 45, 66] items6 = [45, 58, 29] items7 = [\u0026#39;Python\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;JavaScript\u0026#39;] print(items5 + items6) # [35, 12, 99, 45, 66, 45, 58, 29] print(items6 + items7) # [45, 58, 29, \u0026#39;Python\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;JavaScript\u0026#39;] items5 += items6 print(items5) # [35, 12, 99, 45, 66, 45, 58, 29] 两个列表相加，得到一个新的列表。\n列表元素的获取 1 2 3 4 5 6 7 8 9 10 11 items8 = [\u0026#39;apple\u0026#39;, \u0026#39;waxberry\u0026#39;, \u0026#39;pitaya\u0026#39;, \u0026#39;peach\u0026#39;, \u0026#39;watermelon\u0026#39;] print(items8[0]) # apple print(items8[2]) # pitaya print(items8[4]) # watermelon items8[2] = \u0026#39;durian\u0026#39; print(items8) # [\u0026#39;apple\u0026#39;, \u0026#39;waxberry\u0026#39;, \u0026#39;durian\u0026#39;, \u0026#39;peach\u0026#39;, \u0026#39;watermelon\u0026#39;] print(items8[-5]) # \u0026#39;apple\u0026#39; print(items8[-4]) # \u0026#39;waxberry\u0026#39; print(items8[-1]) # watermelon items8[-4] = \u0026#39;strawberry\u0026#39; print(items8) # [\u0026#39;apple\u0026#39;, \u0026#39;strawberry\u0026#39;, \u0026#39;durian\u0026#39;, \u0026#39;peach\u0026#39;, \u0026#39;watermelon\u0026#39;] 取列表中的元素，负数表示倒数第几个。\n列表区间取元素 1 2 3 4 5 print(items8[1:3:1]) # [\u0026#39;strawberry\u0026#39;, \u0026#39;durian\u0026#39;] print(items8[0:3:1]) # [\u0026#39;apple\u0026#39;, \u0026#39;strawberry\u0026#39;, \u0026#39;durian\u0026#39;] print(items8[0:5:2]) # [\u0026#39;apple\u0026#39;, \u0026#39;durian\u0026#39;, \u0026#39;watermelon\u0026#39;] print(items8[-4:-2:1]) # [\u0026#39;strawberry\u0026#39;, \u0026#39;durian\u0026#39;] print(items8[-2:-6:-1]) # [\u0026#39;peach\u0026#39;, \u0026#39;durian\u0026#39;, \u0026#39;strawberry\u0026#39;, \u0026#39;apple\u0026#39;] 区间取元素，第三个参数是取值的跳跃几个。\n1 2 3 4 5 print(items8[1:3]) # [\u0026#39;strawberry\u0026#39;, \u0026#39;durian\u0026#39;] print(items8[:3:1]) # [\u0026#39;apple\u0026#39;, \u0026#39;strawberry\u0026#39;, \u0026#39;durian\u0026#39;] print(items8[::2]) # [\u0026#39;apple\u0026#39;, \u0026#39;durian\u0026#39;, \u0026#39;watermelon\u0026#39;] print(items8[-4:-2]) # [\u0026#39;strawberry\u0026#39;, \u0026#39;durian\u0026#39;] print(items8[-2::-1]) # [\u0026#39;peach\u0026#39;, \u0026#39;durian\u0026#39;, \u0026#39;strawberry\u0026#39;, \u0026#39;apple\u0026#39;] 三个参数可以省略，第一个参数省略是0，第二个参数省略是到最后一个元素，第三个参数省略是1。\n列表遍历 1 2 3 languages = [\u0026#39;Python\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;C++\u0026#39;, \u0026#39;Kotlin\u0026#39;] for index in range(len(languages)): print(languages[index]) 使用range的时候传入列表的长度，然后进行遍历取元素。\n列表的元素添加 1 2 3 4 5 languages = [\u0026#39;Python\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;C++\u0026#39;] languages.append(\u0026#39;JavaScript\u0026#39;) print(languages) # [\u0026#39;Python\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;C++\u0026#39;, \u0026#39;JavaScript\u0026#39;] languages.insert(1, \u0026#39;SQL\u0026#39;) print(languages) # [\u0026#39;Python\u0026#39;, \u0026#39;SQL\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;C++\u0026#39;, \u0026#39;JavaScript\u0026#39;] 使用append添加到列表末尾，使用insert给指定位置添加元素。\n列表的元素移除 1 2 3 4 5 6 7 8 9 10 11 12 13 languages = [\u0026#39;Python\u0026#39;, \u0026#39;SQL\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;C++\u0026#39;, \u0026#39;JavaScript\u0026#39;] if \u0026#39;Java\u0026#39; in languages: languages.remove(\u0026#39;Java\u0026#39;) if \u0026#39;Swift\u0026#39; in languages: languages.remove(\u0026#39;Swift\u0026#39;) print(languages) # [\u0026#39;Python\u0026#39;, \u0026#39;SQL\u0026#39;, C++\u0026#39;, \u0026#39;JavaScript\u0026#39;] languages.pop() temp = languages.pop(1) print(temp) # SQL languages.append(temp) print(languages) # [\u0026#39;Python\u0026#39;, C++\u0026#39;, \u0026#39;SQL\u0026#39;] languages.clear() print(languages) # [] 在列表中用remove方法移除元素的时候，需要判断元素在不在里面，如果不在里面直接remove会报错：ValueError错误导致程序崩溃。上面使用pop方法会移除最后一个元素，pop也可以按位置指定移除，clear方法是清除所有的元素。\n1 2 3 items = [\u0026#39;Python\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;C++\u0026#39;] del items[1] print(items) # [\u0026#39;Python\u0026#39;, \u0026#39;C++\u0026#39;] 通过del删除元素，它是不返回元素，性能上比上面的pop要好。\n列表的索引和频次 1 2 3 4 5 6 7 8 9 items = [\u0026#39;Python\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;C++\u0026#39;, \u0026#39;Kotlin\u0026#39;, \u0026#39;Python\u0026#39;] print(items.index(\u0026#39;Python\u0026#39;)) # 0 # 从索引位置1开始查找\u0026#39;Python\u0026#39; print(items.index(\u0026#39;Python\u0026#39;, 1)) # 5 print(items.count(\u0026#39;Python\u0026#39;)) # 2 print(items.count(\u0026#39;Kotlin\u0026#39;)) # 1 print(items.count(\u0026#39;Swfit\u0026#39;)) # 0 # 从索引位置3开始查找\u0026#39;Java\u0026#39; print(items.index(\u0026#39;Java\u0026#39;, 3)) # ValueError: \u0026#39;Java\u0026#39; is not in list index能找到指定元素的索引，第一个参数是元素，第二个元素是第几个。count获取元素出现的次数。\n列表的排序和翻转 1 2 3 4 5 items = [\u0026#39;Python\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;C++\u0026#39;, \u0026#39;Kotlin\u0026#39;, \u0026#39;Swift\u0026#39;] items.sort() print(items) # [\u0026#39;C++\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;Kotlin\u0026#39;, \u0026#39;Python\u0026#39;, \u0026#39;Swift\u0026#39;] items.reverse() print(items) # [\u0026#39;Swift\u0026#39;, \u0026#39;Python\u0026#39;, \u0026#39;Kotlin\u0026#39;, \u0026#39;Java\u0026#39;, \u0026#39;C++\u0026#39;] sort按照首字母进行排序，reverse进行前后翻转。\n列表的生成式 1 2 items = [i for i in range(1, 100) if i % 3 == 0 or i % 5 == 0] print(items) 首先用for-in来循环1到99，后面是if过滤，如果是3或者5的倍数才会是循环要用的元素，for前面是生成式的运算，这里直接返回i，最后生成一个items的新列表。\n1 2 3 nums1 = [35, 12, 97, 64, 55] nums2 = [num ** 2 for num in nums1] print(nums2) 对列表中的元素求平方操作，生成一个新的列表。\n列表嵌套 1 2 3 scores = [[95, 83, 92], [80, 75, 82], [92, 97, 90], [80, 78, 69], [65, 66, 89]] print(scores[0]) # [95, 83, 92] print(scores[0][1]) # 83 跟java中二维数组没什么区别。\n嵌套列表添加 1 2 3 4 5 6 7 8 scores = [] for _ in range(5): temp = [] for _ in range(3): score = int(input(\u0026#39;请输入: \u0026#39;)) temp.append(score) scores.append(temp) print(scores) 外层是一个大的列表，大的列表里面有5个小列表，每个小列表的大小是3。\n嵌套列表生成式 1 2 3 import random scores = [[random.randrange(60, 101) for _ in range(3)] for _ in range(5)] print(scores) 第一个for-in指定每个小列表的长度，第二个for-in指定了外层列表的长度。\n元组 元组的定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 # 定义一个三元组 t1 = (35, 12, 98) # 定义一个四元组 t2 = (\u0026#39;张三\u0026#39;, 45, True, \u0026#39;四川成都\u0026#39;) # 查看变量的类型 print(type(t1)) # \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; print(type(t2)) # \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; # 查看元组中元素的数量 print(len(t1)) # 3 print(len(t2)) # 4 # 索引运算 print(t1[0]) # 35 print(t1[2]) # 98 print(t2[-1]) # 四川成都 # 切片运算 print(t2[:2]) # (\u0026#39;张三\u0026#39;, 43) print(t2[::3]) # (\u0026#39;张三\u0026#39;, \u0026#39;四川成都\u0026#39;) # 循环遍历元组中的元素 for elem in t1: print(elem) # 成员运算 print(12 in t1) # True print(99 in t1) # False print(\u0026#39;Hao\u0026#39; not in t2) # True # 拼接运算 t3 = t1 + t2 print(t3) # (35, 12, 98, \u0026#39;张三\u0026#39;, 43, True, \u0026#39;四川成都\u0026#39;) # 比较运算 print(t1 == t3) # False print(t1 \u0026gt;= t3) # False print(t1 \u0026lt;= (35, 11, 99)) # False 元组定义好后，就不能再添加元素和删除了，也不能修改。\n空元组和元组定义 1 2 3 4 5 6 7 8 9 10 a = () print(type(a)) # \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; b = (\u0026#39;hello\u0026#39;) print(type(b)) # \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; c = (100) print(type(c)) # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; d = (\u0026#39;hello\u0026#39;, ) print(type(d)) # \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; e = (100, ) print(type(e)) # \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; 上面a是空元组，而b是一个字符串类型，c是一个int类型，d才是元祖类型，e也是，也就是说如果元祖中只有一个元素的时候，后面需要加上逗号，如果是空的就不需要加逗号，如果是两个或以上也不需要逗号。\n元组的打包和解包 1 2 3 4 5 6 7 # 打包操作 a = 1, 10, 100 print(type(a)) # \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; print(a) # (1, 10, 100) # 解包操作 i, j, k = a print(i, j, k) # 1 10 100 打包操作只需要用逗号分隔，而解包只需要把对应的变量用逗号分隔会自定赋值。\n交换变量的值 1 2 3 4 a = 10 b = 20 a, b = b, a print(a, b) # 20 10 其实这个是运用了元祖的打包和解包，首先将b,a组成一个元组，然后付给另外一个元组，然后元组进行解包，给到a和b，所以达到了互换值。\n字符串 转义字符串 字符串中使用\\来表示转义，转义的意思是\\后面字符不再是原来的意思，例如\\n不是代表字符\\和字符n，而是表示换行；\\t也不是代表字符\\和字符t，而是表示制表符。而如果想表示原始字符的话前面需要再加一个\\字符: 1 2 3 4 5 s1 = \u0026#39;\\\u0026#39;hello, world!\\\u0026#39;\u0026#39; # \u0026#39;hello, world!\u0026#39; s2 = \u0026#39;\\\\hello, world!\\\\\u0026#39; # \\hello, world!\\ s3 = \u0026#39;hello\\nworld!\u0026#39; # hello换行world! s5 = \u0026#39;hello\\\\nworld!\u0026#39; # hello\\nworld! s4 = \u0026#39;hello\\tworld!\u0026#39; # hello\tworld! 原始字符串 在上面默认都是\\n表示换行，如果不想换行需要使用\\\\n来表示不转义。而如果在字符串前面加上r的话，就表示原始字符串，也就是说\\n不再表示换行，而是表示\\字符和n字符： 1 s3 = r\u0026#39;hello\\nworld!\u0026#39; # hello\\nworld! 字符的特殊表示 在\\字符后面可以跟一个八进制的数或者是十六进制数来表示字符，比如字符a的ASCII 码值十进制对应的是97。那么可以用\\141来表示a，141表示97的八进制数。而\\x61也可以表示a，61表示97的十六进制数。 1 s1 = \u0026#39;\\141\\142\\143\\x61\\x62\\x63\u0026#39; # abcabc 另外一种是在u后面跟 Unicode 字符编码,例如\\u5f20\\u4e09代表中文\u0026quot;张三\u0026quot;：\n1 s2 = \u0026#39;\\u5f20\\u4e09\u0026#39; # 张三 关于字符的遍历，索引，长度，切片等和列表类似。\n集合 python中的集合和java中的集合不太一样，python中集合对应了java中set容器。也是无序，不重复。\n集合的定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 set1 = {1, 2, 3, 3, 3, 2} print(set1) set2 = {\u0026#39;banana\u0026#39;, \u0026#39;pitaya\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;grape\u0026#39;} print(set2) set3 = set(\u0026#39;hello\u0026#39;) print(set3) set4 = set([1, 2, 2, 3, 3, 3, 2, 1]) # {1, 2, 3} print(set4) set5 = {num for num in range(1, 20) if num % 3 == 0 or num % 7 == 0} print(set5) 上面通过{}初始化一个集合，也可以通过set()来初始化一个集合。set4集合传入的是一个列表，由于是不能重复，所以只有1,2,3这三个数字。set5是通过生成式来初始化一个集合。然后集合的添加，查询等功能和列表类似。\n字典 字典的初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 person = {\u0026#34;name\u0026#34;:\u0026#34;张三\u0026#34;, \u0026#34;age\u0026#34;:18} print(type(person)) # \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; print(\u0026#34;name\u0026#34; in person) # True print(person[\u0026#34;name1\u0026#34;]) # KeyError person[\u0026#34;score\u0026#34;] = 100 for item in person: print(item) student = dict() student[\u0026#39;name\u0026#39;] = \u0026#34;小明\u0026#34; for e in student: print(f\u0026#34;key = {e}; value = {student[e]}\u0026#34;) student1 ={} student1[\u0026#39;name\u0026#39;] = \u0026#34;小王\u0026#34; for e in student1: print(f\u0026#34;key1 = {e}; value1 = {student1[e]}\u0026#34;) 字典是通过key和value组成，跟java的hashMap类似。通过in判断key在不在字典中，如果key不在字典中，直接去拿值的时候，会报KeyError的异常。给新的key添加元素。for in遍历的时候，取的是字典的key，如果要在for-in里面取valye的话需要通过key来取value值。上面可以通过dict()来初始化一个字典，也可以通过{}来初始化一个字典。\n字典的方法 1 2 print(person.get(\u0026#34;name1\u0026#34;)) # None print(person.get(\u0026#34;name1\u0026#34;,\u0026#34;王二\u0026#34;)) # 王二 get方法如果获取不到对应的值不会报错,会返回None,并且第二个参数可以指定没有值的时候，返回默认值。\n1 2 3 4 5 6 7 print(person.keys()) # dict_keys([\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;score\u0026#39;]) print(person.values()) # dict_values([\u0026#39;张三\u0026#39;, 18, 100]) print(person.items()) # dict_items([(\u0026#39;name\u0026#39;, \u0026#39;张三\u0026#39;), (\u0026#39;age\u0026#39;, 18), (\u0026#39;score\u0026#39;, 100)]) for item in person.items(): print(item) # (\u0026#39;name\u0026#39;, \u0026#39;张三\u0026#39;) (\u0026#39;age\u0026#39;, 18) (\u0026#39;score\u0026#39;, 100) for k,v in person.items(): print(item) # (\u0026#39;name\u0026#39;, \u0026#39;张三\u0026#39;) (\u0026#39;age\u0026#39;, 18) (\u0026#39;score\u0026#39;, 100) keys()方法获取所有的key，values()获取所有的value，items()方法能拿到所有的元素，返回的元素是一个元组，需要自己解包到对应的值上。\n函数 不定参数 1 2 3 4 5 6 7 8 9 10 def add(*args): print(type(args)) # \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; total = 0 # 对保存可变参数的元组进行循环遍历 for val in args: # 对参数进行了类型检查（数值型的才能求和） if type(val) in (int, float): total += val return total print(add(1, 2, 3,\u0026#34;hello\u0026#34;,4)) # 10 上面通过*args定义不定参数，可以传入任何类型，如果是int或者是float才累加。args参数是一个元组类型。\n1 2 3 4 5 def foo(*args, **kwargs): print(args) # (3, 2.1, True) print(kwargs) # {\u0026#39;name\u0026#39;: \u0026#39;张三\u0026#39;, \u0026#39;age\u0026#39;: 43, \u0026#39;gpa\u0026#39;: 4.95} print(type(kwargs)) # \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; foo(3, 2.1, True, name=\u0026#39;张三\u0026#39;, age=43, gpa=4.95) 上面**kwargs是一个字典类型，也是一种不定参数的类型写法。\n函数高级用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def calc(init_value, op_func, *args, **kwargs): items = list(args) + list(kwargs.values()) result = init_value for item in items: if type(item) in (int, float): result = op_func(result, item) return result def add(x, y): return x + y def mul(x, y): return x * y print(calc(0, add, 1, 2, 3, 4, 5)) # 15 print(calc(1, mul, 1, 2, 3, 4, 5)) # 120 上面的calc方法在上面的不定参数中增加了init_value和op_func参数，其中init_value是初始值，op_func是传入的函数，通过外界传入函数来进行运算，有点像kotlin的高阶函数。比如下面传入add方法的时候，是对参数求和，传入mul函数的时候是对参数求乘积。 也可以传入operator模块中定义的函数：\n1 2 3 import operator print(calc(0, operator.add, 1, 2, 3, 4, 5)) # 15 print(calc(1, operator.mul, 1, 2, 3, 4, 5)) # 120 内置的高阶函数 1 2 3 4 5 6 7 8 9 10 11 def is_even(num): \u0026#34;\u0026#34;\u0026#34;判断num是不是偶数\u0026#34;\u0026#34;\u0026#34; return num % 2 == 0 def square(num): \u0026#34;\u0026#34;\u0026#34;求平方\u0026#34;\u0026#34;\u0026#34; return num ** 2 old_nums = [35, 12, 8, 99, 60, 52] new_nums = list(map(square, filter(is_even, old_nums))) print(new_nums) # [144, 64, 3600, 2704] 上面的filter和map都是高阶函数，它们的第一个参数是要传入的方法，第二个参数是数据源。filter先过滤出列表的偶数，然后map进行平方操作。最后返回一个列表。\n1 2 3 old_strings = [\u0026#39;in\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;zoo\u0026#39;, \u0026#39;waxberry\u0026#39;, \u0026#39;pear\u0026#39;] new_strings = sorted(old_strings, key=len) print(new_strings) # [\u0026#39;in\u0026#39;, \u0026#39;zoo\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;waxberry\u0026#39;] 前面讲过list的sort()方法， 此处的sorted方法也是类似，此处可以传入key，它也是一个方法，此处通过字符串的长度进行排序。\nLambda函数 1 2 3 old_nums = [35, 12, 8, 99, 60, 52] new_nums = list(map(lambda x: x ** 2, filter(lambda x: x % 2 == 0, old_nums))) print(new_nums) # [144, 64, 3600, 2704] filter中传入lambda x: x % 2 == 0，它就是一个Lambda函数，x表示输入，冒号后面是运算操作，最后一条语句是lambda的返回值，用来判断是不是偶数，map中传入lambda x: x ** 2，它也是一个Lambda函数，用来求平方。\n1 2 3 4 5 6 7 8 9 10 11 12 import functools import operator # 用一行代码实现计算阶乘的函数 fac = lambda n: functools.reduce(operator.mul, range(2, n + 1), 1) # 用一行代码实现判断素数的函数 is_prime = lambda x: all(map(lambda f: x % f, range(2, int(x ** 0.5) + 1))) # 调用Lambda函数 print(fac(6)) # 720 print(is_prime(37)) # True 首先reduce函数是python标准库functools模块中的函数，可以实现对一组数据的规约操作，类似上面讲的calc函数，第一个参数是运算的函数，第二个参数是运算的数据，第三个参数是初始值。第二个判断素数是首先通过map传入lambda计算x%f是否不能整除，f的是lambda的输入，输入\n","date":"2025-10-30T00:00:00Z","permalink":"http://xiangcman.xyz/p/python%E5%B8%B8%E8%A7%81%E8%AF%AD%E6%B3%95%E4%B8%80/","title":"Python常见语法一"},{"content":"谈到Android中的anr监控，一般比较可靠是通过监听系统给进程发送的SIGQUIT信号，我们可以使用sigaction函数增加SIGQUIT信号的捕获，然后在信号处理函数中判断SIGQUIT做相应的处理，监听信号如下代码：\n1 sigaction(SIGQUIT, \u0026amp;sa, \u0026amp;old_sa[SIGILL]); 该方法在signal.h中的方法，方法定义如下：\n1 int sigaction(int __signal, const struct sigaction* __new_action, struct sigaction* __old_action); 第一个参数是信号类型，因此ANR是监听SIGQUIT信号，所以此处直接给该信号。 第二个参数是新安装的信号处理行为（即告诉系统以后这个信号怎么处理）。 第三个参数是用来保存原来的信号处理行为（可选，如果你想之后恢复的话）。 这里着重看下sigaction被struct修饰的结构体的定义： 1 2 3 4 5 6 7 8 9 10 #define __SIGACTION_BODY \\ int sa_flags; \\ union { \\ sighandler_t sa_handler; \\ void (*sa_sigaction)(int, struct siginfo*, void*); \\ }; \\ sigset_t sa_mask; \\ void (*sa_restorer)(void); \\ struct sigaction { __SIGACTION_BODY }; sa_flags:行为控制的标志，比如SA_RESTART、SA_SIGINFO等。 SA_RESTART：被信号中断的系统调用自动重启。 SA_SIGINFO：使用sa_sigaction替代sa_handler。 SA_ONSTACK：使用备用信号栈。SA_NODEFER：不屏蔽当前信号。 sa_handler：信号处理函数 sa_sigaction：带上下文的高级处理函数（与SA_SIGINFO配合使用） sa_mask：当处理信号时，临时屏蔽哪些信号 如果只是按照上面的sigaction函数监听SIGQUIT信号的时候，会发现处理函数是捕获不到SIGQUIT信号，那是因为系统屏蔽了SIGQUIT信号，不允许sigaction接受SIGQUIT信号。\n程序启动的时候会启动一个SignalCatcher线程，该线程会通过sigwait函数阻塞监听SIGQUIT信号。sigwait函数也是监听信号的函数，相比于sigaction函数，它是同步接收的方式，也就是只允许一个地方监听指定的信号，而sigaction函数是异步的，可以在多个地方都监听之心信号并进行处理。 虽然系统屏蔽了 sigaction 异步接收 SIGQUIT 信号的方式，但是没法屏蔽通过 sigwait 同步监听 SIGQUIT 信号 ，这样也保障了 SignalCatcher 线程接收到 SIGQUIT 信号后，能够正常的获取进程中的各个线程的信息，并输出到 /data/anr/traces.txt 文件中。\n虽然 SIGQUIT 信号被系统屏蔽了，但是我们可以使用 pthread_sigmask 函数将 SIGQUIT 信号从当前线程的信号屏蔽集中移除，实现如下：\n1 2 3 4 5 6 7 sigset_t new_set; // 初始化清空信号集 sigemptyset(\u0026amp;new_set); // 将 SIGQUIT 信号添加到信号集 sigaddset(\u0026amp;new_set, SIGQUIT); // 将当前线程的信号屏蔽集设置为信号集的补集，即解除 SIGQUIT 信号的屏蔽 pthread_sigmask(SIG_UNBLOCK, \u0026amp;new_set, \u0026amp;old_set); 解除对SIGQUIT信号的屏蔽后，下面就能捕获到SIGQUIT信号了，然后我们在信号的处理函数中判断是SIGQUIT信号来对ANR的处理，并捕获ANR的trace数据，还需要保证原来的SignalCatcher线程能响应SIGQUIT信号的，这里我们想下，既然上面解除了当前线程接收到SIGQUIT信号后，那么当前线程会拦截掉了SIGQUIT信号，那么SignalCatcher线程就接收不到SIGQUIT信号了，所以需要给SignalCatcher补发一次SIGQUIT信号，因为SignalCatcher线程的主要职责如下：\n注册 SIGQUIT 的 handler； 当系统（如 system_server）向 app 进程发送 SIGQUIT 时，负责 dump 所有线程的堆栈； 输出 trace 到 /data/anr/traces.txt。 由于SignalCatcher 线程不是通过 sigaction 来响应 SIGQUIT 信号的，所以我们直接执行 old_sa 是没法生效的，此时可以通过 tgkill 信号发生函数 tgkill，往 SignalCatcher 线程发生一个 SIGQUIT 信号，tgkill 函数往指定线程发送信号时需要知道线程的 id，所以我们还需要通过遍历 /proc/{pid}/task 目录下所记录的该进程下所有的线程数据，拿到名称为 “SignalCatcher” 线程对应的线程 id。代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int getSignalCatcherThreadId() { std::string proc_path = \u0026#34;/proc/\u0026#34; + std::to_string(getpid()) + \u0026#34;/task\u0026#34;; DIR *dir = opendir(proc_path.c_str()); if (dir == nullptr) return -1; struct dirent *entry; while ((entry = readdir(dir)) != nullptr) { std::string name = entry-\u0026gt;d_name; if (std::all_of(name.begin(), name.end(), ::isdigit)) { std::string status_path = proc_path + \u0026#34;/\u0026#34; + name + \u0026#34;/status\u0026#34;; std::ifstream status_file(status_path); if (!status_file.is_open()) continue; std::string line; while (std::getline(status_file, line)) { if (line.find(\u0026#34;Name:\\tSignalCatcher\u0026#34;) != std::string::npos) { int tid = std::stoi(name); closedir(dir); return tid; } } } } closedir(dir); return -1; } int tid = getSignalCatcherThreadId(); if (tid != -1) { tgkill(getpid(), tid, SIGQUIT); // 转发给 SignalCatcher 线程 } 上面就完成了当前线程监听SIGQUIT信号，虽然完成了SIGQUIT信号的监听，但是不能保证是当前进程出现了ANR,因为有可能其他应用发生ANR时，cpu使用率占用比较高的进程也会收到SIGQUIT信号。其他进程或者线程也可以手动调用tgkill函数发送SIGQUIT信号给当前进程，因此我们还需要二次确认当前进程发生了ANR,二次确认的方案一般有下面两种：\n当进程发生ANR的时候，在ActivityManagerService通知进程启动ANR弹框前，会给发生了ANR的进程设置一个NOT_RESPONDING的标志位，表示该进程发生了ANR，而这个标志位可以通过ActivityManager的getProcessesInErrorState方法来获取，思路就是在上面监听到SIGQUIT信号后，通过jni方法回调到java层，然后在java层判断这个标志位判断是不是当前进程发生了ANR,来进行二次确认。 我们都知道主线程中消息队列的消息是按照时间先后的顺序进行排列，每次都会取队列的最开始的消息，每个消息是通过变量when放到队列的，所以我们可以判断消息队列中的开始消息when和当前时间对比，如果超过我们设置的阈值，就认为发生了anr。 关于上面两种方案各有利弊，第一种方案会存在漏掉，因为存在一些后台的ANR不会通过ActivityManagerService给进程设置一个NOT_RESPONDING的标志位，因为后台的ANR会直接杀死进程，此时都没机会捕捉该标志位了。还有种情况是闪退ANR，相当一部分机型（例如OPPO、VIVO两家的高Android版本的机型）修改了ANR的流程，即使是发生在前台的ANR,也不会弹框，而是直接杀死进程，也就是闪退。这部分的机型覆盖的用户量也非常大。并且，确定两家今后的新设备会一直维持这个机制。所以基于此，第二种方案更加全面，但是第二种方案也会存在弊端，它需要版本的兼容，因为在低版本中无法获取到messageQueue，并且是通过反射的手段来进行获取。\n第一种方案(获取标志位)实现代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //jni回调方法 void anrDumpTraceCallback() { if (g_vm == nullptr || g_utils_class == nullptr) return; JNIEnv *env = nullptr; if (g_vm-\u0026gt;AttachCurrentThread(\u0026amp;env, nullptr) != JNI_OK) return; jmethodID method = env-\u0026gt;GetStaticMethodID(g_utils_class, \u0026#34;onANRDumpTrace\u0026#34;, \u0026#34;()V\u0026#34;); if (method != nullptr) { env-\u0026gt;CallStaticVoidMethod(g_utils_class, method); } g_vm-\u0026gt;DetachCurrentThread(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static void onANRDumpTrace() { Log.d(\u0026#34;MyUtils\u0026#34;, \u0026#34;onANRDumpTrace start\u0026#34;); ActivityManager am = (ActivityManager) getSystemService(context, ActivityManager.class); if (am != null) { List\u0026lt;ActivityManager.ProcessErrorStateInfo\u0026gt; errorList = am.getProcessesInErrorState(); if (errorList != null \u0026amp;\u0026amp; !errorList.isEmpty()) { for (ActivityManager.ProcessErrorStateInfo info : errorList) { if (info.condition == ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING) { Log.e(\u0026#34;MyUtils\u0026#34;, \u0026#34;ANR detected in process: \u0026#34; + info.processName); // 二次确认ANR，用于ANR记录或者上报 // ... } } } } } 第二种方案代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @RequiresApi(api = Build.VERSION_CODES.M) private static boolean isMainThreadBlocked() { try { MessageQueue mainQueue = Looper.getMainLooper().getQueue(); Field field = mainQueue.getClass().getDeclaredField(\u0026#34;mMessages\u0026#34;); field.setAccessible(true); final Message mMessage = (Message) field.get(mainQueue); if (mMessage != null) { anrMessageString = mMessage.toString(); long when = mMessage.getWhen(); if (when == 0) { return false; } long time = when - SystemClock.uptimeMillis(); anrMessageWhen = time; long timeThreshold = BACKGROUND_MSG_THRESHOLD; if (currentForeground) { timeThreshold = FOREGROUND_MSG_THRESHOLD; } return time \u0026lt; timeThreshold; } else { MatrixLog.i(TAG, \u0026#34;mMessage is null\u0026#34;); } } catch (Exception e) { return false; } return false; } 在二次确认后，还需要对trace文件进行获取，trace文件会存储在/data/anr/traces.txt，文件的内容非常全面，包含了所有线程的各种状态、锁和堆栈，但是很不幸的是应用程序没有权限获取到该文件，所以我们需要间接获取该文件的数据内容。在上面提到的SignalCatcher线程收到SIGQUIT信号后，会收集各个线程的trace信息，并通过系统的write方法把trace的数据写到/data/anr/traces.txt文件中。如果我们能够Hook住这个write方法，就可以获取写入到traces.txt文件的内容了。这里我们使用PLT Hook技术，拦截住该write方法，就可以获取写入到traces.txt文件的内容。这里的write方法是libc.so库中，此处使用bhook拦截住该库的方法就能获取到该trace内容了，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void dealAnr() { bytehook_hook_all( \u0026#34;libc.so\u0026#34;, \u0026#34;write\u0026#34;, (void *) my_write, nullptr, nullptr); } ssize_t my_write(int fd, const void *const buf, size_t count) { BYTEHOOK_STACK_SCOPE(); if (buf != nullptr) { std::string content((const char *) buf, count); if (content.find(\u0026#34;Cmd line\u0026#34;) != std::string::npos) { LOGI(\u0026#34;Detected ANR trace write. Triggering callback...\u0026#34;); anrDumpTraceCallback(); // 回调 Java 方法 } std::ofstream file(\u0026#34;/data/data/com.example.nativelib/example_anr.txt\u0026#34;, std::ios::app); if (file.is_open()) { file \u0026lt;\u0026lt; content; file.close(); } } return BYTEHOOK_CALL_PREV(my_write, fd, buf, count); } 当进程发生anr后，会在上面的目录中生成example_anr.txt文件，我们来测试一波： 从上面日志也能看出来主线程出现了sleep状态，阻塞了主线程的，并且对应有堆栈行号。上面说的二次确认中目前试了android13和15都不太行，ActivityManager的getProcessesInErrorState方法已经不对外提供出错的进程信息了，并且在android10以上不让获取messageQueue中的messages了。所以对应anr的二次确认已经算是一个阉割了吧，只能获取trace日志了。\n参考：\nhttps://juejin.cn/post/7371779128477302823?searchId=20251029174718B15D0AE28A87EE70C32C https://mp.weixin.qq.com/s/fWoXprt2TFL1tTapt7esYg?mode=light ","date":"2025-10-29T00:00:00Z","permalink":"http://xiangcman.xyz/p/android%E4%B8%ADanr%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/","title":"Android中anr监控搭建"},{"content":"weditor是一个Python的插件，通过该插件，可以通过一些命令控制手机，比如我今天要讲的是通过它能自动化连接设置手机的wifi代理。\nweditor安装 基本都是python的常规命令，首先是安装weditor：\n1 pip install weditor 安装完我们检查下是否安装上：\n1 which weditor 该命令会输出weditor的安装目录，然后通过weditor命令可以打开网页版： 左边是手机当前呈现的样式，右边是命令，中间是描述组件的一些属性，其实我们在手机上操作什么，最右边会把命令输出出来。最右边就是我连接代理的命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import uiautomator2 as u2 d = u2.connect() # 连接设备 # 打开 WiFi 设置 d.app_start(\u0026#34;com.android.settings\u0026#34;) d(text=\u0026#34;WLAN\u0026#34;).click() d.sleep(1) d(text=\u0026#34;Wifi的名字\u0026#34;).click() d.swipe_ext(\u0026#34;up\u0026#34;,0.8) d.sleep(1) d(text=\u0026#34;代理\u0026#34;).click() d(text=\u0026#34;手动\u0026#34;).click() d.swipe_ext(\u0026#34;up\u0026#34;,0.8) ipNode = d.xpath(\u0026#39;//*[@resource-id=\u0026#34;com.oplus.wirelesssettings:id/recycler_view\u0026#34;]/android.widget.LinearLayout[8]/android.widget.LinearLayout[1]/android.view.ViewGroup[1]/android.view.ViewGroup[1]/android.widget.FrameLayout[1]\u0026#39;) # ipNode.click() ipNode.set_text(\u0026#34;10.100.3.152\u0026#34;) portNode = d.xpath(\u0026#39;//*[@resource-id=\u0026#34;com.oplus.wirelesssettings:id/recycler_view\u0026#34;]/android.widget.LinearLayout[9]/android.widget.LinearLayout[1]/android.view.ViewGroup[1]/android.view.ViewGroup[1]/android.widget.FrameLayout[1]\u0026#39;) # portNode.click() portNode.set_text(\u0026#34;8888\u0026#34;) d(resourceId=\u0026#34;com.oplus.wirelesssettings:id/coui_toolbar_back_view\u0026#34;).click() 这就实现了一个wifi连接代理，但是如果要做好自动化连接代码，需要考虑的因素很多，比如下面我把连接代码和取消代理的过程按照如下写出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 import argparse import sys import time import uiautomator2 as u2 WLAN_TEXTS = [\u0026#34;WLAN\u0026#34;, \u0026#34;Wi‑Fi\u0026#34;, \u0026#34;WiFi\u0026#34;, \u0026#34;WLAN 和互联网\u0026#34;, \u0026#34;网络和互联网\u0026#34;] PROXY_TEXTS = [\u0026#34;代理\u0026#34;, \u0026#34;Proxy\u0026#34;] MANUAL_TEXTS = [\u0026#34;手动\u0026#34;, \u0026#34;Manual\u0026#34;] SAVE_TEXTS = [\u0026#34;保存\u0026#34;, \u0026#34;Save\u0026#34;, \u0026#34;应用\u0026#34;, \u0026#34;Apply\u0026#34;] BACK_IDS = [ \u0026#34;com.oplus.wirelesssettings:id/coui_toolbar_back_view\u0026#34;, \u0026#34;com.android.settings:id/action_bar\u0026#34;, # 某些机型返回按钮容器 ] LAUNCHER_PKGS = [ \u0026#34;com.android.launcher3\u0026#34;, \u0026#34;com.google.android.apps.nexuslauncher\u0026#34;, \u0026#34;com.coloros.launcher\u0026#34;, \u0026#34;com.oneplus.launcher\u0026#34;, \u0026#34;com.miui.home\u0026#34;, \u0026#34;com.huawei.android.launcher\u0026#34;, \u0026#34;org.lineageos.launcher\u0026#34;, ] def log(msg): print(f\u0026#34;[INFO] {msg}\u0026#34;) def err(msg): print(f\u0026#34;[ERROR] {msg}\u0026#34;, file=sys.stderr) def sh(d, cmd): r = d.shell(cmd) # 统一拿到纯文本 if isinstance(r, dict) and \u0026#34;output\u0026#34; in r: out = r[\u0026#34;output\u0026#34;] elif hasattr(r, \u0026#34;output\u0026#34;): out = r.output else: out = r if out is None: return \u0026#34;\u0026#34; if isinstance(out, (bytes, bytearray)): out = out.decode(\u0026#34;utf-8\u0026#34;, errors=\u0026#34;ignore\u0026#34;) return str(out) def is_wifi_on(d): # 优先从 dumpsys 读状态 txt = sh(d, \u0026#39;dumpsys wifi | grep -iE \u0026#34;wi-?fi is\u0026#34; || true\u0026#39;).lower() if \u0026#34;enabled\u0026#34; in txt: return True if \u0026#34;disabled\u0026#34; in txt: return False # 退化到全局设置（有些系统可能返回 \u0026#34;null\u0026#34;） val = sh(d, \u0026#34;settings get global wifi_on || true\u0026#34;).strip() return val == \u0026#34;1\u0026#34; def ensure_wifi_on(d, timeout=10): sh(d, \u0026#34;svc wifi enable || true\u0026#34;) end = time.time() + timeout while time.time() \u0026lt; end: if is_wifi_on(d): return True time.sleep(0.4) return False def wait_and_click_text(d, candidates, timeout=10, must=True): end = time.time() + timeout while time.time() \u0026lt; end: for t in candidates if isinstance(candidates, list) else [candidates]: obj = d(text=t) if obj.exists: obj.click() return True time.sleep(0.3) if must: raise RuntimeError(f\u0026#34;找不到文本: {candidates}\u0026#34;) return False def wait_exists_text(d, candidates, timeout=10): end = time.time() + timeout while time.time() \u0026lt; end: for t in candidates if isinstance(candidates, list) else [candidates]: if d(text=t).exists: return t time.sleep(0.3) return None def scroll_to_text_and_click(d, target_text, max_swipes=10): for _ in range(max_swipes): if d(text=target_text).exists: d(text=target_text).click() return True if d(scrollable=True).exists: d(scrollable=True).scroll.vert.forward(steps=30) else: d.swipe_ext(\u0026#34;up\u0026#34;, 0.8) time.sleep(0.2) raise RuntimeError(f\u0026#34;滚动仍未找到: {target_text}\u0026#34;) def go_home(d, timeout=0): d.press(\u0026#34;home\u0026#34;) if timeout \u0026lt;= 0: # 直接返回，不等待检测 return True end = time.time() + timeout while time.time() \u0026lt; end: cur = d.app_current() or {} if cur.get(\u0026#34;package\u0026#34;) in LAUNCHER_PKGS: return True time.sleep(0.1) d.press(\u0026#34;home\u0026#34;) # 兜底，不阻塞 d.shell(\u0026#34;am start -a android.intent.action.MAIN -c android.intent.category.HOME\u0026#34;) return True def click_any_back(d, isGoHome=False, go_home_timeout=0): for t in SAVE_TEXTS: if d(text=t).exists: d(text=t).click() break else: for rid in BACK_IDS: if d(resourceId=rid).exists: d(resourceId=rid).click() break else: d.press(\u0026#34;back\u0026#34;) if isGoHome: go_home(d, timeout=go_home_timeout) def set_edit_texts(d, host, port, clear_first=True): # 代理为“手动”后，通常会出现两个 EditText：主机、端口 # 避免复杂 XPath，直接找可见的 EditText edits = d(className=\u0026#34;android.widget.EditText\u0026#34;) if len(edits) \u0026lt; 2: # 可能未滚到位或控件延迟出现，再尝试滚动几次 for _ in range(4): d.swipe_ext(\u0026#34;up\u0026#34;, 0.7) time.sleep(0.2) edits = d(className=\u0026#34;android.widget.EditText\u0026#34;) if len(edits) \u0026gt;= 2: break if len(edits) \u0026lt; 2: raise RuntimeError(\u0026#34;未找到代理主机/端口输入框\u0026#34;) host_edit = edits[0] port_edit = edits[1] if clear_first: try: host_edit.clear_text() port_edit.clear_text() except Exception: pass host_edit.set_text(host) port_edit.set_text(str(port)) def restart_settings(d): # 部分厂商把 Wi‑Fi 界面放在自家包里，一起停更稳 for pkg in (\u0026#34;com.android.settings\u0026#34;, \u0026#34;com.oplus.wirelesssettings\u0026#34;): d.app_stop(pkg) d.shell(f\u0026#34;am force-stop {pkg} || true\u0026#34;) # d.press(\u0026#34;home\u0026#34;) d.app_start(\u0026#34;com.android.settings\u0026#34;) d.app_wait(\u0026#34;com.android.settings\u0026#34;, timeout=10) def open_wifi_settings(d): ensure_wifi_on(d) # 先通过 shell 打开 Wi‑Fi log(\u0026#34;打开设置并进入 WLAN/Wi‑Fi\u0026#34;) restart_settings(d) # 有些机型首页不直接显示 WLAN，需要滚动或进“网络和互联网” found = wait_exists_text(d, WLAN_TEXTS, timeout=3) if not found: # 可能是“网络和互联网”一级菜单 wait_and_click_text(d, [\u0026#34;网络和互联网\u0026#34;, \u0026#34;Network \u0026amp; internet\u0026#34;], timeout=8, must=False) # 进入后再找 WLAN wait_and_click_text(d, WLAN_TEXTS, timeout=8, must=True) else: wait_and_click_text(d, WLAN_TEXTS, timeout=3, must=True) def set_wifi_proxy(d, ssid, host, port, wait=10): log(f\u0026#34;进入 Wi‑Fi: {ssid}\u0026#34;) # 滚动找到对应 SSID scroll_to_text_and_click(d, ssid, max_swipes=12) time.sleep(0.3) # 展开“代理”选项并选择“手动” log(\u0026#34;设置代理为手动\u0026#34;) # 页面可能有“高级选项”，先展开 if d(text=\u0026#34;高级选项\u0026#34;).exists: d(text=\u0026#34;高级选项\u0026#34;).click() # 滚动确保能看到“代理” for _ in range(4): if d(text=PROXY_TEXTS[0]).exists or d(text=PROXY_TEXTS[1]).exists: break d.swipe_ext(\u0026#34;up\u0026#34;, 0.7) time.sleep(0.2) wait_and_click_text(d, PROXY_TEXTS, timeout=wait, must=True) wait_and_click_text(d, MANUAL_TEXTS, timeout=wait, must=True) # 设置主机和端口 log(f\u0026#34;填入代理 {host}:{port}\u0026#34;) set_edit_texts(d, host, port) # 保存/返回 click_any_back(d, isGoHome=True,go_home_timeout=0) def main(): parser = argparse.ArgumentParser(description=\u0026#34;通过 uiautomator2 设置指定 Wi‑Fi 的 HTTP 代理\u0026#34;) parser.add_argument(\u0026#34;--device\u0026#34;, help=\u0026#34;设备IP（可选，默认USB或已配对）\u0026#34;, default=None) parser.add_argument(\u0026#34;--ssid\u0026#34;, required=True, help=\u0026#34;Wi‑Fi SSID\u0026#34;) parser.add_argument(\u0026#34;--host\u0026#34;, required=True, help=\u0026#34;代理主机\u0026#34;) parser.add_argument(\u0026#34;--port\u0026#34;, required=True, type=int, help=\u0026#34;代理端口\u0026#34;) parser.add_argument(\u0026#34;--wait\u0026#34;, type=int, default=10, help=\u0026#34;等待超时秒数\u0026#34;) args = parser.parse_args() try: #连接设备 d = u2.connect(args.device) if args.device else u2.connect() #可以传入连接的超时时间 d.implicitly_wait(args.wait) try: #打开设置页 open_wifi_settings(d) time.sleep(1) set_wifi_proxy(d, args.ssid, args.host, args.port, wait=args.wait) log(\u0026#34;完成\u0026#34;) except Exception as e: err(str(e)) sys.exit(1) except Exception as e: err(\u0026#34;未连接到设备，请检查 USB 或 IP 是否正确\u0026#34;) sys.exit(1) if __name__ == \u0026#34;__main__\u0026#34;: main() 下面再来看下取消代理如何写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 import argparse import sys import time import uiautomator2 as u2 from ppadb.client import Client as AdbClient WLAN_TEXTS = [\u0026#34;WLAN\u0026#34;, \u0026#34;Wi‑Fi\u0026#34;, \u0026#34;WiFi\u0026#34;, \u0026#34;WLAN 和互联网\u0026#34;, \u0026#34;网络和互联网\u0026#34;] PROXY_TEXTS = [\u0026#34;代理\u0026#34;, \u0026#34;Proxy\u0026#34;] MANUAL_TEXTS = [\u0026#34;无\u0026#34;] SAVE_TEXTS = [\u0026#34;保存\u0026#34;, \u0026#34;Save\u0026#34;, \u0026#34;应用\u0026#34;, \u0026#34;Apply\u0026#34;] BACK_IDS = [ \u0026#34;com.oplus.wirelesssettings:id/coui_toolbar_back_view\u0026#34;, \u0026#34;com.android.settings:id/action_bar\u0026#34;, # 某些机型返回按钮容器 ] LAUNCHER_PKGS = [ \u0026#34;com.android.launcher3\u0026#34;, \u0026#34;com.google.android.apps.nexuslauncher\u0026#34;, \u0026#34;com.coloros.launcher\u0026#34;, \u0026#34;com.oneplus.launcher\u0026#34;, \u0026#34;com.miui.home\u0026#34;, \u0026#34;com.huawei.android.launcher\u0026#34;, \u0026#34;org.lineageos.launcher\u0026#34;, ] def log(msg): print(f\u0026#34;[INFO] {msg}\u0026#34;) def err(msg): print(f\u0026#34;[ERROR] {msg}\u0026#34;, file=sys.stderr) def sh(d, cmd): r = d.shell(cmd) # 统一拿到纯文本 if isinstance(r, dict) and \u0026#34;output\u0026#34; in r: out = r[\u0026#34;output\u0026#34;] elif hasattr(r, \u0026#34;output\u0026#34;): out = r.output else: out = r if out is None: return \u0026#34;\u0026#34; if isinstance(out, (bytes, bytearray)): out = out.decode(\u0026#34;utf-8\u0026#34;, errors=\u0026#34;ignore\u0026#34;) return str(out) def is_wifi_on(d): # 优先从 dumpsys 读状态 txt = sh(d, \u0026#39;dumpsys wifi | grep -iE \u0026#34;wi-?fi is\u0026#34; || true\u0026#39;).lower() if \u0026#34;enabled\u0026#34; in txt: return True if \u0026#34;disabled\u0026#34; in txt: return False # 退化到全局设置（有些系统可能返回 \u0026#34;null\u0026#34;） val = sh(d, \u0026#34;settings get global wifi_on || true\u0026#34;).strip() return val == \u0026#34;1\u0026#34; def ensure_wifi_on(d, timeout=10): sh(d, \u0026#34;svc wifi enable || true\u0026#34;) end = time.time() + timeout while time.time() \u0026lt; end: if is_wifi_on(d): return True time.sleep(0.4) return False def wait_and_click_text(d, candidates, timeout=10, must=True): end = time.time() + timeout while time.time() \u0026lt; end: for t in candidates if isinstance(candidates, list) else [candidates]: obj = d(text=t) if obj.exists: obj.click() return True time.sleep(0.3) if must: raise RuntimeError(f\u0026#34;找不到文本: {candidates}\u0026#34;) return False def wait_exists_text(d, candidates, timeout=10): end = time.time() + timeout while time.time() \u0026lt; end: for t in candidates if isinstance(candidates, list) else [candidates]: if d(text=t).exists: return t time.sleep(0.3) return None def scroll_to_text_and_click(d, target_text, max_swipes=10): for _ in range(max_swipes): if d(text=target_text).exists: d(text=target_text).click() return True if d(scrollable=True).exists: d(scrollable=True).scroll.vert.forward(steps=30) else: d.swipe_ext(\u0026#34;up\u0026#34;, 0.8) time.sleep(0.2) raise RuntimeError(f\u0026#34;滚动仍未找到: {target_text}\u0026#34;) def go_home(d, timeout=0): d.press(\u0026#34;home\u0026#34;) if timeout \u0026lt;= 0: # 直接返回，不等待检测 return True end = time.time() + timeout while time.time() \u0026lt; end: cur = d.app_current() or {} if cur.get(\u0026#34;package\u0026#34;) in LAUNCHER_PKGS: return True time.sleep(0.1) d.press(\u0026#34;home\u0026#34;) # 兜底，不阻塞 d.shell(\u0026#34;am start -a android.intent.action.MAIN -c android.intent.category.HOME\u0026#34;) return True def click_any_back(d, isGoHome=False, go_home_timeout=0): for t in SAVE_TEXTS: if d(text=t).exists: d(text=t).click() break else: for rid in BACK_IDS: if d(resourceId=rid).exists: d(resourceId=rid).click() break else: d.press(\u0026#34;back\u0026#34;) if isGoHome: go_home(d, timeout=go_home_timeout) def set_edit_texts(d, host, port, clear_first=True): # 代理为“手动”后，通常会出现两个 EditText：主机、端口 # 避免复杂 XPath，直接找可见的 EditText edits = d(className=\u0026#34;android.widget.EditText\u0026#34;) if len(edits) \u0026lt; 2: # 可能未滚到位或控件延迟出现，再尝试滚动几次 for _ in range(4): d.swipe_ext(\u0026#34;up\u0026#34;, 0.7) time.sleep(0.2) edits = d(className=\u0026#34;android.widget.EditText\u0026#34;) if len(edits) \u0026gt;= 2: break if len(edits) \u0026lt; 2: raise RuntimeError(\u0026#34;未找到代理主机/端口输入框\u0026#34;) host_edit = edits[0] port_edit = edits[1] if clear_first: try: host_edit.clear_text() port_edit.clear_text() except Exception: pass host_edit.set_text(host) port_edit.set_text(str(port)) def restart_settings(d): # 部分厂商把 Wi‑Fi 界面放在自家包里，一起停更稳 for pkg in (\u0026#34;com.android.settings\u0026#34;, \u0026#34;com.oplus.wirelesssettings\u0026#34;): d.app_stop(pkg) d.shell(f\u0026#34;am force-stop {pkg} || true\u0026#34;) # d.press(\u0026#34;home\u0026#34;) d.app_start(\u0026#34;com.android.settings\u0026#34;) d.app_wait(\u0026#34;com.android.settings\u0026#34;, timeout=10) def open_wifi_settings(d): ensure_wifi_on(d) # 先通过 shell 打开 Wi‑Fi log(\u0026#34;打开设置并进入 WLAN/Wi‑Fi\u0026#34;) restart_settings(d) # 有些机型首页不直接显示 WLAN，需要滚动或进“网络和互联网” found = wait_exists_text(d, WLAN_TEXTS, timeout=3) if not found: # 可能是“网络和互联网”一级菜单 wait_and_click_text(d, [\u0026#34;网络和互联网\u0026#34;, \u0026#34;Network \u0026amp; internet\u0026#34;], timeout=8, must=False) # 进入后再找 WLAN wait_and_click_text(d, WLAN_TEXTS, timeout=8, must=True) else: wait_and_click_text(d, WLAN_TEXTS, timeout=3, must=True) def cancel_wifi_proxy(d, ssid, wait=10): log(f\u0026#34;进入 Wi‑Fi: {ssid}\u0026#34;) # 滚动找到对应 SSID scroll_to_text_and_click(d, ssid, max_swipes=12) time.sleep(0.3) # 展开“代理”选项并选择“手动” log(\u0026#34;取消代理\u0026#34;) # 页面可能有“高级选项”，先展开 if d(text=\u0026#34;高级选项\u0026#34;).exists: d(text=\u0026#34;高级选项\u0026#34;).click() # 滚动确保能看到“代理” for _ in range(4): if d(text=PROXY_TEXTS[0]).exists or d(text=PROXY_TEXTS[1]).exists: break d.swipe_ext(\u0026#34;up\u0026#34;, 0.7) time.sleep(0.2) wait_and_click_text(d, PROXY_TEXTS, timeout=wait, must=True) wait_and_click_text(d, MANUAL_TEXTS, timeout=wait, must=True) # 保存/返回 click_any_back(d,isGoHome=True,go_home_timeout=0) def main(): parser = argparse.ArgumentParser(description=\u0026#34;通过 uiautomator2 设置指定 Wi‑Fi 的 HTTP 代理被取消\u0026#34;) parser.add_argument(\u0026#34;--device\u0026#34;, help=\u0026#34;设备IP（可选，默认USB或已配对）\u0026#34;, default=None) parser.add_argument(\u0026#34;--ssid\u0026#34;, required=True, help=\u0026#34;Wi‑Fi SSID\u0026#34;) parser.add_argument(\u0026#34;--wait\u0026#34;, type=int, default=10, help=\u0026#34;等待超时秒数\u0026#34;) args = parser.parse_args() try: d = u2.connect(args.device) if args.device else u2.connect() d.implicitly_wait(args.wait) try: open_wifi_settings(d) time.sleep(1) cancel_wifi_proxy(d, args.ssid, wait=args.wait) log(\u0026#34;完成\u0026#34;) except Exception as e: err(str(e)) sys.exit(1) except Exception as e: err(\u0026#34;未连接到设备，请检查 USB 或 IP 是否正确\u0026#34;) sys.exit(1) if __name__ == \u0026#34;__main__\u0026#34;: main() 其实取消代理和设置代理差不多，只不过在选择代理的项目中，设置代理选择手动，而取消代理选择无，然后就退出设置代理页面了。最后回到home页面。\n","date":"2025-09-25T00:00:00Z","permalink":"http://xiangcman.xyz/p/%E9%80%9A%E8%BF%87python%E7%9A%84weditor%E6%8F%92%E4%BB%B6%E6%90%AD%E5%BB%BA%E6%89%8B%E6%9C%BAwifi%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5%E4%BB%A3%E7%90%86/","title":"通过python的weditor插件搭建手机wifi自动连接代理"},{"content":"我们先看一个native的crash例子:\n这是我在clion中写的一个测试代码，这个很明显，在程序第8行使用了一个未初始化的指针，然后运行最后，说程序被SIGSEGV信号终止了，该信号在c/c++中表示非法访问内存的信号，并且该终止没有指明代码行号。这在调试c++程序很头痛，不过在安卓ndk项目中如果想要定位是c++的问题，我们来一起看下。\n1 2 3 4 5 6 7 extern \u0026#34;C\u0026#34; JNIEXPORT void JNICALL Java_com_example_nativelib_CrashActivity_testNativeCrash(JNIEnv *env, jobject thiz) { int* p; int a = 10; *p = 20; } 然后在activity里面通过jni调用该方法：\n1 2 3 4 5 native void testNativeCrash(); static { System.loadLibrary(\u0026#34;crash_monitor\u0026#34;); } crash的日志如下：\n1 2 3 4 5 6 7 --------- beginning of crash 2025-08-28 14:56:29.639 2487-2487 libc com.example.nativelib A Fatal signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0 in tid 2487 (ample.nativelib), pid 2487 (ample.nativelib) 2025-08-28 14:56:30.559 2724-2724 DEBUG pid-2724 A Cmdline: com.example.nativelib 2025-08-28 14:56:30.559 2724-2724 DEBUG pid-2724 A pid: 2487, tid: 2487, name: ample.nativelib \u0026gt;\u0026gt;\u0026gt; com.example.nativelib \u0026lt;\u0026lt;\u0026lt; 2025-08-28 14:56:30.559 2724-2724 DEBUG pid-2724 A #00 pc 0000000000000644 /data/app/~~uAk5HwqkTX5ikhOJ94KruQ==/com.example.nativelib-nvfAk1bvIIxGrBGSolPLNw==/base.apk!libcrash_monitor.so (Java_com_example_nativelib_CrashActivity_testNativeCrash+28) (BuildId: 3f3fdcb6b22b15038811fa94da4200e7cc25d684) 2025-08-28 14:56:30.559 2724-2724 DEBUG pid-2724 A #03 pc 0000000000000880 [anon:dalvik-classes4.dex extracted in memory from /data/app/~~uAk5HwqkTX5ikhOJ94KruQ==/com.example.nativelib-nvfAk1bvIIxGrBGSolPLNw==/base.apk!classes4.dex] (com.example.nativelib.CrashActivity$1.onClick+4) 2025-08-28 14:56:30.559 2724-2724 DEBUG pid-2724 A #07 pc 000000000038fa62 [anon:dalvik-classes.dex extracted in memory from /data/app/~~uAk5HwqkTX5ikhOJ94KruQ==/com.example.nativelib-nvfAk1bvIIxGrBGSolPLNw==/base.apk] (com.google.android.material.button.MaterialButton.performClick+22) 日志解读 第一行日志 Signal 11 (SIGSEGV):因为SIGSEGV信号失败的，和上面的clion中一致。 SEGV_MAPERR：访问了未映射的内存。 fault addr 0x0：出错地址是 0x0，说明是典型的 空指针访问。 tid: 2487 (ample.nativelib), pid: 2487 (ample.nativelib)：崩溃发生在主线程（tid==pid==2487）。所以是ui线程直接调用native方法导致的crash。 调用堆栈 #00 pc 0000000000000644 libcrash_monitor.so (Java_com_example_nativelib_CrashActivity_testNativeCrash+28) 崩溃点在so库：libcrash_monitor.so 对应JNI方法：Java_com_example_nativelib_CrashActivity_testNativeCrash +28表示在这个JNI函数的第28个字符处发生了错误 0000000000000644：相对于该so加载基址（base address）的偏移量 崩溃定位 addr2line 它是在ndk目录中，首先需要查看项目使用的ndk版本，通过./gradlew app:assembleDebug --info | grep ndk来查看ndk版本，或者在app的module的build.gradle中指定ndk版本或者在local.properties中指定ndk版本，我这里用的是21.3.6528147版本，并且机器是64位，命令如下： 1 /Users/xiangcheng/Library/Android/sdk/ndk/21.3.6528147/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android-addr2line -C -f -e /Users/xiangcheng/AndroidStudioProjects/NativeProject/app/build/intermediates/cxx/Debug/6p5m14a5/obj/arm64-v8a/libcrash_monitor.so 0x00644 首先是addr2line的本地地址，-C:启用 demangling（符号还原），把 C++ 的 mangled name（符号修饰名） 转换成人类可读的函数签名。我这里是jni方法，所以不存在函数还原。-f：打印函数名，默认只输入文件名+行号，加上-f才会显示对应的函数名。-e是so的路径，最后输入偏移地址。命令结果如下： 第一行是方法名，第二行是哪个文件的行号，可以看到对应了cpp的第13行。 addr2line的缺点是只能进行单条地址定位 在上面取的so路径是build/intermediates/cxx/..下面，而最终打到apk的so是这样的过程： 在agp4.0之前: /build/intermediates/cmake|ndkBuild/.../obj/...(编译产物) /build/intermediates/merged_native_libs/.../out/lib/...(打包前，也就是汇总所有依赖之后的集合目录，也是没有被剔除符号的so) /build/intermediates/stripped_native_libs/so文件(剥离了调试符号后的版本) 在agp4.0之后: /build/intermediates/cxx/.../obj/...(编译产物，带符号) /build/intermediates/merged_native_libs/.../out/lib/...(打包前，也就是汇总所有依赖之后的集合目录，也是没有被剔除符号的so) /build/intermediates/stripped_native_libs/so文件(剥离了调试符号后的版本) 这里验证下三者的区别： 使用merged_native_libs下的so，命令如下： 1 /Users/xiangcheng/Library/Android/sdk/ndk/21.3.6528147/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android-addr2line -C -f -e /Users/xiangcheng/AndroidStudioProjects/NativeProject/app/build/intermediates/merged_native_libs/debug/mergeDebugNativeLibs/out/lib/arm64-v8a/libcrash_monitor.so 0x00644 结果如下： 可以看到类名和行号基本和前面的obj目录下的so基本一致。 使用stripped_native_libs下的so，命令如下： 1 /Users/xiangcheng/Library/Android/sdk/ndk/21.3.6528147/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android-addr2line -C -f -e /Users/xiangcheng/AndroidStudioProjects/NativeProject/app/build/intermediates/stripped_native_libs/debug/stripDebugDebugSymbols/out/lib/arm64-v8a/libcrash_monitor.so 0x00644 结果如下： 此处由于testNativeCrash方法是一个jni方法，不会被混淆方法名，但是行号信息是丢失了，可以看出来strip之后的so是不带有行号信息。 打进apk中的so是剥离调试符号的so吗？ 不一定是。如果没有开启strip，那就取的是merged_native_libs目录下的。否则取的是stripped_native_libs目录下的so文件 ndk-stack 它是ndk自带工具，可以直接解析logcat崩溃堆栈，把pc偏移映射回源码行 用法： 1 ndk-stack -sym /Users/xiangcheng/AndroidStudioProjects/NativeProject/app/build/intermediates/cxx/Debug/6p5m14a5/obj/arm64-v8a -dump log sys：指定so的路径，这里不用指明是哪一个so，只需要定位到cpu架构的类型文件夹就行，dump：指定log的地址，此处的log是在上面crash后，我通过logcat导出了log。最后输出的内容如下： 1 2 3 4 5 6 ********** Crash dump: ********** Build fingerprint: \\u0027Xiaomi/umi/umi:13/TKQ1.221114.001/V816.0.5.0.TJBCNXM:user/release-keys\\u0027\u0026#34; #00 0x0000000000000644 /data/app/~~uAk5HwqkTX5ikhOJ94KruQ\\u003d\\u003d/com.example.nativelib-nvfAk1bvIIxGrBGSolPLNw\\u003d\\u003d/base.apk!libcrash_monitor.so (Java_com_example_nativelib_CrashActivity_testNativeCrash+28) (BuildId: 3f3fdcb6b22b15038811fa94da4200e7cc25d684)\u0026#34; Java_com_example_nativelib_CrashActivity_testNativeCrash /Users/xiangcheng/AndroidStudioProjects/NativeProject/app/src/main/cpp/signal_crash.cpp:13:8 Crash dump is completed 可以看到也是定位到signal_crash.cpp文件的第13行出现了问题。 ","date":"2025-08-19T00:00:00Z","permalink":"http://xiangcman.xyz/p/native%E7%9A%84crash%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D/","title":"Native的crash如何定位"},{"content":"plthook技术在native的hook代码上起到关键的作用，native的函数调用分为内部调用和外部调用。内部调用指的是so内部的方法调用，当so被打包好后，so内部的方法都会被分配一个偏移地址，所以如果是内部函数的调用，那么直接通过编译期间给函数分配偏移地址就能去调用内部的其它方法。 如果是外部调用，也就是调用其它so的方法，就只能通过绝对地址来调用了，也就是该外部so的首地址+函数的偏移地址。我们通过一个例子来说明外部调用的过程：\n1 2 3 4 5 6 extern \u0026#34;C\u0026#34; JNIEXPORT void JNICALL Java_com_example_nativelib_MainActivity_MallocLeak(JNIEnv *env, jobject thiz) { malloc(88 * 1000 * 1000); __android_log_print(ANDROID_LOG_DEBUG, \u0026#34;hookMallocByPLTHook\u0026#34;, \u0026#34;原来的malloc函数被调用\u0026#34;); } 这里我在jni的方法MallocLeak方法中调用了malloc方法，它是lic.so库中的方法，所以我们认为它是一个外部调用的方法。 jni方法解释：extern \u0026ldquo;C\u0026rdquo;，告诉c++编译器，该方法是一个jni的方法，你不能混淆该方法，要不然java层找不到该方法的签名。下面的__android_log_print是调用了android库的log方法，用该方法的时候需要导入android/log.h，JNIEXPORT void JNICALL是一个跨平台的两个宏定义。一般在windows平台上如何没有该宏会报错。在jni方法参数上有两个，一个jni环境的方法，它是一个指针变量，第二个参数是java层谁调用的对象，比如我示例中是通过MainActivity调用的，那么此处的jobject就是MainActivity对象。 在java层就应该有该native方法的定义。\n1 external fun MallocLeak() 在kotlin代码中没有native关键字，用external关键字定义native方法。下面我们再来看下CMakeLists.txt文件，它是用来定义会构建哪几个so库，以及每一个so库是由那些c层代码构建的。以及每一个so库它所需要依赖的其它三方库有哪些：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //定义cmake的编译版本 cmake_minimum_required(VERSION 3.22.1) //用来定义native项目的名字，我感觉没有实际意义 project(\u0026#34;nativelib\u0026#34;) #查找并引入一个外部库bytehook，要求必须找到它（REQUIRED），并且以Config模式查找（寻找 bytehookConfig.cmake或类似文件） find_package(bytehook REQUIRED CONFIG) #此处的CMAKE_PROJECT_NAME就是project中定义nativelib字符串 #声明要编译生成一个库，库的名字是CMAKE_PROJECT_NAME，也就是nativelib.so #SHARED：表示生成一个 共享库（.so 文件）；如果是 STATIC，则为 .a 静态库。 #native-lib.cpp：要参与编译的源文件 add_library(${CMAKE_PROJECT_NAME} SHARED native-lib.cpp) #为你生成的库添加链接依赖 #此处总共添加3个依赖库 #android:链接Android NDK提供的libandroid.so #log:链接Android日志库liblog.so，用于 __android_log_print() 等函数 #bytehook::bytehook:链接bytehook这个第三方库（前提是已通过find_package引入） target_link_libraries(${CMAKE_PROJECT_NAME} android log bytehook::bytehook) #生成一个anr_monitor.so的库 add_library(anr_monitor SHARED signal-anr.cpp) target_link_libraries(anr_monitor android log bytehook::bytehook) 上面的cmake构建文件中，我定义了要构建两个so，其中一个so叫nativelib.so，另外一个叫anr_monitor.so。在定义之前我定义了一个find_package方法，用来引入一个外部库bytehook。add_library方法表示要构建的so由哪些c/c++类。target_link_libraries方法表示该so库需要哪些三方库的支持，比如android log bytehook::bytehook是我们要在c++代码中使用的三方库。如果要生成更多的so，依次类推。 在上面的nativelib.so的构建过程中，参与编译的文件是native-lib.cpp，前面我们已经介绍过jni方法Java_com_example_nativelib_MainActivity_MallocLeak。在它里面调用了外部so的方法malloc来申请内存，malloc方法是lic.so外部库的方法，我们的目的是通过plthook技术来实现malloc方法的监听，从而做自己的事情。前面已经讲过plthook技术其实是通过拦截外部so的方法调用，具体它是通过so内部的plt表跳转到外部的函数对应的got表的代码段，而在got表中记录了外部函数的地址。在程序运行时，动态链接器会根据函数的符号信息，将函数的真实地址回写到got表中，从而实现函数的动态调用。而plthook技术其实就是修改got表中记录的真实地址，改为我们的自定义方法的地址。而在自定义方法中，通过调用原函数的地址来实现原函数的调用。 下面我们通过bhook框架来实现外部函数调用的拦截：\n1 2 3 4 5 6 7 8 9 10 11 extern \u0026#34;C\u0026#34; JNIEXPORT void JNICALL Java_com_example_nativelib_MainActivity_loadAddress(JNIEnv *env, jobject thiz) { bytehook_stub_t stub = bytehook_hook_single( \u0026#34;libnativelib.so\u0026#34;, nullptr, \u0026#34;malloc\u0026#34;, reinterpret_cast\u0026lt;void *\u0026gt;(\u0026amp;malloc_hook_by_plt), hacker_bytehook_strlen_hooked, nullptr); } 这里我定义了一个jni的方法，它的调用需要在上面jni方法Java_com_example_nativelib_MainActivity_MallocLeak之前。因为只有先监听，后面调用的时候才能监听到。bytehook_hook_single方法是bhook框架中的方法，它是bhook框架中的方法，用于hook进程中的单个调用者动态库的某个方法。第一个参数指定作用于在哪个so上，此处的malloc方法拦截是在libnativelib.so库中的Java_com_example_nativelib_MainActivity_MallocLeak方法调用的。第二个参数是被调用so的名字，此处我传的是nullptr，其实它是lic.so的方法，此处如果有多个库中出现了malloc方法，该参数需要制定。第三个参数是方法名。第四个参数是被hook时候的方法指针，此处要求类型是void *，在c++/c中表示指向未知类型的指针，也叫通用指针。而reinterpret_cast是c++/c中的强转。 下面来了解下c++中的几种强转：\nstatic_cast(expr) 做类型之间的转换，作用于编译期检查，运行时不检查。比如基础类型之间转换（int-\u0026gt;double） 有继承关系的指针或引用之间的转换(向上转型安全，向下转型需自己保证安全) void* ↔ 具体类型 举例说明： 基本类型转换 1 2 3 int i = 10; double d = static_cast\u0026lt;double\u0026gt;(i);//int-\u0026gt;double类型 cout \u0026lt;\u0026lt;\u0026#34;数值是:\u0026#34;\u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; void*转成具体类型 1 2 3 4 int i = 10; void *p = \u0026amp;i;//将i的地址给到指针p int *pi = static_cast\u0026lt;int*\u0026gt;(p);//将p的指针强转成int类型的指针 cout \u0026lt;\u0026lt; \u0026#34;pi指针存储的值是 = \u0026#34; \u0026lt;\u0026lt; *pi \u0026lt;\u0026lt; endl;//取值操作 那什么是编译期检查的类型呢？我们通过下面一个例子来说明: 1 2 class Base{}; class Derived : public Base{}; 这里我定义了一个父类和一个子类，然后通过static_cast能将子类类型指向父类类型： 1 2 Derived* derived = new Derived(); Base* base = static_cast\u0026lt;Base*\u0026gt;(derived); 这里直接能将子类指针指向父类指针。下面举个不能被指向的例子： 1 2 3 4 struct A {}; struct B {}; A* a = new A(); B* b = static_cast\u0026lt;B*\u0026gt;(a); // ❌ 报错：没有 A* -\u0026gt; B* 的转换规则 dynamic_cast(expr) 运行时类型安全转换，主要用于多态类（含有 虚函数表 的类）。向下转换时，会在运行时检查，失败则返回nullptr（指针情况），或抛出std::bad_cast（引用情况）。 1 2 3 4 5 6 7 8 class Base{virtual void fun(){}}; class Derived : public Base{}; Base* base = new Derived(); Derived* derived = dynamic_cast\u0026lt;Derived*\u0026gt;(base); std::cout \u0026lt;\u0026lt;\u0026#34;转换后的结果：\u0026#34;\u0026lt;\u0026lt; derived \u0026lt;\u0026lt;std::endl; if (derived) { std::cout \u0026lt;\u0026lt; \u0026#34;转换成功\u0026#34;\u0026lt;\u0026lt;std::endl; } 上面可以通过dynamic_cast转换将子类类型的指针转换成父类类型的指针。上面如果Base中没有定义虚函数，则在dynamic_cast编译期就会提示错误。在上面例子中derived不会为空，什么叫运行时安全转换呢？下面通过一个不是继承关系来说明问题： 1 2 3 4 5 6 7 8 class Base{virtual void fun(){}}; class Derived {}; Base* base = new Base(); Derived* derived = dynamic_cast\u0026lt;Derived*\u0026gt;(base); std::cout \u0026lt;\u0026lt;\u0026#34;转换后的结果：\u0026#34;\u0026lt;\u0026lt; derived \u0026lt;\u0026lt;std::endl; if (derived == nullptr) { std::cout \u0026lt;\u0026lt; \u0026#34;转换后为空\u0026#34;\u0026lt;\u0026lt;std::endl; } 在上面代码中，Derived不是继承自Base，并且在用dynamic_cast时候，编译期不会报错，如果用上面的static_cast就会报错了。但是在运行期得到的结果就是nullptr。 const_cast(expr) 去除或添加 const、volatile 修饰符 唯一能去掉 const 的 cast 不能用于不同类型之间的转换 如果原对象本身是 const 的，去掉 const 后修改会导致 未定义行为。 1 2 3 4 5 const int a = 10; int* p = const_cast\u0026lt;int*\u0026gt;(\u0026amp;a); *p = 20; std::cout \u0026lt;\u0026lt; \u0026#34;a=\u0026#34;\u0026lt;\u0026lt; a \u0026lt;\u0026lt;std::endl;//a=10 std::cout \u0026lt;\u0026lt; \u0026#34;p=\u0026#34;\u0026lt;\u0026lt; *p \u0026lt;\u0026lt;std::endl;//p=20 此处定义了const a等于10，在后面虽然把p指针指向a，改变p的值后，对a没有影响。 reinterpret_cast(expr) 底层二进制级别的重新解释。 不安全，不检查类型。 常用于指针之间的的转换、指针和整数之间的转换。 只是简单地“解释”比特位，没有语义上的转换。 举个指针转化成long类型的例子： 1 2 3 4 5 6 int i =10; int* p2 = \u0026amp;i; std::cout \u0026lt;\u0026lt; \u0026#34;p2=\u0026#34;\u0026lt;\u0026lt; *p2 \u0026lt;\u0026lt;std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;p2的地址值=\u0026#34;\u0026lt;\u0026lt; p2 \u0026lt;\u0026lt;std::endl; long s = reinterpret_cast\u0026lt;long\u0026gt;(p2); std::cout \u0026lt;\u0026lt; \u0026#34;s的值是:\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt;std::endl; p2指向了变量i的地址，接着使用reinterpret_cast将p2这个指针转化成long类型。 再来举一个指针变成另外一个指针的例子： 1 2 3 4 Base* base2 = new Base(); std::cout \u0026lt;\u0026lt; \u0026#34;base2:\u0026#34;\u0026lt;\u0026lt;base2\u0026lt;\u0026lt;std::endl; Derived* derived2 = reinterpret_cast\u0026lt;Derived*\u0026gt;(base2); std::cout \u0026lt;\u0026lt; \u0026#34;derived2:\u0026#34;\u0026lt;\u0026lt; derived2 \u0026lt;\u0026lt;std::endl; 上面使用reinterpret_cast能直接将base2的指针直接强转到derived2上，从结果来看，base2和derived2的指针值都是一样的，在上面讲的const_cast它是得到一个默认指针，也就是nullptr。 回到上面jni的拦截方法里面，它是将malloc_hook_by_plt这个函数通过取址符(\u0026amp;)来获取到函数的地址，接着通过reinterpret_cast强转操作符转化成void*类型的指针，它是c/c++中的任何指针类型。我们来看下malloc_hook_by_plt函数：\n1 2 3 4 5 6 7 8 9 10 size_t malloc_hook_by_plt(size_t len) { __android_log_print(ANDROID_LOG_DEBUG, \u0026#34;hookMallocByPLTHook\u0026#34;, \u0026#34;origin malloc size:%d\u0026#34;, len); if (len \u0026gt; 20 * 1024 * 1024) { __android_log_print(ANDROID_LOG_DEBUG, \u0026#34;hookMallocByPLTHook\u0026#34;, \u0026#34;do somethings\u0026#34;); //堆栈打印 // printNativeStack(); } //调用原来的函数 return hacker_orig_strlen(len); } 首先该函数的返回值类型是size_t，它表示的是无符号的int值，在32位机器上，它是4字节，64位机器上，它是8字节，一般用来表示地址值。接着函数的参数也是一个size_t值，它是和我们的malloc函数的参数对应，表示申请的内存大小。接着我们输出android的log，如果申请的内存大于20M的时候，也输出android的log，最后返回原来函数的地址值。我们看下hacker_orig_strlen函数，它是一个函数指针类型：\n1 2 typedef size_t (*hacker_strlen_t)(const size_t); static hacker_strlen_t hacker_orig_strlen = nullptr; 此处使用typedef是给当前函数指针起一个别名，名字叫hacker_strlen_t，函数的返回值是size_t，第二行定义了一个hacker_strlen_t类型的函数。此处为什么要这样定义函数指针呢？我们回到上面的调用就知道了，malloc_hook_by_plt方法需要一个size_t用来表示new_func的地址，参数和malloc方法的参数一致。这个在hock的时候需要知道申请的内存大小，hacker_orig_strlen函数指针是什么时候初始化的呢？它是在hacker_bytehook_strlen_hooked方法中被赋值的：\n1 2 3 4 5 6 7 8 9 static void hacker_bytehook_strlen_hooked(bytehook_stub_t task_stub, int status_code, const char *caller_path_name, const char *sym_name, void *new_func, void *prev_func, void *arg) { hacker_orig_strlen = (hacker_strlen_t) prev_func;//此处当hook的之后，将原始函数的指针赋值给hacker_orig_strlen变量，这是c风格的强制转换，不太推荐这种转换，因为这种无法区分用途，不安全，不明确，可能绕过类型检查 //caller_path_name此处会输出libnativelib.so的完整路径 __android_log_print(ANDROID_LOG_DEBUG, \u0026#34;hookMallocByPLTHook\u0026#34;, \u0026#34;caller_path_name:%s\u0026#34;, caller_path_name); //sym_name此处会输出malloc函数名字 __android_log_print(ANDROID_LOG_DEBUG, \u0026#34;hookMallocByPLTHook\u0026#34;, \u0026#34;sym_name:%s\u0026#34;, sym_name); } 它是bhook中bytehook_hook_single方法的hooked参数被调用的，它表示plthook过程中被hooked时候调用的方法，下面来分析下该方法：\n该函数的定义是用于hook成功后保存原始函数指针 static表示该函数只能在当前源文件中可见（局部链接） task_stub：hook操作的句柄，bhook用来标识一次hook任务 status_code：状态码，表示hook是否成功，在bytehook.h中定义了BYTEHOOK_STATUS_CODE_OK，表示hook成功 caller_path_name：这是一个指向常量字符的指针，在c和c++中，字符串不是一个单独的类型，而是由字符数组实现的，而指针可以用来指向一串字符的指针，所以次数用char *，前面加const表示该函数中不能修改该字符串，调用者模块的路径,是谁调用了被hook的函数 sym_name：被hook的符号名 new_func：新的函数地址，此处使用void *，表示的是泛型指针，表示任意类型的指针，即一个没有具体类型的内存地址，hook框架不知道你hook函数到底是什么签名，所以只返回一个地址，让你自行转换为对应函数指针类型 prev_func：被替换掉的原函数地址（可通过它调用原函数） arg：你 hook 时传入的自定义参数，可传 hook 时的上下文等 在函数里面将prev_func的void*类型指针直接强转成hacker_strlen_t函数指针，其实这种小括号的强转不够规范，应该用上面的reinterpret_cast来进行指针类型的强转。最后输出了android log，整个过程就结束了。\n","date":"2025-08-06T19:20:53+08:00","permalink":"http://xiangcman.xyz/p/%E4%BB%8Eplthook%E5%BC%80%E5%A7%8B%E8%AE%A4%E8%AF%86jni%E5%BC%80%E5%8F%91/","title":"从plthook开始认识jni开发"},{"content":"前面介绍过如何使用perfetto跟踪app的问题，本节主要围绕app的主线程卡顿问题，以及熟悉应用界面是如何被渲染到屏幕上的。还是和往常一样，先看下我配置的跟踪文件config.pbtx:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 buffers: { size_kb: 131072 fill_policy: DISCARD } buffers: { size_kb: 2048 fill_policy: DISCARD } data_sources: { config { name: \u0026#34;android.packages_list\u0026#34; target_buffer: 1 } } data_sources: { config { name: \u0026#34;android.log\u0026#34; android_log_config { log_ids: LID_EVENTS log_ids: LID_CRASH log_ids: LID_KERNEL log_ids: LID_DEFAULT log_ids: LID_RADIO log_ids: LID_SECURITY log_ids: LID_STATS log_ids: LID_SYSTEM } } } data_sources: { config { name: \u0026#34;android.surfaceflinger.frametimeline\u0026#34; } } data_sources: { config { name: \u0026#34;linux.ftrace\u0026#34; ftrace_config { ftrace_events: \u0026#34;sched/sched_switch\u0026#34; ftrace_events: \u0026#34;sched/sched_wakeup\u0026#34; ftrace_events: \u0026#34;sched/sched_blocked_reason\u0026#34; ftrace_events: \u0026#34;power/suspend_resume\u0026#34; ftrace_events: \u0026#34;sched/sched_process_exit\u0026#34; ftrace_events: \u0026#34;sched/sched_process_free\u0026#34; ftrace_events: \u0026#34;task/task_newtask\u0026#34; ftrace_events: \u0026#34;task/task_rename\u0026#34; ftrace_events: \u0026#34;ftrace/print\u0026#34; ftrace_events: \u0026#34;mutex/lock_contention\u0026#34; ftrace_events: \u0026#34;mutex/lock_acquired\u0026#34; ftrace_events: \u0026#34;mutex/lock_release\u0026#34; ftrace_events: \u0026#34;synchronization/lock_acquire\u0026#34; ftrace_events: \u0026#34;synchronization/lock_release\u0026#34; ftrace_events: \u0026#34;sync/sync_timeline_wait\u0026#34; ftrace_events: \u0026#34;mm_event/page_fault_user\u0026#34; ftrace_events: \u0026#34;io_uring/io_uring_cmd\u0026#34; atrace_categories: \u0026#34;am\u0026#34; atrace_categories: \u0026#34;adb\u0026#34; atrace_categories: \u0026#34;aidl\u0026#34; atrace_categories: \u0026#34;dalvik\u0026#34; atrace_categories: \u0026#34;audio\u0026#34; atrace_categories: \u0026#34;binder_lock\u0026#34; atrace_categories: \u0026#34;binder_driver\u0026#34; atrace_categories: \u0026#34;bionic\u0026#34; atrace_categories: \u0026#34;camera\u0026#34; atrace_categories: \u0026#34;database\u0026#34; atrace_categories: \u0026#34;gfx\u0026#34; atrace_categories: \u0026#34;hal\u0026#34; atrace_categories: \u0026#34;input\u0026#34; atrace_categories: \u0026#34;network\u0026#34; atrace_categories: \u0026#34;nnapi\u0026#34; atrace_categories: \u0026#34;pm\u0026#34; atrace_categories: \u0026#34;power\u0026#34; atrace_categories: \u0026#34;rs\u0026#34; atrace_categories: \u0026#34;res\u0026#34; atrace_categories: \u0026#34;rro\u0026#34; atrace_categories: \u0026#34;sm\u0026#34; atrace_categories: \u0026#34;ss\u0026#34; atrace_categories: \u0026#34;vibrator\u0026#34; atrace_categories: \u0026#34;video\u0026#34; atrace_categories: \u0026#34;view\u0026#34; atrace_categories: \u0026#34;webview\u0026#34; atrace_categories: \u0026#34;wm\u0026#34; atrace_apps: \u0026#34;应用的包名\u0026#34; } } } data_sources: { config { name: \u0026#34;linux.process_stats\u0026#34; target_buffer: 1 process_stats_config { scan_all_processes_on_start: true } } } duration_ms: 10000 上面配置了主缓冲区和次缓冲区的大小，时长，ftrace等信息。接着通过如下命令进行跟踪：\n1 ./record_android_trace -c config.pbtx -o trace_file.perfetto-trace 然后操作app后，过了10s自动打开该跟踪文件。我们打开\n","date":"2025-06-24T00:00:00Z","permalink":"http://xiangcman.xyz/p/%E4%BD%BF%E7%94%A8perfetto%E8%AF%86%E5%88%AB%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98/","title":"使用perfetto识别卡顿问题"},{"content":"目的 该篇主要介绍如果在Android下面启动perfetto的跟踪，方便后面能快速使用perfetto工具。\n启动跟踪服务 启动跟踪服务在Android11(R)之后是默认开启的，在Android9(P)和Android10(Q)上，需要执行以下操作，确保已启用跟踪服务：\n1 2 # Needed only on Android 9 (P) and 10 (Q) on non-Pixel phones. adb shell setprop persist.traced.enable 1 如果是在Android9之前的版本，能通过Perfetto 脚本捕获跟踪记录record_android_trace。\n记录跟踪 命令行跟踪 record_android_trace脚本跟踪 首先将record_android_trace脚本下载下来： 1 2 3 4 //下载脚本 curl -O https://raw.githubusercontent.com/google/perfetto/main/tools/record_android_trace //给脚本分配执行权限 chmod u+x record_android_trace 开始跟踪 1 2 ./record_android_trace -o trace_file.perfetto-trace -t 30s -b 64mb \\ sched freq idle am wm gfx view binder_driver hal dalvik camera input res memory 命令解释： 上面的脚本中是通过record_android_trace这个脚本收集，接着-o后面跟的是输出的perfetto能识别的文件，-t是跟踪多久的时间，-b后面是最大的文件大小，最后是一堆的category分类。收集完后，它会自动在ui.perfetto.dev上打开该trace文件。上面拼接的分类有如下解释： sched：进程调度(Scheduler) freq：CPU 频率变化(CPU Frequency) idle：CPU 空闲状态(CPU Idle) am：应用生命周期、进程调度等(Activity Manager) wm：窗口管理、Activity 启动等(Window Manager) gfx:图形渲染、SurfaceFlinger、GPU 活动等(Graphics) view:视图绘制、布局、测量等(View System) binder_driver：进程间通信（Binder IPC） hal：硬件抽象层（Hardware Abstraction Layer） dalvik：ART 运行时、GC、JNI 调用等（ART Runtime） camera：摄像头操作（Camera） input：输入事件处理（Input） res：资源加载（Resource） memory：内存分配和使用（Memory） 想获取更多的类别，可以通过如下的指令获取：\n1 2 adb shell atrace --list_categories atrace \u0026ndash;list_categories 列出的主要是 Atrace 类别。这些类别是 Perfetto 中最常用的类别之一。\n一些厂商可能会添加自己的自定义类别，这些也会在这里列出。\n使用设备上的 /system/bin/perfetto 命令 首先我得设备是Android13的，所以具备通过adb的命令来抓取跟踪文件，需要在开发者选项中选择调试应用为你要调试的应用。\n接着通过如下命令来跟踪：\n1 2 adb shell perfetto -o /data/misc/perfetto-traces/trace_file.perfetto-trace -t 20s \\ sched freq idle am wm gfx view binder_driver hal dalvik camera input res memory 此处的命令和上面record_android_trace脚本跟踪基本一致的，跟踪完后，导出该文件到电脑上：\n1 adb pull /data/misc/perfetto-traces/trace_file.perfetto-trace ~/trace.perfetto-trace 最后将导出的trace文件拖拽到ui.perfetto.dev中。\n通过配置文件来启动跟踪 首先来看下官网给的事例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 cat\u0026lt;\u0026lt;EOF\u0026gt;config.pbtx duration_ms: 10000 buffers: { size_kb: 8960 fill_policy: DISCARD } buffers: { size_kb: 1280 fill_policy: DISCARD } data_sources: { config { name: \u0026#34;linux.ftrace\u0026#34; ftrace_config { ftrace_events: \u0026#34;sched/sched_switch\u0026#34; ftrace_events: \u0026#34;power/suspend_resume\u0026#34; ftrace_events: \u0026#34;sched/sched_process_exit\u0026#34; ftrace_events: \u0026#34;sched/sched_process_free\u0026#34; ftrace_events: \u0026#34;task/task_newtask\u0026#34; ftrace_events: \u0026#34;task/task_rename\u0026#34; ftrace_events: \u0026#34;ftrace/print\u0026#34; atrace_categories: \u0026#34;gfx\u0026#34; atrace_categories: \u0026#34;view\u0026#34; atrace_categories: \u0026#34;webview\u0026#34; atrace_categories: \u0026#34;camera\u0026#34; atrace_categories: \u0026#34;dalvik\u0026#34; atrace_categories: \u0026#34;power\u0026#34; } } } data_sources: { config { name: \u0026#34;linux.process_stats\u0026#34; target_buffer: 1 process_stats_config { scan_all_processes_on_start: true } } } EOF ./record_android_trace -c config.pbtx -o trace_file.perfetto-trace 在EOF之前的命令会把配置写到config.pbtx文件中，在EOF之后，和上面的一样，只不过区别是增加了-c后面跟配置文件的路径，该方式也会自动在ui.perfetto.dev上打开该trace。\n下面再来解释下上面的配置文件都配置了些什么：\nduration_ms: 10000: 跟踪将持续 10 秒 buffers: 定义了两个缓冲区。 size_kb: 8960, fill_policy: DISCARD(主缓冲区，其中填充策略是丢弃模式) size_kb: 1280, fill_policy: DISCARD(次缓冲区，用来存储其它少量的数据源) data_sources linux.ftrace：ftrace和atrace事件的跟踪 ftrace相关的跟踪 sched/sched_switch：这是显示 CPU 调度和构建线程 CPU 轨道的最关键事件。 有了这个事件，Perfetto UI 就能知道哪些线程在何时运行在哪个 CPU 上。 power/suspend_resume：与电源管理相关。 sched/sched_process_exit, sched/sched_process_free, task/task_newtask, task/task_rename：这些事件有助于 Perfetto 跟踪进程和线程的创建、销毁和重命名，从而在 UI 中正确地显示它们的生命周期和名称。 ftrace/print: 收集 printk 等内核打印信息，在某些调试场景有用。 atrace相关的跟踪 gfx，view，webview：图形和ui渲染相关的atrace。 camera：摄像头相关的atrace dalvik：ART运行时相关的atrace。 power：电源相关的atrace。 linux.process_stats：所有进程的状态跟踪，如果没有该配置，生成的perfetto跟踪信息中，都不会显示具体的进程名字，如果想知道 target_buffer: 1: 指示此数据源将数据写入第二个（较小的）缓冲区。 process_stats_config： scan_all_processes_on_start: true：这将会在跟踪开始时扫描所有进程信息，确保 Perfetto 了解所有活动的进程和线程的初始状态。 再来看一个之前通过perfetto可视化页面获取的一个配置： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 buffers: { size_kb: 63488 fill_policy: DISCARD } buffers: { size_kb: 2048 fill_policy: DISCARD } data_sources: { config { name: \u0026#34;android.packages_list\u0026#34; target_buffer: 1 } } data_sources: { config { name: \u0026#34;android.log\u0026#34; android_log_config { log_ids: LID_EVENTS log_ids: LID_CRASH log_ids: LID_KERNEL log_ids: LID_DEFAULT log_ids: LID_RADIO log_ids: LID_SECURITY log_ids: LID_STATS log_ids: LID_SYSTEM } } } data_sources: { config { name: \u0026#34;android.surfaceflinger.frametimeline\u0026#34; } } data_sources: { config { name: \u0026#34;linux.ftrace\u0026#34; ftrace_config { ftrace_events: \u0026#34;ftrace/print\u0026#34; atrace_categories: \u0026#34;am\u0026#34; atrace_categories: \u0026#34;adb\u0026#34; atrace_categories: \u0026#34;aidl\u0026#34; atrace_categories: \u0026#34;dalvik\u0026#34; atrace_categories: \u0026#34;audio\u0026#34; atrace_categories: \u0026#34;binder_lock\u0026#34; atrace_categories: \u0026#34;binder_driver\u0026#34; atrace_categories: \u0026#34;bionic\u0026#34; atrace_categories: \u0026#34;camera\u0026#34; atrace_categories: \u0026#34;database\u0026#34; atrace_categories: \u0026#34;gfx\u0026#34; atrace_categories: \u0026#34;hal\u0026#34; atrace_categories: \u0026#34;input\u0026#34; atrace_categories: \u0026#34;network\u0026#34; atrace_categories: \u0026#34;nnapi\u0026#34; atrace_categories: \u0026#34;pm\u0026#34; atrace_categories: \u0026#34;power\u0026#34; atrace_categories: \u0026#34;rs\u0026#34; atrace_categories: \u0026#34;res\u0026#34; atrace_categories: \u0026#34;rro\u0026#34; atrace_categories: \u0026#34;sm\u0026#34; atrace_categories: \u0026#34;ss\u0026#34; atrace_categories: \u0026#34;vibrator\u0026#34; atrace_categories: \u0026#34;video\u0026#34; atrace_categories: \u0026#34;view\u0026#34; atrace_categories: \u0026#34;webview\u0026#34; atrace_categories: \u0026#34;wm\u0026#34; atrace_apps: \u0026#34;com.example.coroutinescopedemo\u0026#34; } } } duration_ms: 10000 主要来说下和上面官网的配置区别。主要在data_sources部分：\nandroid.packages_list:收集设备上安装的应用程序包的列表。这对于在 Perfetto UI 中将跟踪事件与特定的应用程序关联起来非常有用。 android.log:收集android logcat日志。这对于调试应用程序行为、查看系统事件、崩溃信息等非常重要。 android_log_config: 详细配置了要收集的日志缓冲区： LID_EVENTS: 事件日志（二进制格式的系统事件）。 LID_CRASH: 崩溃日志。 LID_KERNEL: 内核日志。 LID_DEFAULT: 主日志缓冲区（应用程序和大部分系统日志）。 LID_RADIO: 无线电/电话相关的日志。 LID_SECURITY: 安全相关的日志。 LID_STATS: 统计信息日志。 LID_SYSTEM: 系统日志。 这几乎涵盖了所有主要的 Logcat 日志缓冲区，会收集大量的日志信息。 android.surfaceflinger.frametimeline：收集 SurfaceFlinger 的帧时间线数据。这对于分析 UI 渲染性能、卡顿、Jank 等问题非常关键。它能显示帧的生命周期，从应用提交到最终显示在屏幕上的各个阶段。 linux.ftrace：和上面对比，增加了atrace_apps信息，这是非常重要的。它会启用针对特定应用程序 com.example.coroutinescopedemo 的应用层自定义 app 类别跟踪。如果该应用使用了 android.os.Trace 或类似的 Tracing SDK 来添加自定义事件，那么这些事件将被捕获。 关于更多的配置可以参考repo上的test/configs\n上面是通过record_android_trace脚本，然后配置config.pbtx来跟踪的，我们也可以不借助record_android_trace脚本，直接使用设备上的命令：\n1 cat config.pbtx | adb shell perfetto -c - --txt -o /data/misc/perfetto-traces/trace.perfetto-trace 或者先把config.pbtx给推送到设备上，然后再跟踪：\n1 2 adb push config.pbtx /data/local/tmp/config.pbtx adb shell \u0026#39;cat /data/local/tmp/config.pbtx | perfetto --txt -c - -o /data/misc/perfetto-traces/trace.perfetto-trace\u0026#39; 通过 Perfetto 界面记录跟踪 点开ui.perfetto,dev，然后点击左侧菜单的Record new trace，然后连接上设备：\n来到Buffers and duration，这里默认的缓冲区是64M，duration是10s，我们可以选择不动：\n接着配置前面说的ftrace和atrace信息，它是在Android apps \u0026amp; svcs的tab中，但是此处我只看到atrace的配置：\n可以看到上面我把所有的atrace的分类都给勾上了。在最后一栏中我填上了进程的名字，这个跟上面config.pbtx的atrace_apps配置是一样的，用来跟踪自定义的trace信息。\n接着来看下android log的数据源配置，它也是在Android apps \u0026amp; svcs的tab中：\n可以看到我这里把所有的log级别都给勾上了。\n在Event log下面还有个Frame timeline的跟踪，它是我们卡顿分析中很重要的一项，它会把每一帧的期望时间和实际时间给列出来，方便分析是否是卡顿帧：\n它会在config.pbtx中生成如下：\n1 2 3 4 5 data_sources: { config { name: \u0026#34;android.surfaceflinger.frametimeline\u0026#34; } } 这个在前面的config中有介绍。所有的配置完事后，可以在Cmdline instructions的tab中浏览生成的配置信息。最终生成的也是前面介绍的config.pbtx: 通用操作 导航操作 w：放大操作\ns：缩小操作\na：轨道左移\nd：轨道右移\n鼠标操作 鼠标左键点击：选中区域或片段\ncontrol+滚轮：放大或缩小\n鼠标左键长按+拖拽：选中区域\nshift+左键长按+拖拽：轨道左移或右移\n命令行操作 在头部的搜索框中输入「\u0026gt;」,进入快捷操作，点击delete退出快捷操作\n在头部的搜索框中输入「:」，进入sql模式，点击delete退出sql模式\nenter：在上面输入完sql后，就执行sql\ncontrol+enter：在上面输入完sql后，就执行sql，每次的sql都不会被覆盖\nsql页面操作 control+enter：执行sql，也可以通过鼠标选中某段sql来执行结果\n快捷键操作 shift+m：基于当前选中的区域或片段添加一个新的笔记片段\nR：对当前选中的区域或片段转为区域选择\nesc：取消当前选择的区域或片段\ncommand+p：通过名字找轨道\nf:将画面聚焦到当前选中的区域或片段\n回车：对页面上的搜索结果（command+f）进行定位到下一个\nshift+回车：对页面上的搜索结果（command+f）进行定位到上一个\ncommand+shift+p:打开快捷操作，跟上面在搜索框中输入「\u0026gt;」一样的效果\ncommand+o：打开trace文件\ncommand+t:置顶轨道\ndelete:移除掉选中的笔记片段\n/:聚焦到搜索框\n.:定位到下一个轨道的片段\n,:定位到上一个轨道的片段\nm：根据当前选中的区域或片段，添加临时的笔记片段，和上面的shift+m的区别是，此处如果再添加另外的笔记片段的时候，此时这种添加的笔记片段会被覆盖\nq：切换底部的面板\ncommand+b:切换左边的菜单面板\ncommand+option+s：多个trace文件在浏览器中打开的时候，能同步多个trace的操作，方便对比\n常见sql 模糊匹配查询：like、glob、regexp like:一般跟%和_来搭配使用，是不确定数量字符个数，_是匹配单个字符，并且like前面可以加not取反，比如我想查询所有fragment的onCreateView的耗时：\n1 SELECT * FROM slice WHERE name LIKE \u0026#39;%onCreateView%\u0026#39;; 在like中是不区分大小写。 glob:一般和*、?、[\u0026hellip;]搭配使用，*表示任意长度的字符串、?表示单个字符、[\u0026hellip;]表示字符集。它是要区分大小写。并且前面也可以用not取反。\n1 2 3 4 SELECT * FROM slice WHERE name GLOB \u0026#39;*interesting_slice*\u0026#39; LIMIT 10; regexp:是一种以正则来匹配的关键字，下面看一个统计slice的耗时sql：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 SELECT name, COUNT(dur) AS count_slice, -- Convert nanoseconds to milliseconds AVG(dur) / 1000000 AS avg_dur_ms, CAST(MAX(dur) AS DOUBLE) / 1000000 AS max_dur_ms, CAST(MIN(dur) AS DOUBLE) / 1000000 AS min_dur_ms, PERCENTILE(dur,50) / 1000000 AS P50_dur_ms, PERCENTILE(dur,90) / 1000000 AS P90_dur_ms, PERCENTILE(dur,99) / 1000000 AS P99_dur_ms FROM slice WHERE name REGEXP \u0026#39;.*interesting_slice.*\u0026#39; GROUP BY name ORDER BY count_slice DESC LIMIT 10; 上面的sql通过regexp正则来匹配到感兴趣的slice，并且开头和结尾都是.*来匹配，该.表示匹配单个字符，而*则是匹配前一个字符是0次或多次，所以表示前面interesting_slice前面有任意个数的字符，interesting_slice后面有任意个数的字符。并且按照名字分组，列明有名字、count_slice表示该slice出现的次数、avg_dur_ms该slice的平均耗时，单位是ms、max_dur_ms最大耗时、min_dur_ms最小耗时、P50_dur_ms是p50耗时、P90_dur_ms是p90的耗时、P99_dur_ms是p99的耗时，最后按照出现次数降序排列，查询前10条。\n联表查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 SELECT s.id AS id, s.ts AS ts, s.track_id AS track_id, s.slice_id AS slice_id, s.dur AS dur, s.name AS slice, p.name AS process, t.name AS thread FROM slice s JOIN thread_track tt ON s.track_id = tt.id JOIN thread t on tt.utid = t.utid JOIN process p on t.upid = p.upid WHERE s.name LIKE \u0026#39;%interesting_slice%\u0026#39; -- Only look for slices in your app\u0026#39;s process AND p.name = \u0026#39;com.example.myapp\u0026#39; -- Only look for slices on your app\u0026#39;s main thread AND t.is_main_thread ORDER BY dur DESC; 上面thread_track（线程轨道表）的id和slice的trace_id进行关联，thread（线程表）的utid（线程唯一id）和thread_track的utid进行关联，progress（进程表）的upid（进程唯一id）和thread的upid进行关联。\n通过sql查找睡眠中断的原因 睡眠中断是性能优化中一个阻塞线程的问题，比如在等待io、锁等都是睡眠中断问题，即调用在不可中断条件下阻塞的内核函数。我们可以通过配置perfetto如下来找出睡眠中断的原因：\n1 2 3 4 5 6 7 8 9 data_sources: { config { name: \u0026#34;linux.ftrace\u0026#34; target_buffer: 0 ftrace_config { ftrace_events: \u0026#34;sched/sched_blocked_reason\u0026#34; } } } 然后通过sql查找中断的原因：\n1 2 3 4 5 6 7 SELECT blocked_function, COUNT(thread_state.id), SUM(dur) FROM thread_state JOIN thread USING (utid) JOIN process USING (upid) WHERE process.name = \u0026#34;com.google.android.youtube\u0026#34; GROUP BY blocked_function ORDER BY SUM(dur) DESC; blocked_function:它是来自于thread_state表，它是线程状态表，表示线程在某个时刻阻塞时，对应的函数。 COUNT(thread_state.id)：统计该阻塞问题出现的次数 SUM(dur):统计这种阻塞出现的总时长 注意：上面通过join thread using（utid）是通过thread_state中的utid和thread表中的utid进行关联，将thread中的upid和process中的upid进行关联，通过threa表进行中间过渡。\n参考 https://perfetto.dev/docs/quickstart/android-tracing https://perfetto.dev/docs/concepts/config https://perfetto.dev/docs/getting-started/android-trace-analysis ","date":"2025-06-18T00:00:00Z","permalink":"http://xiangcman.xyz/p/android%E4%B8%8A%E5%90%AF%E5%8A%A8perfetto%E8%B7%9F%E8%B8%AA/","title":"Android上启动perfetto跟踪"},{"content":"Android中卡顿治理主要集中在recyclerView滑动列表时候有卡顿，我们结合android studio中profiler的systemTrace工具来查看卡顿情况，我目前的Android Studio已更新到Meerkat Feature Drop | 2024.3.2 Patch 1版本，下来来看看如何通过该工具来定位到具体的卡顿。\n首先Android Studio中System Trace工具是基于perfetto来进行定位，所以需要有一定的perfetto经验才能使用该功能，perfetto能通过内核、系统组件、本地内存、cpu等多方面进行收集数据，而我们的卡顿一般是监控应用的主线程绘制阶段的数据，而android代码中已经为主线程绘制阶段添加了各种tag，通过该tag能知道是什么组件的绘制阶段发生了卡顿。\n首先我的手机是Android13的版本，在卡顿检测官网中介绍了Android12以上、Android11、Android10以下的区别，这里我就以Android13来讲解如何识别卡顿。\n在官网中介绍有两种模式，一种是可分析应用，一种是可调试应用，新版android studio中的profiler中system trace要求是可分析的(profileable)应用，在启动应用时候，点击menu toolbar的更多操作，然后点击，便可进入到profileable模式，也可以将变体切换为release模式，在release变体下，在清单文件加上如下配置：\n1 \u0026lt;profileable android:shell=\u0026#34;true\u0026#34; /\u0026gt; 配置完后，接着就是选择相应的应用，然后点击System Trace选项进行监控应用。比如我在RecyclerView的列表adapter中onBindViewHolder进行Thread.sleep(50)，然后观察生成的trace文件： 整体上分为Janky frames、Threads、Analysis几个区域，Janky frames默认展示的是卡顿帧，我们也可以勾选All Frames，Threads部分展示的时候所有线程，比如app的主线程，RenderThread渲染线程等。Analysis区域展示的是某块的跟踪信息。\n卡顿帧：它是我们分析卡顿最直接的图形，我们首先选中某一个卡顿帧，然后该帧会出现两个颜色，左边的深红色表示一针的期望时间，而右边的暗红色表示该帧延迟了多久。我们可以看到右边Analysis区域标明了Jank type是Deadline missed（延迟帧），Layer name表明是哪个activity，Expected duration表示期望时间，Actual duration表示实际执行时间。events associated with frame展示的是该帧从主线程到RenderThread到gpu到SurfaceFlinger的关键事件。可以通过该区域分析该帧是应用层绘制耗时多，还是渲染线程或者是gpu等阶段耗时久。下面还会展示Main thread states和RenderThread states，分别记录了现成的状态、每个状态的耗时、以及每个状态的占比，Occurrences表示的是当前线程在该帧的生命周期内，在该状态下的次数。 从上面截图中可以看到在该帧中，主线程的sleeping状态占比是最高的。\n回到左边的Janky frames面板，再回到刚才那一帧，然后按m键会自动放大该帧的视图，在主线程视图中查看跟踪事件的tag。这里介绍系统system trace中常见的一帧的tag：\ntag名字 描述 Choreographer#doFrame *** 每一帧的父事件，其中后面的数字是vsync input 每一帧中执行input事件 animation 每一帧执行animation事件 RV Scroll recyclerview滑动事件 选中某一帧的Choreographer#doFrame后，在右侧的Analysis面板会看到该帧的相关信息。分为Summary、Top Down、Flame Chart、Bottom Up、Events几个tab。\nSummary\nTime Range：该帧的时间 Data Type：该帧的事件类型 start time：事件在trace中的开始时间 Name：事件的名称 Wall Duration：事件从开始到结束所经过的实际时间，这包括线程处于Running、Runnable、Waiting、Sleeping等所有状态的时间 Wall Self time：该时间表示不算子事件的时间，只算自己等待其他操作的时间 cpu duration：事件在cpu上执行的实际时间，包括子事件的执行时间。但是这只包括线程处于running状态下的时间，也就是它正在主动使用cpu进行计算的时间 cpu self time：和上面cpu duration唯一区别是刨除了子事件的执行时间，也就是自己占用cpu处于running状态下的时间 All Occurrences：这里是统计了所有相同名字的事件次数、平均事件、最大事件、最小事件、所有事件的标准差，标准差衡量了数据相对于平均值的离散程度，值越大表示波动越大。其中这几项里面的时间都是表示Wall duration，也就是真实所经过的时间 Longest running occurrences：按运行时间进行排序的事件，通过该表可以找到事件消耗最久的事件，从而优先处理耗时最久的事件 Top Down Top Down关注的是父事件到子事件的层级信息 Total：该事件所消耗的实际时间，也就是前面提到的Wall Duration 第一个百分比：当前事件的Total时间占比根事件的Total时间比例 Self：不算子事件的Total时间，可以看出来每个时间的total时间=self+所有子事件的total时间 第二个百分比：当前事件的self时间占比根事件的total时间的比例 children：当前事件的所有子事件的实际消耗时间 第三个百分比：所有子事件消耗的时间占根事件的total时间的比例 Flame Chart Flame Chart视图也叫火焰图，从底下到上面依次是父事件到子事件，该图能直观的看到子事件在父事件上的占比,在父事件上展示子事件的时候，会把占比最长的放在左边，所以排查子事件的时候优先看左边的事件 Bottom Up bottom up视图将父事件和子事件平铺展开，通过它可以直观的看出当前事件占比根事件的占比，也可以直接按照比例排序查看占比高的事件 Events 其实它是对前面Summary视图中的All Occurrences（所有相同事件）的汇总，并把各项信息列出来，方便我们知道每个事件的耗时 回到前面例子中，我们在Adapter的onBindViewHolder中加入了Thread.sleep(50)的时间，然后回到刚才那一帧，查看线程的状态：\n我们选择了刚刚的那一帧，发现在其中主线程一直处于sleep状态，那最终是怎么发现是在onBindViewHolder中线程处于休眠状态的呢，我们看下该帧的RV Scroll事件：\n在该事件的Top Down面板中，大部分占用时间是在RV Scroll中，其中子事件的时间占用很少，在RV OnBindView中的self时间很少，是因为它不占用cpu的资源，而systemtrace记录的是RV OnBindView真正占用cpu的运行时间。所以在RV OnBindView上的时间占比很少。所以最终时间消耗体现在RV Scroll上面，而结合线程的状态，所以能确定是在recyclerview的scroll阶段线程出现了大量的sleep状态。\n案例分析 这是一个来回滑动recyclerview的页面，在Janky frames有卡顿的帧，我们点开第一个卡顿帧，然后使用M键放大该帧：\n观察卡顿原因是在滑动过程中一直有inflate，通过代码查看是因为该视图存在recyclerview嵌套recyclerview导致的，在onbindViewHolder中重新去inflate了子布局导致会重新inflate，此处的改法是将外层的recyclerview的layoutmanager重写calculateExtraLayoutSpace方法，然后将extraLayoutSpace的上下方向的偏移量设置为外层recyclerview高度的2倍。 参考：\nhttps://developer.android.com/studio/profile?hl=zh-cn#start-profiling https://developer.android.com/studio/profile/inspect-traces https://developer.android.com/studio/profile/jank-detection ","date":"2025-06-05T17:39:52+08:00","permalink":"http://xiangcman.xyz/p/android%E5%8D%A1%E9%A1%BF%E6%B2%BB%E7%90%86/","title":"Android卡顿治理"},{"content":"glide源码精髓是能学习到很多设计模式，以及对图片的各种处理，首先以源码通读的方式进入到今天的文章。\nglide源码是在4.16.0的版本上分析的。 平常我们使用glide时候直接 glide.with(activity).load(url).into(imageview) 加载图片，基于此，我们顺藤摸瓜看下底层是怎么加载图片的。\nGlide.with 我们是基于参数是activity的重载方法：\n1 2 3 public static RequestManager with(@NonNull Activity activity) { return getRetriever(activity).get(activity); } 先获取RequestManagerRetriever，然后再获取RequestManager：\n1 2 3 private static RequestManagerRetriever getRetriever(@Nullable Context context) { return Glide.get(context).getRequestManagerRetriever(); } 首先调用Glide.get(context)方法，然后通过getRequestManagerRetriever方法获取到RequestManagerRetriever：\n1 2 3 4 5 6 7 8 9 10 public static Glide get(@NonNull Context context) { if (glide == null) { synchronized (Glide.class) { if (glide == null) { checkAndInitializeGlide(context); } } } return glide; } 可以看到该方法是一个静态方法加锁，锁的是所有线程创建glide的实例。如果glide为空，会调用checkAndInitializeGlide方法，猜测是创建glide实例的方法：\n此处不允许多次初始化glide对象，通过一个布尔值控制，并且该布尔值是一个volatile类型的，在多线程中访问是安全的。接着调用了initializeGlide方法：\n1 2 3 4 private static void initializeGlide( @NonNull Context context, @Nullable GeneratedAppGlideModule generatedAppGlideModule) { initializeGlide(context, new GlideBuilder(), generatedAppGlideModule); } 调用了另外一个initializeGlide方法：\n1 2 3 4 5 6 7 8 9 10 private static void initializeGlide( @NonNull Context context, @NonNull GlideBuilder builder, @Nullable GeneratedAppGlideModule annotationGeneratedModule) { //省略代码 Context applicationContext = context.getApplicationContext(); Glide glide = builder.build(applicationContext, manifestModules, annotationGeneratedModule); applicationContext.registerComponentCallbacks(glide); Glide.glide = glide; } 此处省略了通过注解来生成各种配置，其中注解是 GlideModule 的注解，它是一个编译时注解，通过编译时扫描到该注解，然后生成GeneratedAppGlideModuleImpl类，initializeGlide是通过反射执行GeneratedAppGlideModuleImpl类。最终通过GlideBuilder.build方法来生成glide对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 Glide build(@NonNull Context context) { if (sourceExecutor == null) {//访问资源的线程池 sourceExecutor = GlideExecutor.newSourceExecutor(); } if (diskCacheExecutor == null) {//缓存线程池 diskCacheExecutor = GlideExecutor.newDiskCacheExecutor(); } if (animationExecutor == null) {//动画线程池 animationExecutor = GlideExecutor.newAnimationExecutor(); } if (memorySizeCalculator == null) { memorySizeCalculator = new MemorySizeCalculator.Builder(context).build(); } if (connectivityMonitorFactory == null) { connectivityMonitorFactory = new DefaultConnectivityMonitorFactory(); } if (bitmapPool == null) { int size = memorySizeCalculator.getBitmapPoolSize(); if (size \u0026gt; 0) { bitmapPool = new LruBitmapPool(size); } else { bitmapPool = new BitmapPoolAdapter(); } } if (arrayPool == null) { arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes()); } if (memoryCache == null) { memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize()); } if (diskCacheFactory == null) { diskCacheFactory = new InternalCacheDiskCacheFactory(context); } if (engine == null) { engine = new Engine( memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, GlideExecutor.newUnlimitedSourceExecutor(), GlideExecutor.newAnimationExecutor(), isActiveResourceRetentionAllowed); } RequestManagerRetriever requestManagerRetriever = new RequestManagerRetriever(requestManagerFactory); return new Glide( context, engine, memoryCache, bitmapPool, arrayPool, requestManagerRetriever, connectivityMonitorFactory, logLevel, defaultRequestOptions.lock(), defaultTransitionOptions); } 初始化线程池，构造了Engine、RequestManagerRetriever对象，最后初始化了Glide对象。所以上面的getRequestManagerRetriever方法返回的对象就是此处new的RequestManagerRetriever对象。接着调用了RequestManagerRetriever的get方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @NonNull public RequestManager get(@NonNull Context context) { if (context == null) { throw new IllegalArgumentException(\u0026#34;You cannot start a load on a null Context\u0026#34;); } else if (Util.isOnMainThread() \u0026amp;\u0026amp; !(context instanceof Application)) { if (context instanceof FragmentActivity) { return get((FragmentActivity) context); } else if (context instanceof ContextWrapper \u0026amp;\u0026amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != null) { return get(((ContextWrapper) context).getBaseContext()); } } return getApplicationManager(context); } 该方法会返回一个RequestManager对象，如果context不是Application类型，则通过get方法创建RequestManager对象，如果是Application类型，则通过getApplicationManager方法创建。首先来看下通过FragmentActivity来创建RequestManager对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public RequestManager get(@NonNull FragmentActivity activity) { //如果当前不是主线程，则通过Application创建 if (Util.isOnBackgroundThread()) { return get(activity.getApplicationContext()); } assertNotDestroyed(activity); frameWaiter.registerSelf(activity); boolean isActivityVisible = isActivityVisible(activity); Glide glide = Glide.get(activity.getApplicationContext()); return lifecycleRequestManagerRetriever.getOrCreate( activity, glide, activity.getLifecycle(), activity.getSupportFragmentManager(), isActivityVisible); } 首先判断当前线程如果不是主线程，则通过Application创建RequestManager，接着判断activity是否可见，可见的条件是activity没有finish掉。最终通过LifecycleRequestManagerRetriever的getOrCreate方法来创建RequestManager：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 RequestManager getOrCreate( Context context, Glide glide, final Lifecycle lifecycle, FragmentManager childFragmentManager, boolean isParentVisible) { Util.assertMainThread(); RequestManager result = getOnly(lifecycle); if (result == null) { LifecycleLifecycle glideLifecycle = new LifecycleLifecycle(lifecycle); result = factory.build( glide, glideLifecycle, new SupportRequestManagerTreeNode(childFragmentManager), context); lifecycleToRequestManager.put(lifecycle, result); glideLifecycle.addListener( new LifecycleListener() { @Override public void onStart() {} @Override public void onStop() {} @Override public void onDestroy() { lifecycleToRequestManager.remove(lifecycle); } }); if (isParentVisible) { result.onStart(); } } return result; } 先通过getOnly从lifecycleToRequestManager这个map中取，key是activity的lifecycle对象，如果没有取到则通过factory.build来创建RequestManager，factory是RequestManagerFactory接口，它是在glide初始化的时候构造的。LifecycleRequestManagerRetriever中的factory是在RequestManagerRetriever构造方法中传进来的：\n1 2 3 4 5 public RequestManagerRetriever(@Nullable RequestManagerFactory factory) { this.factory = factory != null ? factory : DEFAULT_FACTORY; lifecycleRequestManagerRetriever = new LifecycleRequestManagerRetriever(this.factory); frameWaiter = buildFrameWaiter(); } RequestManagerRetriever构造方法中默认传入的RequestManagerFactory是空的，因此会用DEFAULT_FACTORY：\n1 2 3 4 5 6 7 8 9 10 11 12 private static final RequestManagerFactory DEFAULT_FACTORY = new RequestManagerFactory() { @NonNull @Override public RequestManager build( @NonNull Glide glide, @NonNull Lifecycle lifecycle, @NonNull RequestManagerTreeNode requestManagerTreeNode, @NonNull Context context) { return new RequestManager(glide, lifecycle, requestManagerTreeNode, context); } }; 直接new了一个RequestManager对象，可见典型的工厂模式创建对象。\n小结 Glide.with方法里面判断glide单例对象是否存在，如果不存在先在GlideBuilder的build方法中创建各种线程池，包括访问资源的线程池，缓存线程池，动画线程池等。然后创建Engine和RequestManagerRetriever对象，接着把创建的各种线程池，pool，Engine和RequestManagerRetriever都传入到Glide对象中，方便后面使用。上面在构建Glide之前会判断GeneratedAppGlideModule注解的类存不存在，它是通过注解来配置各种参数的类。 构建完Glide对象后，接着通过RequestManagerRetriever的get方法创建RequestManager，其中创建RequestManager的方式有Application，Fragment，Activity的形式，我们拿Activity的形式创建来说，如果当前线程不是主线程，则使用Application的形式来创建，因为非主线程是不带生命周期。接着通过LifecycleRequestManagerRetriever的getOrCreate方法来获取RequestManager，此处的LifecycleRequestManagerRetriever是在RequestManagerRetriever构造方法中创建的。 LifecycleRequestManagerRetriever的getOrCreate方法中通过map存储了Lifecycle中的RequestManager，也就是说每一个Lifecycle对应一个RequestManager。首先判断该map中是否存在RequestManager，如果不存在，创建了一个LifecycleLifecycle，它是一个LifecycleObserver对象，它通过监听Activity等类型的Lifecycle的生命周期，来管理Lifecycle和RequestManager。 上面就是整个Glide.with创建RequestManager的流程。 Glide.with(Context).load(url) 上面分析了Glide.with是创建RequestManager的过程，那其实load方法也就对应了RequestManager的load方法：\n1 2 3 public RequestBuilder\u0026lt;Drawable\u0026gt; load(@Nullable String string) { return asDrawable().load(string); } 我们通过传进来的string作为讲解，首先调用了asDrawable方法：\n1 2 3 4 5 6 7 8 public RequestBuilder\u0026lt;Drawable\u0026gt; asDrawable() { return as(Drawable.class); } public \u0026lt;ResourceType\u0026gt; RequestBuilder\u0026lt;ResourceType\u0026gt; as( @NonNull Class\u0026lt;ResourceType\u0026gt; resourceClass) { return new RequestBuilder\u0026lt;\u0026gt;(glide, this, resourceClass, context); } 将Drawable作为RequestBuilder的泛型，并返回了RequestBuilder实例，接着看RequestBuilder的load方法：\n1 2 3 4 5 6 7 8 9 10 11 public RequestBuilder\u0026lt;TranscodeType\u0026gt; load(@Nullable String string) { return loadGeneric(string); } private RequestBuilder\u0026lt;TranscodeType\u0026gt; loadGeneric(@Nullable Object model) { if (isAutoCloneEnabled()) { return clone().loadGeneric(model); } this.model = model; isModelSet = true; return selfOrThrowIfLocked(); } load方法将url传给了RequestBuilder的model属性，然后返回自己。\nGlide.with(Context).load(url).into(imageView) 调完load方法，实际就返回了RequestBuilder对象了。所以into就是它的方法了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public ViewTarget\u0026lt;ImageView, TranscodeType\u0026gt; into(@NonNull ImageView view) { Util.assertMainThread(); BaseRequestOptions\u0026lt;?\u0026gt; requestOptions = this; if (!requestOptions.isTransformationSet() \u0026amp;\u0026amp; requestOptions.isTransformationAllowed() \u0026amp;\u0026amp; view.getScaleType() != null) { switch (view.getScaleType()) { case CENTER_CROP: requestOptions = requestOptions.clone().optionalCenterCrop(); break; case CENTER_INSIDE: requestOptions = requestOptions.clone().optionalCenterInside(); break; case FIT_CENTER: case FIT_START: case FIT_END: requestOptions = requestOptions.clone().optionalFitCenter(); break; case FIT_XY: requestOptions = requestOptions.clone().optionalCenterInside(); break; case CENTER: case MATRIX: default: } } return into( glideContext.buildImageViewTarget(view, transcodeClass), /* targetListener= */ null, requestOptions, Executors.mainThreadExecutor()); } RequestBbuilder继承自BaseRequestOptions，在into里面首先通过imageView的scaleType，然后生成不同的BaseRequestOptions，然后通过glideContext.buildImageViewTarget方法将ImageView包装成ViewTarget：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public \u0026lt;X\u0026gt; ViewTarget\u0026lt;ImageView, X\u0026gt; buildImageViewTarget( @NonNull ImageView imageView, @NonNull Class\u0026lt;X\u0026gt; transcodeClass) { return imageViewTargetFactory.buildTarget(imageView, transcodeClass); } public \u0026lt;Z\u0026gt; ViewTarget\u0026lt;ImageView, Z\u0026gt; buildTarget( @NonNull ImageView view, @NonNull Class\u0026lt;Z\u0026gt; clazz) { if (Bitmap.class.equals(clazz)) { return (ViewTarget\u0026lt;ImageView, Z\u0026gt;) new BitmapImageViewTarget(view); } else if (Drawable.class.isAssignableFrom(clazz)) { return (ViewTarget\u0026lt;ImageView, Z\u0026gt;) new DrawableImageViewTarget(view); } } 上面分析过clazz传进来的是Drawable.class，所以会包装成DrawableImageViewTarget。 接着调用了另外一个into方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private \u0026lt;Y extends Target\u0026lt;TranscodeType\u0026gt;\u0026gt; Y into( @NonNull Y target, @Nullable RequestListener\u0026lt;TranscodeType\u0026gt; targetListener, BaseRequestOptions\u0026lt;?\u0026gt; options, Executor callbackExecutor) { Request request = buildRequest(target, targetListener, options, callbackExecutor); Request previous = target.getRequest(); if (request.isEquivalentTo(previous) \u0026amp;\u0026amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) { if (!Preconditions.checkNotNull(previous).isRunning()) { previous.begin(); } return target; } requestManager.clear(target); target.setRequest(request); requestManager.track(target, request); return target; } 首先调用了buildRequest方法来构建Request，然后获取target的request和当前request是不是同一个，如果是的话，则直接返回已经存在的target，否则调用requestManager.track，我们先看buildRequest：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 private Request buildRequest( Target\u0026lt;TranscodeType\u0026gt; target, @Nullable RequestListener\u0026lt;TranscodeType\u0026gt; targetListener, BaseRequestOptions\u0026lt;?\u0026gt; requestOptions, Executor callbackExecutor) { return buildRequestRecursive( /* requestLock= */ new Object(), target, targetListener, /* parentCoordinator= */ null, transitionOptions, requestOptions.getPriority(), requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight(), requestOptions, callbackExecutor); } private Request buildRequestRecursive( Object requestLock, Target\u0026lt;TranscodeType\u0026gt; target, @Nullable RequestListener\u0026lt;TranscodeType\u0026gt; targetListener, @Nullable RequestCoordinator parentCoordinator, TransitionOptions\u0026lt;?, ? super TranscodeType\u0026gt; transitionOptions, Priority priority, int overrideWidth, int overrideHeight, BaseRequestOptions\u0026lt;?\u0026gt; requestOptions, Executor callbackExecutor) { Request mainRequest = buildThumbnailRequestRecursive( requestLock, target, targetListener, parentCoordinator, transitionOptions, priority, overrideWidth, overrideHeight, requestOptions, callbackExecutor); return mainRequest; } 上面的buildRequestRecursive方法省去了errorBuilder相关的处理，默认是不用去处理的，所以可以看到上面构建Request实际调用了buildThumbnailRequestRecursive方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private Request buildThumbnailRequestRecursive( Object requestLock, Target\u0026lt;TranscodeType\u0026gt; target, RequestListener\u0026lt;TranscodeType\u0026gt; targetListener, @Nullable RequestCoordinator parentCoordinator, TransitionOptions\u0026lt;?, ? super TranscodeType\u0026gt; transitionOptions, Priority priority, int overrideWidth, int overrideHeight, BaseRequestOptions\u0026lt;?\u0026gt; requestOptions, Executor callbackExecutor) { return obtainRequest( requestLock, target, targetListener, requestOptions, parentCoordinator, transitionOptions, priority, overrideWidth, overrideHeight, callbackExecutor); } 上面也是省去了其他相关逻辑，所以我们直接看obtainRequest方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 private Request obtainRequest( Object requestLock, Target\u0026lt;TranscodeType\u0026gt; target, RequestListener\u0026lt;TranscodeType\u0026gt; targetListener, BaseRequestOptions\u0026lt;?\u0026gt; requestOptions, RequestCoordinator requestCoordinator, TransitionOptions\u0026lt;?, ? super TranscodeType\u0026gt; transitionOptions, Priority priority, int overrideWidth, int overrideHeight, Executor callbackExecutor) { return SingleRequest.obtain( context, glideContext, requestLock, model, transcodeClass, requestOptions, overrideWidth, overrideHeight, priority, target, targetListener, requestListeners, requestCoordinator, glideContext.getEngine(), transitionOptions.getTransitionFactory(), callbackExecutor); } public static \u0026lt;R\u0026gt; SingleRequest\u0026lt;R\u0026gt; obtain( Context context, GlideContext glideContext, Object requestLock, Object model, Class\u0026lt;R\u0026gt; transcodeClass, BaseRequestOptions\u0026lt;?\u0026gt; requestOptions, int overrideWidth, int overrideHeight, Priority priority, Target\u0026lt;R\u0026gt; target, RequestListener\u0026lt;R\u0026gt; targetListener, @Nullable List\u0026lt;RequestListener\u0026lt;R\u0026gt;\u0026gt; requestListeners, RequestCoordinator requestCoordinator, Engine engine, TransitionFactory\u0026lt;? super R\u0026gt; animationFactory, Executor callbackExecutor) { return new SingleRequest\u0026lt;\u0026gt;( context, glideContext, requestLock, model, transcodeClass, requestOptions, overrideWidth, overrideHeight, priority, target, targetListener, requestListeners, requestCoordinator, engine, animationFactory, callbackExecutor); } 上面都没什么好说的，直接new了一个SingleRequest，此处SingleRequest的发型是Drawable，这是在上面分析load的时候知道的，先明确这点。我们再回到上面RequestBuilder的into方法，先构建一个SingleRequest，然后看当前target的request和构建的SingleRequest是不是同一个，如果是直接返回，如果不是调用requestManager.track，先看target.getRequest，前面分析过target是一个DrawableImageViewTarget，它的父父类ViewTarget：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public Request getRequest() { Object tag = getTag(); Request request = null; if (tag != null) { if (tag instanceof Request) { request = (Request) tag; } else { throw new IllegalArgumentException( \u0026#34;You must not call setTag() on a view Glide is targeting\u0026#34;); } } return request; } private static int tagId = R.id.glide_custom_view_target_tag; private Object getTag() { return view.getTag(tagId); } public void setRequest(@Nullable Request request) { setTag(request); } private void setTag(@Nullable Object tag) { isTagUsedAtLeastOnce = true; view.setTag(tagId, tag); } 可以看到request是塞入到view的tag上，并且该tag是绑定了一个id。接着看下requestManager.track：\n1 2 3 4 synchronized void track(@NonNull Target\u0026lt;?\u0026gt; target, @NonNull Request request) { targetTracker.track(target); requestTracker.runRequest(request); } 将target放到TargetTracker中：\n1 2 3 4 5 private final Set\u0026lt;Target\u0026lt;?\u0026gt;\u0026gt; targets = Collections.newSetFromMap(new WeakHashMap\u0026lt;Target\u0026lt;?\u0026gt;, Boolean\u0026gt;()); public void track(@NonNull Target\u0026lt;?\u0026gt; target) { targets.add(target); } 将target只是放到set集合中，后面会用到，先不用管。重要看RequestTracker的runRequest方法：\n1 2 3 4 5 6 7 8 9 10 11 private final Set\u0026lt;Request\u0026gt; requests = Collections.newSetFromMap(new WeakHashMap\u0026lt;Request, Boolean\u0026gt;()); public void runRequest(@NonNull Request request) { requests.add(request); if (!isPaused) { request.begin(); } else { request.clear(); pendingRequests.add(request); } } 首先将request也是放到set集合中，接着判断当前是不是pause状态，默认不是pause状态，则调用request的begin方法，前面分析过该request实际是SingleRequest：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public void begin() { synchronized (requestLock) { experimentalNotifyRequestStarted(model); status = Status.WAITING_FOR_SIZE;//默认状态 //如果重写了override方法来制定加载图片的大小 if (Util.isValidDimensions(overrideWidth, overrideHeight)) { onSizeReady(overrideWidth, overrideHeight); } else { //如果没有制定大小走此处 target.getSize(this); } if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE) \u0026amp;\u0026amp; canNotifyStatusChanged()) { //回调start的状态 target.onLoadStarted(getPlaceholderDrawable()); } } } 如果没有通过override方法制定加载图片的大小，则调用target.getSize方法：\n1 2 3 public void getSize(@NonNull SizeReadyCallback cb) { sizeDeterminer.getSize(cb); } 调用了内部类SizeDeterminer的getSize方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void getSize(@NonNull SizeReadyCallback cb) { //获取target的宽高 int currentWidth = getTargetWidth(); int currentHeight = getTargetHeight(); //如果宽高校验通过则回调到SingleRequest的onSizeReady if (isViewStateAndSizeValid(currentWidth, currentHeight)) { cb.onSizeReady(currentWidth, currentHeight); return; } if (!cbs.contains(cb)) { cbs.add(cb); } if (layoutListener == null) { ViewTreeObserver observer = view.getViewTreeObserver(); layoutListener = new SizeDeterminerLayoutListener(this); //否则监听绘制的前置事件 observer.addOnPreDrawListener(layoutListener); } } 获取target的宽高，如果宽高校验通过则回调到SingleRequest中，否则监听target的绘制前置事件。我们看下如何获取宽高的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 private int getTargetWidth() { int horizontalPadding = view.getPaddingLeft() + view.getPaddingRight(); LayoutParams layoutParams = view.getLayoutParams(); int layoutParamSize = layoutParams != null ? layoutParams.width : PENDING_SIZE; return getTargetDimen(view.getWidth(), layoutParamSize, horizontalPadding); } private int getTargetDimen(int viewSize, int paramSize, int paddingSize) { int adjustedParamSize = paramSize - paddingSize; //如果layoutParams中设置了精确宽度 if (adjustedParamSize \u0026gt; 0) { return adjustedParamSize; } //默认不走这里 if (waitForLayout \u0026amp;\u0026amp; view.isLayoutRequested()) { return PENDING_SIZE; } //默认viewSize等于0，也不走这里 int adjustedViewSize = viewSize - paddingSize; if (adjustedViewSize \u0026gt; 0) { return adjustedViewSize; } //如果imageView没有经过测量，并且宽度设置的是WRAP_CONTENT，走这里 if (!view.isLayoutRequested() \u0026amp;\u0026amp; paramSize == LayoutParams.WRAP_CONTENT) { return getMaxDisplayLength(view.getContext()); } return PENDING_SIZE; } 我们只分析宽度和高度为LayoutParams. WRAP_CONTENT情况，此时会调getMaxDisplayLength：\n1 2 3 4 5 6 7 8 9 10 11 private static int getMaxDisplayLength(@NonNull Context context) { if (maxDisplayLength == null) { WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay(); Point displayDimensions = new Point(); display.getSize(displayDimensions); maxDisplayLength = Math.max(displayDimensions.x, displayDimensions.y); } return maxDisplayLength; } 可以看到获取的是屏幕的宽高，所以如果没有imageView定宽高，并且还没到测量的时候，此时设置的初始宽高是屏幕宽高的最大值。获取到默认宽高后会回调到SingleRequest的onSizeReady：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public void onSizeReady(int width, int height) { synchronized (requestLock) { if (status != Status.WAITING_FOR_SIZE) { return; } status = Status.RUNNING; loadStatus = engine.load( glideContext, model, requestOptions.getSignature(), this.width, this.height, requestOptions.getResourceClass(), transcodeClass, priority, requestOptions.getDiskCacheStrategy(), requestOptions.getTransformations(), requestOptions.isTransformationRequired(), requestOptions.isScaleOnlyOrNoTransform(), requestOptions.getOptions(), requestOptions.isMemoryCacheable(), requestOptions.getUseUnlimitedSourceGeneratorsPool(), requestOptions.getUseAnimationPool(), requestOptions.getOnlyRetrieveFromCache(), this, callbackExecutor); if (status != Status.RUNNING) { loadStatus = null; } } } 调用了Engine的load方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 public \u0026lt;R\u0026gt; LoadStatus load( GlideContext glideContext, Object model, Key signature, int width, int height, Class\u0026lt;?\u0026gt; resourceClass, Class\u0026lt;R\u0026gt; transcodeClass, Priority priority, DiskCacheStrategy diskCacheStrategy, Map\u0026lt;Class\u0026lt;?\u0026gt;, Transformation\u0026lt;?\u0026gt;\u0026gt; transformations, boolean isTransformationRequired, boolean isScaleOnlyOrNoTransform, Options options, boolean isMemoryCacheable, boolean useUnlimitedSourceExecutorPool, boolean useAnimationPool, boolean onlyRetrieveFromCache, ResourceCallback cb, Executor callbackExecutor) { //构建EngineKey，由于不需要外部去控制key，所以keyFactory是一个普通的factory，不需要进行扩展 EngineKey key = keyFactory.buildKey( model, signature, width, height, transformations, resourceClass, transcodeClass, options); EngineResource\u0026lt;?\u0026gt; memoryResource; synchronized (this) { //从内存中加载 memoryResource = loadFromMemory(key, isMemoryCacheable, startTime); if (memoryResource == null) { //如果内存中不存在，走这里 return waitForExistingOrStartNewJob( glideContext, model, signature, width, height, resourceClass, transcodeClass, priority, diskCacheStrategy, transformations, isTransformationRequired, isScaleOnlyOrNoTransform, options, isMemoryCacheable, useUnlimitedSourceExecutorPool, useAnimationPool, onlyRetrieveFromCache, cb, callbackExecutor, key, startTime); } } cb.onResourceReady( memoryResource, DataSource.MEMORY_CACHE, /* isLoadedFromAlternateCacheKey= */ false); return null; } 先不用管内存加载这块，直接看waitForExistingOrStartNewJob方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 private \u0026lt;R\u0026gt; LoadStatus waitForExistingOrStartNewJob( GlideContext glideContext, Object model, Key signature, int width, int height, Class\u0026lt;?\u0026gt; resourceClass, Class\u0026lt;R\u0026gt; transcodeClass, Priority priority, DiskCacheStrategy diskCacheStrategy, Map\u0026lt;Class\u0026lt;?\u0026gt;, Transformation\u0026lt;?\u0026gt;\u0026gt; transformations, boolean isTransformationRequired, boolean isScaleOnlyOrNoTransform, Options options, boolean isMemoryCacheable, boolean useUnlimitedSourceExecutorPool, boolean useAnimationPool, boolean onlyRetrieveFromCache, ResourceCallback cb, Executor callbackExecutor, EngineKey key, long startTime) { //从已存在的job列表中找相同的EngineJob EngineJob\u0026lt;?\u0026gt; current = jobs.get(key, onlyRetrieveFromCache); if (current != null) { current.addCallback(cb, callbackExecutor); return new LoadStatus(cb, current); } //如果没有找到相同的EngineJob，则构建一个新的出来 EngineJob\u0026lt;R\u0026gt; engineJob = engineJobFactory.build( key, isMemoryCacheable, useUnlimitedSourceExecutorPool, useAnimationPool, onlyRetrieveFromCache); //构建DecodeJob DecodeJob\u0026lt;R\u0026gt; decodeJob = decodeJobFactory.build( glideContext, model, key, signature, width, height, resourceClass, transcodeClass, priority, diskCacheStrategy, transformations, isTransformationRequired, isScaleOnlyOrNoTransform, onlyRetrieveFromCache, options, engineJob); //将构建好的EngineJob放到job列表中 jobs.put(key, engineJob); //将cb添加到EngineJob中作为回调，这里的cb是前面的SingleRequest engineJob.addCallback(cb, callbackExecutor); //触发加载逻辑 engineJob.start(decodeJob); return new LoadStatus(cb, engineJob); } 上面创建EngineJob和DecodeJob，从名字看EngineJob是专门用来加载主逻辑的Job，DecodeJob是解码用的。先不管它们是怎么创建的，后面会讲到，直接看EngineJob的start方法：\n1 2 3 4 5 6 public synchronized void start(DecodeJob\u0026lt;R\u0026gt; decodeJob) { this.decodeJob = decodeJob; GlideExecutor executor = decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor(); executor.execute(decodeJob); } 此时将DecodeJob作为runnable放到线程池中执行，看下它的run方法：\n1 2 3 public void run() { runWrapped(); } 其余的代码删除掉了，只保留核心的方法调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private void runWrapped() { switch (runReason) { case INITIALIZE: stage = getNextStage(Stage.INITIALIZE); currentGenerator = getNextGenerator(); runGenerators(); break; case SWITCH_TO_SOURCE_SERVICE: runGenerators(); break; case DECODE_DATA: decodeFromRetrievedData(); break; } } runReason的默认值是INITIALIZE，然后调用getNextStage获取到当前stage，然后通过getNextGenerator获取下一个generator，然后调用runGenerators来执行generator，来看下这一段逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 private Stage getNextStage(Stage current) { switch (current) { case INITIALIZE: return diskCacheStrategy.decodeCachedResource() ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE); case RESOURCE_CACHE: return diskCacheStrategy.decodeCachedData() ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE); case DATA_CACHE: return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE; case SOURCE: case FINISHED: return Stage.FINISHED; default: throw new IllegalArgumentException(\u0026#34;Unrecognized stage: \u0026#34; + current); } } 默认是支持decodeCachedResource的，它表示是否获取解码后的缓存资源，所以此时返回Stage. RESOURCE_CACHE，接着调用getNextGenerator方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private DataFetcherGenerator getNextGenerator() { switch (stage) { case RESOURCE_CACHE: return new ResourceCacheGenerator(decodeHelper, this); case DATA_CACHE: return new DataCacheGenerator(decodeHelper, this); case SOURCE: return new SourceGenerator(decodeHelper, this); case FINISHED: return null; default: throw new IllegalStateException(\u0026#34;Unrecognized stage: \u0026#34; + stage); } } 创建了ResourceCacheGenerator，然后调用runGenerators方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private void runGenerators() { boolean isStarted = false; //调用当前的generator，如果它的startNext方法返回false，则继续获取下一个stage，并继续调用下一个generator的startNext方法 while (!isCancelled \u0026amp;\u0026amp; currentGenerator != null \u0026amp;\u0026amp; !(isStarted = currentGenerator.startNext())) { stage = getNextStage(stage); currentGenerator = getNextGenerator(); if (stage == Stage.SOURCE) { reschedule(RunReason.SWITCH_TO_SOURCE_SERVICE); return; } } if ((stage == Stage.FINISHED || isCancelled) \u0026amp;\u0026amp; !isStarted) { notifyFailed(); } } 我们直接看stage为SOURCE, generator直接是SourceGenerator时候，看下它的startNext方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public boolean startNext() { //如果已经缓存上了，直接用缓存的数据 if (dataToCache != null) { Object data = dataToCache; dataToCache = null; try { boolean isDataInCache = cacheData(data); if (!isDataInCache) { return true; } } catch (IOException e) { } } //如果sourceCacheGenerator中能拿到数据直接返回 if (sourceCacheGenerator != null \u0026amp;\u0026amp; sourceCacheGenerator.startNext()) { return true; } sourceCacheGenerator = null; loadData = null; boolean started = false; //从DecodeHelper中获取loadData while (!started \u0026amp;\u0026amp; hasNextModelLoader()) { loadData = helper.getLoadData().get(loadDataListIndex++); if (loadData != null \u0026amp;\u0026amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource()) || helper.hasLoadPath(loadData.fetcher.getDataClass()))) { started = true; //如果存在loadData则调该方法 startNextLoad(loadData); } } return started; } startNext中首先从DecodeHelper中获取到loadData，此处我们先不用管怎么获取到loadData，获取到loadData后调用startNextLoad方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 private void startNextLoad(final LoadData\u0026lt;?\u0026gt; toStart) { loadData.fetcher.loadData( helper.getPriority(), new DataCallback\u0026lt;Object\u0026gt;() { @Override public void onDataReady(@Nullable Object data) { if (isCurrentRequest(toStart)) { onDataReadyInternal(toStart, data); } } @Override public void onLoadFailed(@NonNull Exception e) { if (isCurrentRequest(toStart)) { onLoadFailedInternal(toStart, e); } } }); } 此时调用loadData中的fetcher的loadData方法，此处的loadData.fetcher是谁呢？这个后面的章节再了解，先知道是HttpUrlFetcher，然后看下它的loadData方法：\n1 2 3 4 5 6 7 8 9 public void loadData( @NonNull Priority priority, @NonNull DataCallback\u0026lt;? super InputStream\u0026gt; callback) { try { InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders()); callback.onDataReady(result); } catch (IOException e) { callback.onLoadFailed(e); } } 调用了loadDataWithRedirects方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private InputStream loadDataWithRedirects( URL url, int redirects, URL lastUrl, Map\u0026lt;String, String\u0026gt; headers) throws HttpException { urlConnection = buildAndConfigureConnection(url, headers); try { urlConnection.connect(); stream = urlConnection.getInputStream(); } catch (IOException e) { throw new HttpException( \u0026#34;Failed to connect or obtain data\u0026#34;, getHttpStatusCodeOrInvalid(urlConnection), e); } if (isCancelled) { return null; } final int statusCode = getHttpStatusCodeOrInvalid(urlConnection); if (isHttpOk(statusCode)) { return getStreamForSuccessfulRequest(urlConnection); } } 通过buildAndConfigureConnection创建了HttpURLConnection，接着通过code码解析对应的InputStream，结束后回调到SourceGenerator内部类DataCallback的onDataReady，然后回调到SourceGenerator的onDataReadyInternal：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void onDataReadyInternal(LoadData\u0026lt;?\u0026gt; loadData, Object data) { DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy(); if (data != null \u0026amp;\u0026amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) { dataToCache = data; cb.reschedule(); } else { cb.onDataFetcherReady( loadData.sourceKey, data, loadData.fetcher, loadData.fetcher.getDataSource(), originalKey); } } 将获取到的数据给到dataToCache，并且回调到DecodeJob的reschedule方法：\n1 2 3 4 5 6 7 8 public void reschedule() { reschedule(RunReason.SWITCH_TO_SOURCE_SERVICE); } private void reschedule(RunReason runReason) { this.runReason = runReason; callback.reschedule(this); } 此处的callback是EngineJob，继续回调到reschedule：\n1 2 3 public void reschedule(DecodeJob\u0026lt;?\u0026gt; job) { getActiveSourceExecutor().execute(job); } 此处又是一个线程池，再次执行DecodeJob，注意了此时DecodeJob中的runReason是SWITCH_TO_SOURCE_SERVICE，又回到刚才说的runWrapped方法中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 private void runWrapped() { switch (runReason) { case SWITCH_TO_SOURCE_SERVICE: runGenerators(); break; } } private void runGenerators() { boolean isStarted = false; //前面分析过currentGenerator是SourceGenerator，所以再次执行它的startNext方法 while (!isCancelled \u0026amp;\u0026amp; currentGenerator != null \u0026amp;\u0026amp; !(isStarted = currentGenerator.startNext())) { stage = getNextStage(stage); currentGenerator = getNextGenerator(); if (stage == Stage.SOURCE) { reschedule(RunReason.SWITCH_TO_SOURCE_SERVICE); return; } } if ((stage == Stage.FINISHED || isCancelled) \u0026amp;\u0026amp; !isStarted) { notifyFailed(); } } public boolean startNext() { if (dataToCache != null) { Object data = dataToCache; dataToCache = null; try { boolean isDataInCache = cacheData(data); if (!isDataInCache) { return true; } } catch (IOException e) { } } if (sourceCacheGenerator != null \u0026amp;\u0026amp; sourceCacheGenerator.startNext()) { return true; } //...省略了前面分析过的流程 } 前面分析过获取到网络数据后，给dataToCache赋值，所以再次执行startNext时候，会调用dataToCache不为空的逻辑。其中cacheData是将原始图片的inputStream数据保存到磁盘中：\n1 2 3 4 5 6 7 8 9 10 11 12 private boolean cacheData(Object dataToCache) throws IOException { DataRewinder\u0026lt;Object\u0026gt; rewinder = helper.getRewinder(dataToCache); Object data = rewinder.rewindAndGet(); Encoder\u0026lt;Object\u0026gt; encoder = helper.getSourceEncoder(data); DataCacheWriter\u0026lt;Object\u0026gt; writer = new DataCacheWriter\u0026lt;\u0026gt;(encoder, data, helper.getOptions()); DataCacheKey newOriginalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature()); DiskCache diskCache = helper.getDiskCache(); diskCache.put(newOriginalKey, writer); sourceCacheGenerator = new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, this); return true; } 保存完磁盘后，创建了DataCacheGenerator，所以回到startNext方法中，会执行DataCacheGenerator的startNext方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public boolean startNext() { loadData = null; boolean started = false; while (!started \u0026amp;\u0026amp; hasNextModelLoader()) { ModelLoader\u0026lt;File, ?\u0026gt; modelLoader = modelLoaders.get(modelLoaderIndex++); loadData = modelLoader.buildLoadData( cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions()); if (loadData != null \u0026amp;\u0026amp; helper.hasLoadPath(loadData.fetcher.getDataClass())) { started = true; loadData.fetcher.loadData(helper.getPriority(), this); } } return started; } 此处的loadData.fetcher是一个ByteBufferFetcher，后面再分析怎么得到该fetcher，会执行到它的loadData：\n1 2 3 4 5 6 public void loadData( @NonNull Priority priority, @NonNull DataCallback\u0026lt;? super ByteBuffer\u0026gt; callback) { ByteBuffer result; result = ByteBufferUtil.fromFile(file); callback.onDataReady(result); } 将文件转换成buffer数据，并回调到DataCacheGenerator的onDataReady：\n1 2 3 public void onDataReady(Object data) { cb.onDataFetcherReady(sourceKey, data, loadData.fetcher, DataSource.DATA_DISK_CACHE, sourceKey); } 回调到SourceGenerator的onDataFetcherReady：\n1 2 3 4 public void onDataFetcherReady( Key sourceKey, Object data, DataFetcher\u0026lt;?\u0026gt; fetcher, DataSource dataSource, Key attemptedKey) { cb.onDataFetcherReady(sourceKey, data, fetcher, loadData.fetcher.getDataSource(), sourceKey); } 继续回调到DecodeJob的onDataFetcherReady方法：\n1 2 3 4 5 6 7 8 9 10 public void onDataFetcherReady( Key sourceKey, Object data, DataFetcher\u0026lt;?\u0026gt; fetcher, DataSource dataSource, Key attemptedKey) { this.currentSourceKey = sourceKey; this.currentData = data; this.currentFetcher = fetcher; this.currentDataSource = dataSource; this.currentAttemptingKey = attemptedKey; this.isLoadingFromAlternateCacheKey = sourceKey != decodeHelper.getCacheKeys().get(0); reschedule(RunReason.DECODE_DATA); } 还是和上面拿到网络数据一样，继续执行DecodeJob的runWrapped：\n1 2 3 4 5 6 7 private void runWrapped() { switch (runReason) { case DECODE_DATA: decodeFromRetrievedData(); break; } } 调用开始解码的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private void decodeFromRetrievedData() { Resource\u0026lt;R\u0026gt; resource = null; try { resource = decodeFromData(currentFetcher, currentData, currentDataSource); } catch (GlideException e) { e.setLoggingDetails(currentAttemptingKey, currentDataSource); throwables.add(e); } if (resource != null) { notifyEncodeAndRelease(resource, currentDataSource, isLoadingFromAlternateCacheKey); } else { runGenerators(); } } 关于解码这块后面会分析到，解码成功后先回调到DecodeJob的onResourceDecoded方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;Z\u0026gt; Resource\u0026lt;Z\u0026gt; onResourceDecoded(DataSource dataSource, @NonNull Resource\u0026lt;Z\u0026gt; decoded) { Class\u0026lt;Z\u0026gt; resourceSubClass = (Class\u0026lt;Z\u0026gt;) decoded.get().getClass(); Transformation\u0026lt;Z\u0026gt; appliedTransformation = null; Resource\u0026lt;Z\u0026gt; transformed = decoded; if (dataSource != DataSource.RESOURCE_DISK_CACHE) { appliedTransformation = decodeHelper.getTransformation(resourceSubClass); transformed = appliedTransformation.transform(glideContext, decoded, width, height); } if (!decoded.equals(transformed)) { decoded.recycle(); } final EncodeStrategy encodeStrategy; final ResourceEncoder\u0026lt;Z\u0026gt; encoder; if (decodeHelper.isResourceEncoderAvailable(transformed)) { encoder = decodeHelper.getResultEncoder(transformed); encodeStrategy = encoder.getEncodeStrategy(options); } else { encoder = null; encodeStrategy = EncodeStrategy.NONE; } Resource\u0026lt;Z\u0026gt; result = transformed; return result; } 在我们的事例中首次获取的是图片原始尺寸，并且transformed和decoded是同一个，所以直接返回了。接着回到decodeFromRetrievedData方法中，继续调用了notifyEncodeAndRelease方法：\n1 2 3 4 5 6 7 8 9 private void notifyEncodeAndRelease( Resource\u0026lt;R\u0026gt; resource, DataSource dataSource, boolean isLoadedFromAlternateCacheKey) { Resource\u0026lt;R\u0026gt; result = resource; LockedResource\u0026lt;R\u0026gt; lockedResource = null; notifyComplete(result, dataSource, isLoadedFromAlternateCacheKey); stage = Stage.ENCODE; onEncodeComplete(); } 上面把encode逻辑去掉了，因为上面返回的是原始图片，所以无需进行encode的本地保存。看下notifyComplete方法：\n1 2 3 4 private void notifyComplete( Resource\u0026lt;R\u0026gt; resource, DataSource dataSource, boolean isLoadedFromAlternateCacheKey) { callback.onResourceReady(resource, dataSource, isLoadedFromAlternateCacheKey); } 回调到EngineJob的onResourceReady：\n1 2 3 4 5 6 7 8 9 public void onResourceReady( Resource\u0026lt;R\u0026gt; resource, DataSource dataSource, boolean isLoadedFromAlternateCacheKey) { synchronized (this) { this.resource = resource; this.dataSource = dataSource; this.isLoadedFromAlternateCacheKey = isLoadedFromAlternateCacheKey; } notifyCallbacksOfResult(); } 继续调用notifyCallbacksOfResult：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void notifyCallbacksOfResult() { ResourceCallbacksAndExecutors copy; Key localKey; EngineResource\u0026lt;?\u0026gt; localResource; synchronized (this) { engineResource = engineResourceFactory.build(resource, isCacheable, key, resourceListener); copy = cbs.copy(); incrementPendingCallbacks(copy.size() + 1); localKey = key; localResource = engineResource; } engineJobListener.onEngineJobComplete(this, localKey, localResource); for (final ResourceCallbackAndExecutor entry : copy) { entry.executor.execute(new CallResourceReady(entry.cb)); } decrementPendingCallbacks(); } 首先调用onEngineJobComplete进行回调保存到内存中，接着通过线程池调用了CallResourceReady，其实此处的线程池是回调到主线程，在上面cbs.copy()的使用，是为了防止使用原始集合遍历的时候，可能发生modifyException问题，所以创建了一个新的对象出来遍历，看下CallResourceReady的run方法：\n1 2 3 4 5 6 7 8 9 10 11 12 public void run() { synchronized (cb.getLock()) { synchronized (EngineJob.this) { if (cbs.contains(cb)) { engineResource.acquire(); callCallbackOnResourceReady(cb); removeCallback(cb); } decrementPendingCallbacks(); } } } 主要看下callCallbackOnResourceReady方法：\n1 2 3 4 5 6 7 void callCallbackOnResourceReady(ResourceCallback cb) { try { cb.onResourceReady(engineResource, dataSource, isLoadedFromAlternateCacheKey); } catch (Throwable t) { throw new CallbackException(t); } } 此处的cb对象是在Engine的waitForExistingOrStartNewJob方法中添加的，实际是SingleRequest对象，所以继续回调到SingleRequest的onResourceReady方法：\n1 2 3 4 5 6 7 8 9 10 public void onResourceReady( Resource\u0026lt;?\u0026gt; resource, DataSource dataSource, boolean isLoadedFromAlternateCacheKey) { onResourceReady( (Resource\u0026lt;R\u0026gt;) resource, (R) received, dataSource, isLoadedFromAlternateCacheKey); } private void onResourceReady( Resource\u0026lt;R\u0026gt; resource, R result, DataSource dataSource, boolean isAlternateCacheKey) { target.onResourceReady(result, animation); } 前面分析过target是DrawableImageViewTarget，它是继承自ImageViewTarget，它的onResourceReady方法：\n1 2 3 4 5 6 7 public void onResourceReady(@NonNull Z resource, @Nullable Transition\u0026lt;? super Z\u0026gt; transition) { if (transition == null || !transition.transition(resource, this)) { setResourceInternal(resource); } else { maybeUpdateAnimatable(resource); } } 此处的transition是一个NoTransition，所以会走setResourceInternal：\n1 2 3 4 5 6 private void setResourceInternal(@Nullable Z resource) { setResource(resource); maybeUpdateAnimatable(resource); } protected abstract void setResource(@Nullable Z resource); 在DrawableImageViewTarget中重写了setResource方法：\n1 2 3 protected void setResource(@Nullable Drawable resource) { view.setImageDrawable(resource); } 最终将图片展示到imageView上。\n最终的简图：\n","date":"2025-05-22T00:00:00Z","permalink":"http://xiangcman.xyz/p/glide%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E6%B5%81%E7%A8%8B/","title":"Glide加载图片流程"},{"content":"之前在了解touch事件的时候，都是从activity-\u0026gt;phoneWindow-\u0026gt;decoreVoew-\u0026gt;content部分的view事件分发，而不知道底层是如何传递给view的，该篇文章就是介绍，底层是如何将事件传递给应用层的。下面先把traceView的截图列出来： 当屏幕收到触摸事件后，底层会给主线程的消息队列中插入一条消息，然后唤醒上层，上层的接收端是NativeInputEventReceriver的handleEvent： 接着调用了consumeEvents方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env, bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) { if (inputEventObj.get()) { if (kDebugDispatchCycle) { ALOGD(\u0026#34;channel \u0026#39;%s\u0026#39; ~ Dispatching input event.\u0026#34;, getInputChannelName().c_str()); } //调用到java层的android/view/InputEventReceiver的dispatchInputEvent方法 env-\u0026gt;CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj.get()); } } int register_android_view_InputEventReceiver(JNIEnv* env) { int res = RegisterMethodsOrDie(env, \u0026#34;android/view/InputEventReceiver\u0026#34;, gMethods, NELEM(gMethods)); //指向了java层的android/view/InputEventReceiver类 jclass clazz = FindClassOrDie(env, \u0026#34;android/view/InputEventReceiver\u0026#34;); gInputEventReceiverClassInfo.clazz = MakeGlobalRefOrDie(env, clazz); gInputEventReceiverClassInfo.dispatchInputEvent = GetMethodIDOrDie(env, gInputEventReceiverClassInfo.clazz, \u0026#34;dispatchInputEvent\u0026#34;, \u0026#34;(ILandroid/view/InputEvent;)V\u0026#34;); gInputEventReceiverClassInfo.onFocusEvent = GetMethodIDOrDie(env, gInputEventReceiverClassInfo.clazz, \u0026#34;onFocusEvent\u0026#34;, \u0026#34;(Z)V\u0026#34;); gInputEventReceiverClassInfo.onPointerCaptureEvent = GetMethodIDOrDie(env, gInputEventReceiverClassInfo.clazz, \u0026#34;onPointerCaptureEvent\u0026#34;, \u0026#34;(Z)V\u0026#34;); gInputEventReceiverClassInfo.onDragEvent = GetMethodIDOrDie(env, gInputEventReceiverClassInfo.clazz, \u0026#34;onDragEvent\u0026#34;, \u0026#34;(ZFF)V\u0026#34;); gInputEventReceiverClassInfo.onTouchModeChanged = GetMethodIDOrDie(env, gInputEventReceiverClassInfo.clazz, \u0026#34;onTouchModeChanged\u0026#34;, \u0026#34;(Z)V\u0026#34;); gInputEventReceiverClassInfo.onBatchedInputEventPending = GetMethodIDOrDie(env, gInputEventReceiverClassInfo.clazz, \u0026#34;onBatchedInputEventPending\u0026#34;, \u0026#34;(I)V\u0026#34;); return res; } 可以看到上面通过register_android_view_InputEventReceiver方法的注册，将gInputEventReceiverClassInfo指向了java层的android/view/InputEventReceiver。而在consumeEvents中通过env-\u0026gt;CallVoidMethod调用jni到了android/view/InputEventReceiver的dispatchInputEvent方法。接下来到了java层，直接看traceview\n1 InputEventReceiver.dispatchInputEvent-\u0026gt;ViewRootImpl$WindowInputEventReceiver.onInputEvent-\u0026gt;ViewRootImpl.enqueueInputEvent-\u0026gt;ViewRootImpl.doProcessInputEvents-\u0026gt;ViewRootImpl.deliverInputEvent-\u0026gt;ViewRootImpl$InputStage.deliver-\u0026gt;ViewRootImpl$InputStage.apply-\u0026gt;deliver-\u0026gt;ViewRootImpl$InputStage.forward-\u0026gt;ViewRootImpl$InputStage.onDeliverToNext....-\u0026gt;ViewPostImeInputStage.onProcess-\u0026gt;ViewPostImeInputStage.processPointerEvent-\u0026gt;View.dispatchPointerEvent-\u0026gt;DecorView.dispatchTouchEvent-\u0026gt;Activity.dispatchTouchEvent-\u0026gt;PhoneWindow.superDispatchTouchEvent-\u0026gt;DecorView.superDispatchTouchEvent-\u0026gt;ViewGroup.dispatchTouchEvent 单击view时候的trace文件\n其实这个只是单次的点击事件，如果是多次触发点击，在viewrootimpl中会通过给Choreographer插入一条CALLBACK_INPUT的事件，这个根源也是在NativeInputEventReceiver的consumeEvents中触发了WindowInputEventReceiver的onBatchedInputEventPending，关键代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env, bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) { if (kDebugDispatchCycle) { ALOGD(\u0026#34;channel \u0026#39;%s\u0026#39; ~ Consuming input events, consumeBatches=%s, frameTime=%\u0026#34; PRId64, getInputChannelName().c_str(), toString(consumeBatches), frameTime); } if (consumeBatches) { mBatchedInputEventPending = false; traceBoolVariable(\u0026#34;mBatchedInputEventPending\u0026#34;, mBatchedInputEventPending); } if (outConsumedBatch) { *outConsumedBatch = false; } ScopedLocalRef\u0026lt;jobject\u0026gt; receiverObj(env, nullptr); bool skipCallbacks = false; for (;;) { uint32_t seq; InputEvent* inputEvent; status_t status = mInputConsumer.consume(\u0026amp;mInputEventFactory, consumeBatches, frameTime, \u0026amp;seq, \u0026amp;inputEvent); if (status == WOULD_BLOCK) { if (!skipCallbacks \u0026amp;\u0026amp; !mBatchedInputEventPending \u0026amp;\u0026amp; mInputConsumer.hasPendingBatch()) { // There is a pending batch. Come back later. if (!receiverObj.get()) { receiverObj.reset(GetReferent(env, mReceiverWeakGlobal)); if (!receiverObj.get()) { ALOGW(\u0026#34;channel \u0026#39;%s\u0026#39; ~ Receiver object was finalized \u0026#34; \u0026#34;without being disposed.\u0026#34;, getInputChannelName().c_str()); return DEAD_OBJECT; } } mBatchedInputEventPending = true; traceBoolVariable(\u0026#34;mBatchedInputEventPending\u0026#34;, mBatchedInputEventPending); if (kDebugDispatchCycle) { ALOGD(\u0026#34;channel \u0026#39;%s\u0026#39; ~ Dispatching batched input event pending notification.\u0026#34;, getInputChannelName().c_str()); } //调用到gInputEventReceiverClassInfo的onBatchedInputEventPending方法 env-\u0026gt;CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.onBatchedInputEventPending, mInputConsumer.getPendingBatchSource()); if (env-\u0026gt;ExceptionCheck()) { ALOGE(\u0026#34;Exception dispatching batched input events.\u0026#34;); mBatchedInputEventPending = false; // try again later traceBoolVariable(\u0026#34;mBatchedInputEventPending\u0026#34;, mBatchedInputEventPending); } } return OK; } } } 最终触发到ConsumeBatchedInputRunnable，最后会执行doProcessInputEvents-\u0026gt;deliverInputEvent\u0026hellip;，也就上单次点击的方法调用。从这里也可以看出，如果触摸事件积累很多的时候，会通过给Choreographer插入一条CALLBACK_INPUT的事件，然后等到下次vsync信号来的时候，才会去处理touch事件，减轻主线程的压力。通过此机制，Android 在保证输入响应的同时，最大限度减少 UI 线程的负载，优化整体流畅性。 多次触摸屏幕的时候trace文件\n","date":"2025-03-24T00:00:00Z","permalink":"http://xiangcman.xyz/p/%E9%80%9A%E8%BF%87traceview%E5%88%86%E6%9E%90touch%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%BA%90%E5%A4%B4%E5%8A%A0%E6%B7%B1touch%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3/","title":"TraceView帮我解决了touch事件的源头"},{"content":"要着手binder分析，我们可以用一个简单的activity跳转逻辑来分析，最好的办法是让intent中携带的数据超过1M的数据，然后通过logcat中异常堆栈来分析：\n1 2 3 4 val intent = Intent(this, BitmapActivity::class.java) val data = ByteArray(1024*1024)open intent.putExtra(\u0026#34;data\u0026#34;,data) startActivity(intent) 此处是直接携带1M的数据，然后系统给我来了个异常信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 2025-04-17 20:33:24.613 8782-8782 JavaBinder com.example.coroutinescopedemo E !!! FAILED BINDER TRANSACTION !!! (parcel size = 1049068) --------- beginning of crash 2025-04-17 20:33:24.627 8782-8782 AndroidRuntime com.example.coroutinescopedemo E FATAL EXCEPTION: main Process: com.example.coroutinescopedemo, PID: 8782 java.lang.RuntimeException: Failure from system at android.app.Instrumentation.execStartActivity(Instrumentation.java:1749) at android.app.Activity.startActivityForResult(Activity.java:5533) at androidx.activity.ComponentActivity.startActivityForResult(ComponentActivity.kt:704) at android.app.Activity.startActivityForResult(Activity.java:5486) at androidx.activity.ComponentActivity.startActivityForResult(ComponentActivity.kt:683) at android.app.Activity.startActivity(Activity.java:5892) at android.app.Activity.startActivity(Activity.java:5845) at com.example.coroutinescopedemo.BottomSheetActivity.onCreate$lambda$0(BottomSheetActivity.kt:27) at com.example.coroutinescopedemo.BottomSheetActivity.$r8$lambda$CWhZfDsJCDnJCQuDq0om0F9MZaU(Unknow at com.example.coroutinescopedemo.BottomSheetActivity$$ExternalSyntheticLambda0.onClick(D8$$Synthet at android.view.View.performClick(View.java:7753) at android.view.View.performClickInternal(View.java:7730) at android.view.View.access$3700(View.java:861) at android.view.View$PerformClick.run(View.java:29146) at android.os.Handler.handleCallback(Handler.java:938) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loopOnce(Looper.java:210) at android.os.Looper.loop(Looper.java:299) at android.app.ActivityThread.main(ActivityThread.java:8293) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:556) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1045) Caused by: android.os.TransactionTooLargeException: data parcel size 1049092 bytes at android.os.BinderProxy.transactNative(Native Method) at android.os.BinderProxy.transact(BinderProxy.java:624) at android.app.IActivityTaskManager$Stub$Proxy.startActivity(IActivityTaskManager.java:2664) at android.app.Instrumentation.execStartActivity(Instrumentation.java:1743) at android.app.Activity.startActivityForResult(Activity.java:5533) at androidx.activity.ComponentActivity.startActivityForResult(ComponentActivity.kt:704) at android.app.Activity.startActivityForResult(Activity.java:5486) at androidx.activity.ComponentActivity.startActivityForResult(ComponentActivity.kt:683) at android.app.Activity.startActivity(Activity.java:5892) at android.app.Activity.startActivity(Activity.java:5845) at com.example.coroutinescopedemo.BottomSheetActivity.onCreate$lambda$0(BottomSheetActivity.kt:27) at com.example.coroutinescopedemo.BottomSheetActivity.$r8$lambda$CWhZfDsJCDnJCQuDq0om0F9MZaU(Unknow at com.example.coroutinescopedemo.BottomSheetActivity$$ExternalSyntheticLambda0.onClick(D8$$Synthet at android.view.View.performClick(View.java:7753) at android.view.View.performClickInternal(View.java:7730) at android.view.View.access$3700(View.java:861) at android.view.View$PerformClick.run(View.java:29146) at android.os.Handler.handleCallback(Handler.java:938) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loopOnce(Looper.java:210) at android.os.Looper.loop(Looper.java:299) at android.app.ActivityThread.main(ActivityThread.java:8293) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:556) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1045) 可以看到异常分两块，一块是上面的 java.lang.RuntimeException: Failure from system ，它是Instrumentation中的execStartActivity抛的异常，最终是因为在android.os. BinderProxy.transactNative(Native Method)中抛了 android.os.TransactionTooLargeException: data parcel size 1049092 bytes 异常，异常堆栈越是往上面是异常所在点，越往下面是上层代码。当点击按钮的时候屏幕底层会给android应用层发送主线程的消息，然后在消息队列轮训该消息的时候，由于底层抛出异常，在looper轮训消息的时候继续往上层抛，最终该异常会抛给到ZygoteInit。java默认的异常处理机制是交给当前线程的defaultUncaughtExceptionHandler，而RuntimeInit中定义过主线程的defaultUncaughtExceptionHandler，最终该Handler是KillApplicationHandler，在该handler中先收集日志，然后kill掉进程。\n客户端到驱动层 在上面堆栈中，我们直接分析 IActivityTaskManager$Stub$Proxy.startActivity 方法，其中 IActivityTaskManager$Stub$Proxy 类是aidl工具帮我们生成的类，它是IActivityTaskManager接口中的一个内部类，它是客户端拿到服务端的binder起始类，它的获取如下：\n1 2 final IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE); return IActivityTaskManager.Stub.asInterface(b); 其中ServiceManager.getService(Context. ACTIVITY_TASK_SERVICE)拿到的是binderProxy对象，它是c++层的BinderProxy对应java层的BinderProxy对象，在IActivityTaskManager. Stub.asInterface中判断如果调用进程和目标进程不是一个的话，会返回Proxy对象，然后调用到Proxy的startActivity方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @Override public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException { Parcel _data = Parcel.obtain(); Parcel _reply = Parcel.obtain(); int _result; try { _data.writeInterfaceToken(DESCRIPTOR); // 验证远程接口 _data.writeStrongBinder(caller != null ? caller.asBinder() : null); _data.writeString(callingPackage); if (intent != null) { _data.writeInt(1); intent.writeToParcel(_data, 0); } else { _data.writeInt(0); } _data.writeString(resolvedType); _data.writeStrongBinder(resultTo); _data.writeString(resultWho); _data.writeInt(requestCode); _data.writeInt(flags); if (profilerInfo != null) { _data.writeInt(1); profilerInfo.writeToParcel(_data, 0); } else { _data.writeInt(0); } if (options != null) { _data.writeInt(1); options.writeToParcel(_data, 0); } else { _data.writeInt(0); } mRemote.transact(Stub.TRANSACTION_startActivity, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); } finally { _reply.recycle(); _data.recycle(); } return _result; } 在该方法里面，会创建两个Parcel对象，一个是_data，一个是_reply。然后将参数都放到_data中，最终调用了mRemote的transact方法，并把_data和_reply传入其中。此处的_remote对象java层的BinderProxy对象，从堆栈上看然后调用了transactNative方法，该方法是一个native方法，对应的aosp中是android_util_Binder.cpp的android_os_BinderProxy_transact方法，可以看如下方法注册：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static const JNINativeMethod gBinderProxyMethods[] = { /* name, signature, funcPtr */ {\u0026#34;pingBinder\u0026#34;, \u0026#34;()Z\u0026#34;, (void*)android_os_BinderProxy_pingBinder}, {\u0026#34;isBinderAlive\u0026#34;, \u0026#34;()Z\u0026#34;, (void*)android_os_BinderProxy_isBinderAlive}, {\u0026#34;getInterfaceDescriptor\u0026#34;, \u0026#34;()Ljava/lang/String;\u0026#34;, (void*)android_os_BinderProxy_getInterfaceDescriptor}, {\u0026#34;transactNative\u0026#34;, \u0026#34;(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z\u0026#34;, (void*)android_os_BinderProxy_transact}, {\u0026#34;linkToDeathNative\u0026#34;, \u0026#34;(Landroid/os/IBinder$DeathRecipient;I)V\u0026#34;, (void*)android_os_BinderProxy_linkToDeath}, {\u0026#34;unlinkToDeathNative\u0026#34;, \u0026#34;(Landroid/os/IBinder$DeathRecipient;I)Z\u0026#34;, (void*)android_os_BinderProxy_unlinkToDeath}, {\u0026#34;addFrozenStateChangeCallbackNative\u0026#34;, \u0026#34;(Landroid/os/IBinder$FrozenStateChangeCallback;)V\u0026#34;, (void*)android_os_BinderProxy_addFrozenStateChangeCallback}, {\u0026#34;removeFrozenStateChangeCallbackNative\u0026#34;, \u0026#34;(Landroid/os/IBinder$FrozenStateChangeCallback;)Z\u0026#34;, (void*)android_os_BinderProxy_removeFrozenStateChangeCallback}, {\u0026#34;getNativeFinalizer\u0026#34;, \u0026#34;()J\u0026#34;, (void*)android_os_BinderProxy_getNativeFinalizer}, {\u0026#34;getExtension\u0026#34;, \u0026#34;()Landroid/os/IBinder;\u0026#34;, (void*)android_os_BinderProxy_getExtension}, }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException { //①、dataObj是java层传过来的发送数据的parcel if (dataObj == NULL) { jniThrowNullPointerException(env, NULL); return JNI_FALSE; } //②、将java层的parcel数据转成native层的parcel Parcel* data = parcelForJavaObject(env, dataObj); if (data == NULL) { return JNI_FALSE; } //③、将java层的reply的parcel数据转成native层的parcel Parcel* reply = parcelForJavaObject(env, replyObj); if (reply == NULL \u0026amp;\u0026amp; replyObj != NULL) { return JNI_FALSE; } //④、通过java层的BinderProxy获取到native层的BpBinder IBinder* target = getBPNativeData(env, obj)-\u0026gt;mObject.get(); if (target == NULL) { jniThrowException(env, \u0026#34;java/lang/IllegalStateException\u0026#34;, \u0026#34;Binder has been finalized!\u0026#34;); return JNI_FALSE; } ALOGV(\u0026#34;Java code calling transact on %p in Java object %p with code %\u0026#34; PRId32 \u0026#34;\\n\u0026#34;, target, obj, code); //⑤、调用native层的BpBinder的transact方法 status_t err = target-\u0026gt;transact(code, *data, reply, flags); if (err == NO_ERROR) { return JNI_TRUE; } //⑥、通过jni调用到java层的Binder的transactionCallback方法 env-\u0026gt;CallStaticVoidMethod(gBinderOffsets.mClass, gBinderOffsets.mTransactionCallback, getpid(), code, flags, err); if (err == UNKNOWN_TRANSACTION) { return JNI_FALSE; } //⑦、输出错误信息 signalExceptionForError(env, obj, err, true /*canThrowRemoteException*/, data-\u0026gt;dataSize()); return JNI_FALSE; } 在①处如果传进来的java层的parcel类型的data数据为空，则直接返回失败。\n在②处将java层的parcel类型的data数据转成native层的parcel数据。\n在③处将java层的parcel类型的reply数据转成native层的parcel数据。\n在④处通过java层的BinderProxy获取到native层的BpBinder，主要是通过java层BinderProxy的mNativeData指针(native层BpBinder指针)来获取到native层的BpBinder。\n在⑤处调用native层的BpBinder的transact方法。\n在⑥处通过jni调用到java层的Binder的transactionCallback方法。\n最后在⑦处根据transact的结果输出错误信息。\n着重看下在上面⑤处，看下native层的BpBinder如何处理binder的：\n1 2 3 4 5 6 7 status_t BpBinder::transact( uint32_t code, const Parcel\u0026amp; data, Parcel* reply, uint32_t flags) { status_t status; status = IPCThreadState::self()-\u0026gt;transact(binderHandle(), code, data, reply, flags); return status; } 上面只列出关键代码，IPCThreadState::self()是线程单例，调用到IPCThreadState的transact方法，并且可以看到第一个参数是获取BpBinder的binderHandle方法，它就是获取服务端的binder句柄，通过它告诉驱动层，想要的服务端binder是哪个，下面来看下IPCThreadState的transact方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel\u0026amp; data, Parcel* reply, uint32_t flags) { status_t err; flags |= TF_ACCEPT_FDS; //往驱动层写数据 err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, nullptr); //如果有error就不往下执行 if (err != NO_ERROR) { if (reply) reply-\u0026gt;setError(err); return (mLastError = err); } //如果不是one way的请求方式 if ((flags \u0026amp; TF_ONE_WAY) == 0) { //等待返回结果 if (reply) { err = waitForResponse(reply); } else { Parcel fakeReply; err = waitForResponse(\u0026amp;fakeReply); } } else { //如果是one way，传进去的reply是空的 err = waitForResponse(nullptr, nullptr); } return err; } transact逻辑还是挺清晰的，首先往驱动层写数据，如果有error就不往下执行。如果没问题判断是不是one way的请求方式，如果不是则等待返回结果，如果是one way传进入的reply是null。\nwriteTransactionData是往驱动写数据的方法，看下该方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel\u0026amp; data, status_t* statusBuffer) { //定义驱动层认识的数据结构 binder_transaction_data tr; tr.target.ptr = 0; tr.target.handle = handle; tr.code = code; tr.flags = binderFlags; tr.cookie = 0; tr.sender_pid = 0; tr.sender_euid = 0; //判断发送的数据是否有问题 const status_t err = data.errorCheck(); if (err == NO_ERROR) { //如果没有问题，则往binder_transaction_data中写数据 tr.data_size = data.ipcDataSize(); tr.data.ptr.buffer = data.ipcData(); tr.offsets_size = data.ipcObjectsCount()*sizeof(binder_size_t); tr.data.ptr.offsets = data.ipcObjects(); } else if (statusBuffer) { tr.flags |= TF_STATUS_CODE; *statusBuffer = err; tr.data_size = sizeof(status_t); tr.data.ptr.buffer = reinterpret_cast\u0026lt;uintptr_t\u0026gt;(statusBuffer); tr.offsets_size = 0; tr.data.ptr.offsets = 0; } else { //有问题的话，则返回失败 return (mLastError = err); } //将BC_TRANSACTION和binder_transaction_data写入到mOut这个parcel里面 mOut.writeInt32(cmd); mOut.write(\u0026amp;tr, sizeof(tr)); return NO_ERROR; } 首先定义binder_transaction_data数据结构，然后判断发送的数据是否有问题，如果没有则将data相关的数据给到binder_transaction_data，如果有问题，则返回失败，最后将BC_TRANSACTION和binder_transaction_data写入到mOut这个parcel里面。\n上面通过data.errorCheck()来判断发送的数据是否有问题，下面来看下如何验证的：\n1 2 3 4 5 6 status_t Parcel::errorCheck() const { return mError; } 直接返回mError字段，它是在Parcel::continueWrite()方法中赋值的，而continueWrite()方法是在growData()-\u0026gt;writeInplace()-\u0026gt;android_os_Parcel.cpp.android_os_Parcel_write***()方法，最终是java层的Parcel.write***()等方法调用的，关于java层的parcel是如何通过jni调用到android_os_Parcel.cpp主要是因为java层parcel存储了native的parcel指针，它是mNativePtr。 其中关于最大parcel的内存值判断在growData方法中，其中变量SIZE_MAX是64位机器上最大的byte数。如果超过这个值，则返回NO_MEMORY，在continueWrite中会继续判断binder总内存，关于最大内存申请在ProcessState.cpp中调用mmap内存映射的时候，指定了binder的最大内存位BINDER_VM_SIZE = ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2)。 回到上面的IPCThreadState::transact，写完数据后如果发现有问题，则通过android_util_Binder.cpp中的signalExceptionForError抛出异常。接着就是判断如果不是one way的请求方式，则通过waitForResponse等待返回结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult){ uint32_t cmd; while (1) { //往驱动层写东西 talkWithDriver(); cmd = (uint32_t)mIn.readInt32(); switch (cmd) { case BR_TRANSACTION_COMPLETE: break; case BR_REPLY:{ binder_transaction_data tr; err = mIn.read(\u0026amp;tr, sizeof(tr)); reply-\u0026gt;ipcSetDataReference(tr.data.ptr.buffer,tr.data_size); } goto finish; } } return err; } 通过while循环来判断命令，首先每次先通过talkWithDriver往驱动层写东西：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 status_t IPCThreadState::talkWithDriver(bool doReceive) { binder_write_read bwr; const bool needRead = mIn.dataPosition() \u0026gt;= mIn.dataSize(); const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); if (doReceive \u0026amp;\u0026amp; needRead) { bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (uintptr_t)mIn.data(); } else { bwr.read_size = 0; bwr.read_buffer = 0; } ioctl(mProcess-\u0026gt;mDriverFD, BINDER_WRITE_READ, \u0026amp;bwr); return err; } 前面在分析writeTransactionData时候，会把binder_transaction_data数据结构保存到oOut这个parcel里面，此处把oOut的地址指向了binder_write_read的write_buffer字段，如果能读的话，则将mIn的地址指向了binder_write_read的read_buffer字段。最后通过ioctl方法将binder_write_read发送到驱动层。关于ioctl是驱动层的方法，在linux内核代码中。 继续回到上面的waitForResponse方法在BR_REPLY指令中会读取从驱动读出来的二进制裸数据，然后把二进制解析为binder_transaction_data数据结构，最后保存到mIn这个parcel中，这个跟前面写入到mOut中是一样的数据结构，最后将binder_transaction_data中的输入放到reply这个parcel中，最终客户端也就收到了服务端的数据。 在上面要发起ioctl时候，会把mOut和mIn的首地址填充到binder_write_read中，这样驱动层能直接读取到mOut的数据，在驱动层返回数据的时候，同样道理由于拿到了mIn的地址，所以也能将服务端的数据直接指向了mIn，所以在上面waitForResponse的BR_REPLY能直接解析mIn。\n在上面分析IPCThreadState::transact中如果是one way的请求方式，则调用waitForResponse时候传进入的reply和acquireResult都是null。而在waitForResponse中如果reply和acquireResult为null的时候，如果是BR_TRANSACTION_COMPLETE则直接goto finish，在one way中不会收到BR_REPLY指令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult){ uint32_t cmd; while (1) { //往驱动层写东西 talkWithDriver(); cmd = (uint32_t)mIn.readInt32(); switch (cmd) { case BR_TRANSACTION_COMPLETE: if (!reply \u0026amp;\u0026amp; !acquireResult) goto finish; break; } } return err; } 异步消息时序图：\n同步消息时序图：\n上面就是整个客户端到驱动层的调用流程，客户端到驱动层的流程图如下：\n服务端到驱动层 服务端如何跟驱动层通信，得从zygote初始化的时候说起，在该阶段会启动binder机制，启动过程的最后会开启loop循环，通过调用PoolThread::threadLoop方法，源码地址：/frameworks/native/libs/binder/ProcessState.cpp\n1 2 3 4 5 6 7 8 9 protected: virtual bool threadLoop() { IPCThreadState::self()-\u0026gt;joinThreadPool(mIsMain); return false; } const bool mIsMain; }; server端主要通过binder线程，这个binder线程其实就是new了一个普通的线程，然后再调用了IPCThreadState::self()-\u0026gt;joinThreadPool(mIsMain)这行代码，把这个线程注册到binder驱动，这样他就成为一个binder线程了，接着来看下IPCThreadState的joinThreadPool方法：\n1 2 3 4 5 6 7 8 9 10 11 void IPCThreadState::joinThreadPool(bool isMain) { mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER); status_t result; do { result = getAndExecuteCommand(); } while (result != -ECONNREFUSED \u0026amp;\u0026amp; result != -EBADF); mOut.writeInt32(BC_EXIT_LOOPER); talkWithDriver(false); } 这里省略了其它无关的代码，先是往mOut里面写了一个BC_ENTER_LOOPER或者BC_REGISTER_LOOPER，BC_ENTER_LOOPER表示这个线程是自己主动注册到binder驱动的，BC_REGISTER_LOOPER表示是被动的，由binder先申请，然后由应用来注册。注册成功之后，他在一个while循环里面不停地执行getAndExecuteCommand方法，不停地去取指令、处理指令，这个while循环一般是不会退出的，除非是遇到了什么错误。\n我们接着看getAndExecuteCommand的实现，方法位于/frameworks/native/libs/binder/IPCThreadState.cpp中:\n1 2 3 4 5 6 7 8 9 10 11 status_t IPCThreadState::getAndExecuteCommand() { status_t result; int32_t cmd; result = talkWithDriver(); cmd = mIn.readInt32(); result = executeCommand(cmd); return result; } 通过talkWithDriver从驱动读取请求，这个在前面讲过，主要是通过binder_write_read的数据结构和驱动读和写数据。再就是executeCommand处理这个请求，在处理请求之前要先从mIn里面把指令读出来，然后根据这个指令来执行不同的操作。\n接着看下IPCThreadState::executeCommand方法，位于/frameworks/native/libs/binder/IPCThreadState.cpp中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 status_t IPCThreadState::executeCommand(int32_t cmd) { BBinder* obj; RefBase::weakref_type* refs; status_t result = NO_ERROR; switch ((uint32_t)cmd) { case BR_TRANSACTION: { binder_transaction_data\u0026amp; tr; result = mIn.read(\u0026amp;tr, sizeof(tr)); Parcel buffer; buffer.ipcSetDataReference(...); Parcel reply; reinterpret_cast\u0026lt;BBinder*\u0026gt;(tr.cookie)-\u0026gt;transact(tr.code, buffer, \u0026amp;reply, tr.flags); sendReply(reply, (tr.flags \u0026amp; kForwardReplyFlags)); break; } return result; } 这里根据不同的cmd走到不同的case里面，我们主要关注BR_TRANSACTION这个case，它的意思是说Client把请求发给驱动，驱动再把请求转发给Server端，转发给Server端的时候呢Server端的Binder线程就会收到这个指令BR_TRANSACTION。\n收到指令后，首先把数据从mIn里面读出来，放到binder_transaction_data里面，接着准备两个Parcel，一个buffer一个reply，buffer是要传递给Server端上层的，reply就是上层要回复给Client端的。\nbinder_transaction_data里面有个cookie字段，保存的是Binder实体对象，因为这里是native层，所以cookie就是Binder实体对象在native层的对象，也就是BBinder，获取这个Binder对象。\n接着调用BBinder的transact方法， 把这个请求往上传，往Server端的上层去传。我们看下transact方法的参数，第一个是code，第二是buffer，也就是参数，第三个是reply回复的参数，第四个是flags。\n上层处理完之后就调用sendReply，把这个回复的reply发出去。来看下sendReply实现：\n1 2 3 4 5 6 7 status_t IPCThreadState::sendReply(const Parcel\u0026amp; reply, uint32_t flags) { status_t err; status_t statusBuffer; err = writeTransactionData(BC_REPLY, flags, -1, 0, reply, \u0026amp;statusBuffer); return waitForResponse(nullptr, nullptr); } sendReply的实现中，先调用writeTransactionData方法，把数据写到驱动里面，驱动再转发给Client端，我们需要注意下这里的协议是BC_REPLY；接着调用waitForResponse方法，方法的两个入参都是NULL，跟oneway有点像，表示不用等待对方回复了。\n上面executeCommand中通过BBinder的transact调用服务端的上层，它位于/frameworks/native/libs/binder/Binder.cpp：\n1 2 3 4 5 6 7 8 9 10 11 status_t BBinder::transact( uint32_t code, const Parcel\u0026amp; data, Parcel* reply, uint32_t flags) { status_t err = NO_ERROR; switch (code) { default: err = onTransact(code, data, reply, flags); break; } return err; } 在transact中根据不同的code执行不同的指令，这里走的是default分支，调用的是onTransact方法，BBinder的实际对象是JavaBBinder对象，继续看JavaBBinder::onTransact，源码位于/frameworks/base/core/jni/android_util_Binder.cpp：\n1 2 3 4 5 6 7 8 status_t onTransact( uint32_t code, const Parcel\u0026amp; data, Parcel* reply, uint32_t flags = 0) override { JNIEnv* env = javavm_to_jnienv(mVM); jboolean res = env-\u0026gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact, code, reinterpret_cast\u0026lt;jlong\u0026gt;(\u0026amp;data), reinterpret_cast\u0026lt;jlong\u0026gt;(reply), flags); return res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION; } javavm_to_jnienv方法是根据java的VM拿到当前线程的jni Environment，当前线程是在binder线程池中，拿到之后就可以发起jni调用了。接着发起jni调用，调用了Binder对象的execTransact函数，execTransact函数的源码位于/frameworks/base/core/java/android/os/Binder.java中，在它里面调用了Binder对象的onTransact函数。\n在上面的 gBinderOffsets.mExecTransact 对应了Binder对象的execTransact方法，它是在frameworks/base/core/jni/android_util_Binder.cpp#int_register_android_os_Binder方法中注册的：\n1 2 3 4 5 6 7 8 9 10 11 12 const char* const kBinderPathName = \u0026#34;android/os/Binder\u0026#34;; static int int_register_android_os_Binder(JNIEnv* env) { jclass clazz = FindClassOrDie(env, kBinderPathName); gBinderOffsets.mClass = MakeGlobalRefOrDie(env, clazz); gBinderOffsets.mExecTransact = GetMethodIDOrDie(env, clazz, \u0026#34;execTransact\u0026#34;, \u0026#34;(IJJI)Z\u0026#34;); return RegisterMethodsOrDie( env, kBinderPathName, gBinderMethods, NELEM(gBinderMethods)); } 而我们服务端的binder对象正是aidl生成的Stub内部类，比如在启动activity过程中，实际就是IActivityTaskManager.aidl通过aidl工具编译成的内部类stub，而frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java它是继承自IActivityManager. Stub，所以最终是调用了ActivityManagerService的onTransact方法。\n总结 one way请求方式\n分析完整个流程后，我们再来看下 one way 请求方式，在上面客户端到驱动层请求过程中，在 IPCThreadState::transact 方法中，会通过flags参数判断是不是 one way 请求方式，如果是 one way ，给waitForResponse方法传进去的reply和acquireResult参数都是空，在该方法里面如果收到了BR_TRANSACTION_COMPLETE的时候，也就是驱动层收到了客户端的binder请求，然后给到服务端的回执，在这里面如果reply和acquireResult参数为空，直接退出了waitForResponse的while循环，也就是客户端不进行休眠等待服务端的相应。\nTransactionTooLargeException问题\n再来看开篇讲到的parcel中数据量大的问题，IPCThreadState::writeTransactionData方法中先判断data这个parcel的数据量是否有问题，是通过errorCheck来判断，这个错误信息，是在 write** 等系列方法中调用continueWrite时候，判断是否超过总大小，这个总大小是在ProcessState.cpp中调用mmap内存映射的时候，指定了binder的最大内存位BINDER_VM_SIZE = ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2)。最终这个error一路返回到android_util_Binder.cpp的android_os_BinderProxy_transact方法方法，在该方法里面会调用signalExceptionForError方法，在该方法里面会通过判断错误码是 FAILED_TRANSACTION ，然后通过jni给java层抛出TransactionTooLargeException异常。\n通信协议\n①首先从Client发起一个BC_TRANSACTION，也就是Client向Server端发起一个IPC调用的时候，它首先会向binder驱动写了BC_TRANSACTION指令，binder收到之后会给Client一个回执，也就是BR_TRANSACTION_COMPLETE。\n②回执发完了之后，binder驱动再把这个请求转发给Server端，通过BR_TRANSACTION指令。\n③Server端收到BR_TRANSACTION指令之后去处理这个请求，处理完之后会回复binder驱动，通过BC_REPLY指令。\n④驱动收到Server端的回复之后，也会给Server端一个回执，就是BR_TRANSACTION_COMPLETE指令。\n⑤最后binder驱动再把返回结果转发给Client端，通过BR_REPLY指令。\n⑥需要注意的是，Client在发出请求之后，在等待Server端回复的过程中，Client处于休眠状态。另外Server端应该是Binder线程，Binder线程在处理请求之外的时间也是处于休眠状态的，等着binder驱动发过来的请求。\n最后来一张别人总结的binder分层架构图：\n","date":"2025-03-20T00:00:00Z","permalink":"http://xiangcman.xyz/p/binder%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/","title":"binder通信原理"},{"content":"booster-transform-activity-thread 作用：捕捉异常信息，是抛异常还是捕捉到异常，可以通过捕捉到异常后，上传到服务端 插件入口：ActivityThreadTransformer 通过解析manifest中的application标签，然后在application的onCreate方法最后插入ActivityThreadHooker.hook(\u0026quot;\u0026quot;)方法，其中参数传入的是忽略的包名，获取的是gradle.properties中的booster.transform.activity.thread.packages.ignore配置： 1 booster.transform.activity.thread.packages.ignore=com.demo.cdh.cardswipedemo 在ActivityThreadHooker中获取到ActivityThread类的mH，它是一个handler，然后给它的mCallback替换为ActivityThreadCallback，所以最终会回调到ActivityThreadCallback的handleMessage方法中，该方法会处理各种异常信息，在处理异常的时候，如果不是忽略的包名，则认为是需要处理的异常，然后把该异常抛出去了，交给系统去处理。否则不抛给系统，应用不会崩溃。 理解：在apk构建阶段，它是没有android环境的，所以在transform阶段只是在自定义的application的onCreate方法最后插入了ActivityThreadHooker.hook()方法，在该方法里面构建了ActivityThreadCallback对象，在该对象的构造器中通过重新定义一个和android一样的ActivityThread的包名和类名。所以等到apk运行的时候，通过启动了android的虚拟机，会优先找到系统的ActivityThread类。我可以理解有点偷梁换柱的感觉。 booster-transform-logcat 作用：将系统调用Log.()、e.printStackTrace()、System.out或System.err的方法分别替换成ShadowLog.()、ShadowThrowable.printStackTrace(e:Exception)、ShadowSystem.out或ShadowSystem.err等方法，而这些方法中都是空实现。 插件入口：LogcatTransformer 在transform方法中，通过ClassNode遍历方法，然后在方法的指令中如果遇到opcode是INVOKESTATIC，那么此时的指令是一个MethodInsnNode，如果MethodInsnNode的owner是android/util/Log并且是感兴趣的方法则命中；如果opcode是INVOKEVIRTUAL（java实例的普通方法的调用），此时也是一个MethodInsnNode，获取方法的name是printStackTrace，并且方法的描述是()V，并且通过判断当前owner的class类型是java.lang.throwable的class子类型时就命中；如果opcode是GETSTATIC，并且owner是java/lang/System，方法的name是out或是err时候也命中。 在上面判断当前MethodInsnNode的owner的class类型是java.lang.throwable的class子类型源码分析： 1 context.klassPool.get(THROWABLE).isAssignableFrom(it.owner) context.klassPool.get(THROWABLE)拿到的是一个AbstractKlassPool，它表示的是transform阶段所有已经加载过的class的池子，它是在BoosterTransformInvocation中初始化的，初始化的时候接收compileClasspath和transform.bootKlassPool，其中compileClasspath表示的transform阶段所有的输入class（包括所有transform阶段可以修改和不可修改的输入class和jar文件路径），此处的不可修改表示当前transform识别到的其它插件生成的class，例如dagger2、ButterKnife等。transform.bootKlassPool是获取AndroidExtensions的bootClasspath的路径，然后生成一个AbstractKlassPool，AndroidExtensions的bootClasspath的路径指的是编译时 JDK + Android Framework 的基础类库路径。所以此处有两个AbstractKlassPool，一个是用来表示bootClasspath的父类池子，另外一个就是compileClasspath的池子，bootClasspath的父类池子的classloader指向了compileClasspath的池子的父classloader，此处用到的classloader是一个URLClassLoader，用它是为了和gradle主类加载器避免冲突，能够独立管理项目类路径，支持按需加载类和资源，适应字节码操作需求，隔离Booster内部依赖，防止与项目依赖冲突，允许动态添加插件或模块的类路径。最后加载过的class会放到map中，下次直接拿到该class，最终通过class的isAssignableFrom方法来判断传入的class是否是父class的子类。 booster-transform-shared-preferences ","date":"2025-03-18T00:00:00Z","permalink":"http://xiangcman.xyz/p/booster%E5%85%B6%E4%BB%96%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/","title":"Booster其他插件介绍"},{"content":"平时如果有定制化pdf的时候，一般都是通过有道云笔记来到处pdf，自从用上VScode导出pdf后，发现非常nice。下面记录下整个定制pdf的过程。\n下载插件 在vscode中选择Extensions，并搜索Markdown PDF插件 安装完后，开始通过配置settings.json文件来配置Markdown PDF插件 使用快捷键command+shift+p调起vscode搜索功能，搜索框中输入settings.json settings.json关于markdwon pdf配置如下： 1 2 3 \u0026#34;markdown-pdf.displayHeaderFooter\u0026#34;: false,//不显示页码和页眉 \u0026#34;markdown-pdf.styles\u0026#34;:[\u0026#34;/Users/xiangcheng/desktop/youdao-style.css\u0026#34;],//自定义css \u0026#34;markdown-pdf.breaks\u0026#34;: true//是被br标签用来换行或者空一行 youdao-style.css的配置如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 /* 全局样式 */ body { font-family: \u0026#34;Helvetica Neue\u0026#34;, \u0026#34;Microsoft YaHei\u0026#34;, \u0026#34;Segoe UI\u0026#34;, Arial, sans-serif; font-size: 14px; line-height: 1.5; color: #28262a; margin: 0; padding: 0; } /* 标题样式 */ h1 { font-size: 24px; border-bottom: 2px solid #eee; padding-bottom: 0.3em; } h2 { font-size: 20px; border-bottom: 1px solid #eee; } h3 { font-size: 16px; font-weight: bold; } /* 代码块 */ pre { background-color: #f6f8fa; border-radius: 4px; padding: 12px; overflow: auto; } code { font-family: \u0026#34;Consolas\u0026#34;, \u0026#34;Monaco\u0026#34;, monospace; background-color: rgba(27, 31, 35, 0.05); padding: 0.2em 0.4em; border-radius: 3px; } /* Table styles ripped from Github */ table { display: block; overflow: auto; width: 100%; border-collapse: collapse; border-spacing: 0; } tbody { display: table-row-group; vertical-align: middle; border-color: inherit; } table tr { background-color: #fff; border-top: 1px solid #c6cbd1; } table tr:nth-child(2n) { background-color: #f6f8fa; } table th { font-weight: 600; } table td, table th { border: 1px solid #dfe2e5; padding: 6px 13px; } table tr { background-color: #fff; border-top: 1px solid #c6cbd1; } table tr:nth-child(2n) { background-color: #f6f8fa; } table\u0026gt;thead\u0026gt;tr\u0026gt;th { border-bottom: 0; } /* End of table styles */ /* 列表 */ ul, ol { padding-left: 2em; } li { margin: 0.15em 0; } /* 链接 */ a { color: #3f6bde; text-decoration: none; } /* 图片居中 */ p\u0026gt;img { display: block; margin: 0 auto; } blockquote { border-left: 2px solid #d0d7df; /* 左侧边框颜色 */ background: white; /* 背景色 */ } /* 页面设置 */ @page { size: A4; margin: 5mm; } 使用 打开一个md文件后，然后右键： 参考： https://github.com/yzane/vscode-markdown-pdf youdao-style.css\n","date":"2025-03-18T00:00:00Z","permalink":"http://xiangcman.xyz/p/vscode%E8%87%AA%E5%AE%9A%E4%B9%89pdf/","title":"VScode自定义pdf"},{"content":"bitmap解码方式 解码指的是把图片通过文件读取到内存中，而bitmap正是承载着图片在内存中存储的对象。关于图片的解码方式有如下几种：\nALPHA_8：只存储透明度信息，一个像素占用一个字节，一个字节是8位。所以在在该解码方式下，一个像素是占8位。 ARGB_4444：每个像素占2个字节，也就是16位，其中A占4位，R占4位，G占4位，B占4位（4+4+4+4），支持alpha通道 从API13开始不推荐使用，在android4.4上面，设置的ARGB_4444会被系统使用ARGB_8888替换 ARGB_8888：bitmap编码的默认方式，每像素占4字节，每个通道分别占8位 RGB_565：每像素占用2字节，RGB分别占5，6，5位，不支持alpha通道 参考：https://www.ieclipse.cn/2017/06/14/Android/Android-bitmap-config/ 上面提到的RGB_565解码方式，为什么是5,6,5呢？ RGB_565 是早期 Android 在 内存限制、渲染效率、视觉质量 三者间找到的平衡点。随着设备硬件提升，更高精度的格式（如 ARGB_8888）逐渐成为默认选项，但在特定优化场景中，RGB_565 仍是一个有效的省内存方案。 测试各种解码方式 对于带有透明的图片：在ALPHA_8下，它是只有透明信息，但是他占用的大小还是一个像素占4个字节，并且展示的图片和ARGB_8888一样的。RGB_565是不带透明通道的，但是带有透明度的图片还是能呈现透明样式的，并且占用内存和ARGB_8888一样的。 对于非透明的图片：RGB_565下内存占用是ARGB_8888的一半。在ALPHA_8下面展示的图片所占用的字节大小和ARGB_8888是一样的。 关于这块为什么带有透明的图片在alpha_8下还是和argb_8888下面一样的，下面文章有讲解： https://juejin.cn/post/7059206294959292452 测试了下带透明的图片使用RGB_565的时候，发现解码生成的bitmap的config还是ARGB_8888，说明系统还是会选择合适的颜色模式来解码，通过如下获取最终的解码方式： bitmap压缩 1.采样率压缩：设置BitmapFactory.Options.inSampleSize，值越大，对应的宽高的像素值越小，如果inSampleSize=2，则内存是原来的4分支1了，因为宽高各减少2倍 2.设置编码格式：BitmapFactory.Options.inPreferredConfig，一般设置有RGB_565，ARGB_8888，RGB_565的时候忽略了透明通道。 3.质量压缩：质量压缩不改变图片的像素，改变图片的位深和透明度，适合二进制图片数据，常见的有PNG、JPEG、WEBP压缩算法。其中PNG压缩算法称为无损压缩，基本不会改变图片占用文件的大小，JPEG会根据quality参数来实现压缩。 经过测试：在PNG压缩算法下，图片不会改变，因此被称为无损压缩\n在JPEG压缩算法下，如果是带有透明的图片，由于会忽略透明度，因此会显示成黑色。并且发现保存到本地的文件大小会增大，但是二进制的byte数会随着quality变小而变小。因此带有透明的图片慎用\nweb压缩算法是一种有损压缩，webp图像的体积要比jpeg格式图像小40%，但是webp的编码时间比jpeg格式长8倍。 https://juejin.cn/post/6844903725081821198#heading-12\nbitmap内存获取 bitmap的宽（像素个数）*bitmap的高（像素个数）*每个像素所占用的内存 bitmap的实际宽： 图片的真实宽*设备的densityDpi/图片所在的drawable的densityDpi 设备的densityDpi:最终会赋值到上BitmapFactory.Options.inTargetDensity，通过如下方式获取设备的densityDpi： 图片所在的drawable的densityDpi：最终会设置到BitmapFactory.Options.inDensity上，通过如下方式获取： 关于设备的dpi和drawable的dpi可以跟着源码看下： 1 2 3 4 5 6 7 8 9 10 public static Bitmap decodeResource(Resources res, int id, Options opts) { Bitmap bm = null; InputStream is = null; //获取图片所在drawable的dpi final TypedValue value = new TypedValue(); is = res.openRawResource(id, value); bm = decodeResourceStream(res, value, is, null, opts); return bm; } 上面逻辑是如果没获取到drawable的density，那么就设置为160，否则直接给Options.inDensity设置为density。然后将设备的density设置到Options.inTargetDensity。\n接着调用了decodeStream方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Nullable public static Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts) { validate(opts); Bitmap bm = null; try { //如果是asset目录中的图片，则走if if (is instanceof AssetManager.AssetInputStream) { final long asset = ((AssetManager.AssetInputStream) is).getNativeAsset(); bm = nativeDecodeAsset(asset, outPadding, opts, Options.nativeInBitmap(opts), Options.nativeColorSpace(opts)); } else { //如果是drawable目录下的图片，则走这里 bm = decodeStreamInternal(is, outPadding, opts); } setDensityFromOptions(bm, opts); return bm; } 可以看到如果是drawable目录下的图片，则走decodeStreamInternal：\n1 2 3 4 5 6 7 8 9 10 11 12 private static Bitmap decodeStreamInternal(@NonNull InputStream is, @Nullable Rect outPadding, @Nullable Options opts) { // ASSERT(is != null); byte [] tempStorage = null; if (opts != null) tempStorage = opts.inTempStorage; if (tempStorage == null) tempStorage = new byte[DECODE_BUFFER_SIZE]; return nativeDecodeStream(is, tempStorage, outPadding, opts, Options.nativeInBitmap(opts), Options.nativeColorSpace(opts)); } private static native Bitmap nativeDecodeStream(InputStream is, byte[] storage, Rect padding, Options opts, long inBitmapHandle, long colorSpaceHandle); 最终会调用nativeDecodeStream方法，此处通过aosp来查看源码，该c++代码在/frameworks/base/libs/hwui/jni/BitmapFactory.cpp下，找到cpp文件后，然后再看c++层的方法注册：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 static const JNINativeMethod gMethods[] = { { \u0026#34;nativeDecodeStream\u0026#34;, \u0026#34;(Ljava/io/InputStream;[BLandroid/graphics/Rect;Landroid/graphics/BitmapFactory$Options;JJ)Landroid/graphics/Bitmap;\u0026#34;, (void*)nativeDecodeStream }, { \u0026#34;nativeDecodeFileDescriptor\u0026#34;, \u0026#34;(Ljava/io/FileDescriptor;Landroid/graphics/Rect;Landroid/graphics/BitmapFactory$Options;JJ)Landroid/graphics/Bitmap;\u0026#34;, (void*)nativeDecodeFileDescriptor }, { \u0026#34;nativeDecodeAsset\u0026#34;, \u0026#34;(JLandroid/graphics/Rect;Landroid/graphics/BitmapFactory$Options;JJ)Landroid/graphics/Bitmap;\u0026#34;, (void*)nativeDecodeAsset }, { \u0026#34;nativeDecodeByteArray\u0026#34;, \u0026#34;([BIILandroid/graphics/BitmapFactory$Options;JJ)Landroid/graphics/Bitmap;\u0026#34;, (void*)nativeDecodeByteArray }, { \u0026#34;nativeIsSeekable\u0026#34;, \u0026#34;(Ljava/io/FileDescriptor;)Z\u0026#34;, (void*)nativeIsSeekable }, }; 此处对应到第一个方法nativeDecodeStream：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static jobject nativeDecodeStream(JNIEnv* env, jobject clazz, jobject is, jbyteArray storage, jobject padding, jobject options, jlong inBitmapHandle, jlong colorSpaceHandle) { jobject bitmap = NULL; std::unique_ptr\u0026lt;SkStream\u0026gt; stream(CreateJavaInputStreamAdaptor(env, is, storage)); if (stream.get()) { std::unique_ptr\u0026lt;SkStreamRewindable\u0026gt; bufferedStream(skia::FrontBufferedStream::Make( std::move(stream), SkCodec::MinBufferedBytesNeeded())); SkASSERT(bufferedStream.get() != NULL); bitmap = doDecode(env, std::move(bufferedStream), padding, options, inBitmapHandle, colorSpaceHandle); } return bitmap; } JNIEnv* env 作用\nJNIEnv 是 JNI 环境指针，提供所有 JNI 函数（如调用 Java 方法、操作 Java 对象等）的接口。 它是线程相关的，每个线程的 JNIEnv 独立，不可跨线程使用。 关键功能\n访问 Java 对象：例如通过 GetFieldID、GetMethodID 获取字段或方法。 调用 Java 方法：例如 CallVoidMethod、CallStaticIntMethod。 异常处理：例如 ExceptionCheck、ExceptionDescribe。 内存管理：例如 NewStringUTF 创建字符串，DeleteLocalRef 释放局部引用。 jobject clazz 作用 如果本地方法是 静态方法（static），jobject clazz 表示调用该方法的 Java 类对象（对应 Class 对象）。 如果本地方法是 实例方法（非静态），参数应为 jobject thiz，表示调用该方法的 Java 对象实例。 可以看到调用了另外一个静态方法doDecode： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 static jobject doDecode(JNIEnv* env, std::unique_ptr\u0026lt;SkStreamRewindable\u0026gt; stream, jobject padding, jobject options, jlong inBitmapHandle, jlong colorSpaceHandle) { // Set default values for the options parameters. int sampleSize = 1; bool onlyDecodeSize = false; SkColorType prefColorType = kN32_SkColorType; bool isHardware = false; bool isMutable = false; float scale = 1.0f; bool requireUnpremultiplied = false; jobject javaBitmap = NULL; sk_sp\u0026lt;SkColorSpace\u0026gt; prefColorSpace = GraphicsJNI::getNativeColorSpace(colorSpaceHandle); // Update with options supplied by the client. if (options != NULL) { sampleSize = env-\u0026gt;GetIntField(options, gOptions_sampleSizeFieldID); // Correct a non-positive sampleSize. sampleSize defaults to zero within the // options object, which is strange. if (sampleSize \u0026lt;= 0) { sampleSize = 1; } if (env-\u0026gt;GetBooleanField(options, gOptions_scaledFieldID)) { //获取图片所在文件夹的density const int density = env-\u0026gt;GetIntField(options, gOptions_densityFieldID); //获取屏幕所在的density const int targetDensity = env-\u0026gt;GetIntField(options, gOptions_targetDensityFieldID); const int screenDensity = env-\u0026gt;GetIntField(options, gOptions_screenDensityFieldID); if (density != 0 \u0026amp;\u0026amp; targetDensity != 0 \u0026amp;\u0026amp; density != screenDensity) { //得到bitmap的缩放比例 scale = (float) targetDensity / density; } } } // Determine the output size. //得到bitmap的大小 SkISize size = codec-\u0026gt;getSampledDimensions(sampleSize); int scaledWidth = size.width(); int scaledHeight = size.height(); bool willScale = false; // Apply a fine scaling step if necessary. if (needsFineScale(codec-\u0026gt;getInfo().dimensions(), size, sampleSize)) { willScale = true; scaledWidth = codec-\u0026gt;getInfo().width() / sampleSize; scaledHeight = codec-\u0026gt;getInfo().height() / sampleSize; } // Scale is necessary due to density differences. //根据前面算的缩放比例，得到最终的bitmap大小 if (scale != 1.0f) { willScale = true; scaledWidth = static_cast\u0026lt;int\u0026gt;(scaledWidth * scale + 0.5f); scaledHeight = static_cast\u0026lt;int\u0026gt;(scaledHeight * scale + 0.5f); } //算出最终的缩放比例 const float scaleX = scaledWidth / float(decodingBitmap.width()); const float scaleY = scaledHeight / float(decodingBitmap.height()); SkBitmap outputBitmap; if (willScale) { // Set the allocator for the outputBitmap. SkBitmap::Allocator* outputAllocator; if (javaBitmap != nullptr) { outputAllocator = \u0026amp;recyclingAllocator; } else { //最终的数据在outputAllocator中 outputAllocator = \u0026amp;defaultAllocator; } SkColorType scaledColorType = decodingBitmap.colorType(); // FIXME: If the alphaType is kUnpremul and the image has alpha, the // colors may not be correct, since Skia does not yet support drawing // to/from unpremultiplied bitmaps. outputBitmap.setInfo( bitmapInfo.makeWH(scaledWidth, scaledHeight).makeColorType(scaledColorType)); if (!outputBitmap.tryAllocPixels(outputAllocator)) { // This should only fail on OOM. The recyclingAllocator should have // enough memory since we check this before decoding using the // scaleCheckingAllocator. return nullObjectReturn(\u0026#34;allocation failed for scaled bitmap\u0026#34;); } SkPaint paint; // kSrc_Mode instructs us to overwrite the uninitialized pixels in // outputBitmap. Otherwise we would blend by default, which is not // what we want. paint.setBlendMode(SkBlendMode::kSrc); //最终解码的bitmap在outputBitmap上 SkCanvas canvas(outputBitmap, SkCanvas::ColorBehavior::kLegacy); //使用最终的缩放比例 canvas.scale(scaleX, scaleY); decodingBitmap.setImmutable(); // so .asImage() doesn\u0026#39;t make a copy canvas.drawImage(decodingBitmap.asImage(), 0.0f, 0.0f, SkSamplingOptions(SkFilterMode::kLinear), \u0026amp;paint); } Bitmap* heapBitmap = defaultAllocator.getStorageObjAndReset(); if (hasGainmap \u0026amp;\u0026amp; heapBitmap != nullptr) { heapBitmap-\u0026gt;setGainmap(std::move(gainmap)); } uirenderer::logBitmapDecode(*heapBitmap); // now create the java bitmap //创建bitmap return bitmap::createBitmap(env, heapBitmap, bitmapCreateFlags, ninePatchChunk, ninePatchInsets, -1); } decode中就是关于bitmap的缩放处理，根据option中的targetDensity/density，也就是屏幕的density/drawable的density得到scale，然后根据原始尺寸再乘以该scale得到最终的宽高像素。\n关于底层如何解析图片的解码方式，可以接着上面分析分析BitmapFactory.cpp的doDecode时候调用的，在doDecode时候有这么两句：\n1 2 3 SkColorType prefColorType = kN32_SkColorType; prefColorType = GraphicsJNI::getNativeBitmapColorType(env, jconfig); SkColorType decodeColorType = codec-\u0026gt;computeOutputColorType(prefColorType); 首先默认定义了prefColorType为kN32_SkColorType，然后调用了getNativeBitmapColorType方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 SkColorType GraphicsJNI::getNativeBitmapColorType(JNIEnv* env, jobject jconfig) { ALOG_ASSERT(env); if (NULL == jconfig) { return kUnknown_SkColorType; } ALOG_ASSERT(env-\u0026gt;IsInstanceOf(jconfig, gBitmapConfig_class)); //获取到java层BitmapFactory.Options中的inPreferredConfig（Bitmap.Config）的nativeInt值 int c = env-\u0026gt;GetIntField(jconfig, gBitmapConfig_nativeInstanceID); return legacyBitmapConfigToColorType(c); } SkColorType GraphicsJNI::legacyBitmapConfigToColorType(jint legacyConfig) { const uint8_t gConfig2ColorType[] = { kUnknown_SkColorType, kAlpha_8_SkColorType, kUnknown_SkColorType, // Previously kIndex_8_SkColorType, kRGB_565_SkColorType, kARGB_4444_SkColorType, kN32_SkColorType, kRGBA_F16_SkColorType, kN32_SkColorType, kRGBA_1010102_SkColorType, }; if (legacyConfig \u0026lt; 0 || legacyConfig \u0026gt; kLastEnum_LegacyBitmapConfig) { legacyConfig = kNo_LegacyBitmapConfig; } return static_cast\u0026lt;SkColorType\u0026gt;(gConfig2ColorType[legacyConfig]); } 在getNativeBitmapColorType方法中获取到BitmapFactory.Options中的inPreferredConfig（Bitmap.Config）的nativeInt值，然后传给了legacyBitmapConfigToColorType，在该方法中获取到对应的SkColorType，其实就是将在java层Bitmap.Config枚举中定义的nativeInt，映射到gConfig2ColorType数组中，然后对应获取到c++层的SkColorType枚举。对应关系如下\njava层 c++层 ALPHA_8 kAlpha_8_SkColorType RGB_565 kRGB_565_SkColorType ARGB_4444 kARGB_4444_SkColorType ARGB_8888 kN32_SkColorType RGBA_F16 kRGBA_F16_SkColorType HARDWARE kN32_SkColorType RGBA_1010102 kRGBA_1010102_SkColorType 获取到SkColorType后，接着调用了SkAndroidCodec的computeOutputColorType方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 SkColorType SkAndroidCodec::computeOutputColorType(SkColorType requestedColorType) { //如果每个颜色分量的位数超过8位，就认为是高精度 bool highPrecision = fCodec-\u0026gt;getEncodedInfo().bitsPerComponent() \u0026gt; 8; //从编码信息中获取颜色深度（例如 8-bit、10-bit） uint8_t colorDepth = fCodec-\u0026gt;getEncodedInfo().getColorDepth(); switch (requestedColorType) { //如果是kARGB_4444_SkColorType，直接返回kN32_SkColorType（ARGB_8888） //原因：ARGB_4444 格式已过时，现代设备更倾向使用 32 位格式（兼容性/性能优化）。 case kARGB_4444_SkColorType: return kN32_SkColorType; //如果是kN32_SkColorType，直接不处理 case kN32_SkColorType: break; case kAlpha_8_SkColorType: case kGray_8_SkColorType: //若当前图像颜色类型为 kGray_8，返回 kGray_8，否则跳过 //kAlpha_8 旧版本中可能用于灰度图，现需兼容性处理 //仅当原始图像为灰度时，才返回 kGray_8（避免无效转换） if (kGray_8_SkColorType == this-\u0026gt;getInfo().colorType()) { return kGray_8_SkColorType; } break; case kRGB_565_SkColorType: //若图像不透明（alphaType == kOpaque），返回 kRGB_565 //RGB_565 不支持透明度，仅适用于不透明图像 if (kOpaque_SkAlphaType == this-\u0026gt;getInfo().alphaType()) { return kRGB_565_SkColorType; } break; case kRGBA_1010102_SkColorType: //若颜色深度为 10-bit，返回 kRGBA_1010102，颜色深度表示每个通道占10位，如果是RGB的话，则是30位的二进制，如果是ARGB的话，则是40位的二进制 //10-bit 深度匹配该格式的高精度需求 if (colorDepth == 10) { return kRGBA_1010102_SkColorType; } break; case kRGBA_F16_SkColorType: //强制高精度浮点格式，每一个颜色通道是16位，如果是RGB的话，则是48位的二进制 return kRGBA_F16_SkColorType; default: break; } //如果高进度的则返回kRGBA_F16_SkColorType，如果位深是10的话，则返回kRGBA_1010102_SkColorType，其余的都返回kN32_SkColorType return highPrecision ? kRGBA_F16_SkColorType : (colorDepth == 10 ? kRGBA_1010102_SkColorType : kN32_SkColorType); } 这也就解释了在RGB_565解码方式下，如果是带透明的图片，直接使用kN32_SkColorType的解码方式，也就是ARGB_8888。默认的解码方式，如果是不带透明的图片，则使用的是RGB_565。如果使用的是ALPHA_8，不是灰度图像的时候，使用的是ARGB_8888。\n关于drawable的densityDpi的值如下： 结论：图片所占内存和drawable的densityDpi成反比。\n来源：https://juejin.cn/post/6844904166138069005\nbitmap内存分配： 8.0之前的Bitmap像素数据基本存储在Java heap 8.0之后的 Bitmap像素数据基本存储在native heap 参考：https://juejin.cn/post/6844903608887017485\nbitmap像素分配： 参考：https://juejin.cn/post/6844903715766272013\n","date":"2025-03-11T00:00:00Z","permalink":"http://xiangcman.xyz/p/bitmap%E6%80%BB%E7%BB%93/","title":"bitmap总结"},{"content":"设计原则 开闭原则 主要指对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节。 优点：保持软件的稳定性，不影响原有业务逻辑代码。使代码更具有模块化，易于维护。提高开发效率。 来源：https://segmentfault.com/a/1190000021922108 里式替换原则 所有引用基类的地方必须能透明地使用其子类的对象 原则：子类必须实现父类的抽象方法，不得重写父类的非抽象方法 子类可以增加自己特有的方法 子类在实现父类的方法的时候，形参要比父类的参数更加宽松。 子类实现父类的方法的时候，出参要比父类更加严格。 依赖倒置原则 高层模块不应该直接依赖底层模块，二者应该依赖抽象，抽象不应该依赖细节，细节应该依赖抽象。 比如A类是接口，B类是实现，而C类要使用B类，那么C类不能直接使用B类，而是通过依赖A接口来实现，这样将使用谁的权交给了外界。C类更加的灵活 单一职业原则 一个类或者模块只负责完成一个职责。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。 接口隔离原则 尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。和单一职责原则相比，他们都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想。两者不同在于单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。单一职责原则主要是约束类，它针对的是程序中的实现和细节。接口隔离原则主要是约束接口，主要针对抽象和程序整体框架的构建。 迪米特法则 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用，目的是降低类之间的耦合度，提高模块的相对独立性。由于亲合度降低，从而提高了类的可复用率和系统的扩展性。 比如A类想调用B类，但是他们又没有直接联系，而通过中间的C类来调用B类。A-\u0026gt;C-\u0026gt;B这种调用关系 合成复用原则 要求在软件复用时，尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用集成关系来实现。采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，从而新对象可以调用已有对象的功能。 维持了类的封装性，因为成分对象的内部细节是新对象看不见的，这种复用称为黑箱复用。 新旧类之间的耦合度低，这种复用所需的依赖较少，新对象存储成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 设计模式 设计模式分为创建型、结构型、行为型。 创建型：用于对象的创建，提高代码的灵活性和复用性 设计模式 描述 工厂方法模式（Factory Method） 通过工厂类提供一个创建对象的接口，而不是直接 new 一个对象，提高代码的可扩展性。 抽象工厂模式（Abstract Factory） 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。 单例模式（Singleton） 确保一个类只有一个实例，并提供一个全局访问点。 建造者模式（Builder） 用于创建复杂对象，将对象的构建与表示分离，以便相同的构建过程可以创建不同的表示。 原型模式（Prototype） 通过复制（克隆）已有的实例来创建新对象，而不是通过实例化。 结构型模式：主要用于类与对象的组合，确保系统的结构更加灵活和高效。 设计模式 描述 适配器模式（Adapter） 让原本不兼容的接口能够协同工作，相当于“转换器”。 桥接模式（Bridge） 分离抽象部分和实现部分，使它们可以独立变化，提高可扩展性。 装饰器模式（Decorator） 通过动态地给对象增加额外的功能，而不会改变其结构（类似于 Java 的 IO 流）。 组合模式（Composite） 允许将对象组合成树形结构，以表示“整体-部分”关系，适用于树形结构数据。 外观模式（Facade） 提供一个统一的接口，用于访问子系统的一组接口，简化客户端的调用。 享元模式（Flyweight） 通过共享对象，减少内存占用，提高性能。 代理模式（Proxy） 通过代理对象控制对目标对象的访问，例如：静态代理、动态代理（JDK/CGLIB）。 行为型模式：主要用于对象之间的通信和职责分配，提高代码的可维护性和可扩展性。 设计模式 描述 策略模式（Strategy） 定义一系列算法，将每种算法封装起来，并使它们可以互换。 观察者模式（Observer） 允许对象间建立一对多的依赖关系，当一个对象状态变化时，所有依赖它的对象都会收到通知（如 监听器 机制）。 责任链模式（Chain of Responsibility） 将请求沿着处理链传递，直到某个对象处理请求，降低耦合度（如 Java Web 过滤器）。 命令模式（Command） 将请求封装为对象，支持请求的撤销（Undo）和恢复（Redo）。 备忘录模式（Memento） 保存对象的历史状态，以便以后恢复（如 撤销/恢复 操作）。 状态模式（State） 允许对象在不同状态下改变行为，避免大量 if-else 语句。 中介者模式（Mediator） 通过一个中介对象来协调多个对象之间的交互，避免对象间的直接通信。 迭代器模式（Iterator） 提供一种访问集合对象元素的方法，而不暴露集合的内部表示。 访问者模式（Visitor） 允许在不修改对象结构的情况下，向对象结构中添加新的行为（如 XML 解析）。 解释器模式（Interpreter） 用于定义语言的语法规则，并解释相应的表达式（如 SQL 解析）。 单例模式 饿汉式：类加载时机就已经把单例对象实例化出来了，所以他不存在线程安全问题。但是它会浪费内存，在还没使用的时候，就已经创建了实例。 懒汉式（线程不安全） 创建对象的时机修改为了在getInstance内部，需要时再创建，可以节约系统资源。 getInstance方法在多个线程并发调用时，有可能会出现创建了多个实例，所以这是线程不安全的单例模式。 懒汉式（线程安全） 方法上加锁，这种加锁能保证线程安全问题，但是加锁的粒度较大，每次在调用getInstance方法的时候，都需要加锁，很显然，锁的开销很大。 懒汉式（线程安全-dcl模式） 双重判断，成员属性instance上，增加了volatile关键字，保障多线程对instance值的可见性以及禁止指令重排。 第一层空判断是为了锁的开销，只有为空的时候才加锁。第二层空判断是为了防止创建了多个实例。 静态内部类中加静态变量 静态内部类可以达到双检锁的效果。将instance放在了内部类中，不会在类加载的时候就加载实例，这个和饿汉式在类加载的时候就加载有区别。他只会在getInstance的时候，才会去加载内部类，此时才会去加载单例实例。并且instance是内部类类加载的时候才进行加载，所以线程安全问题也保证了。 枚举单例 这种不仅能避免多线程同步问题，还自动支持序列化机制，防止反序列化重新创建新的对象，防止多次实例化。 原型模式 Java原型模式（Prototype Pattern）是一种创建型设计模式，其目的是通过复制现有对象来创建新的对象。 使用场景： 当对象创建的过程比较耗时或者比较复杂，例如需要进行复杂的计算或者涉及到网络请求等操作，可以使用原型模式来避免重复的初始化过程。 当需要创建的对象需要和其他对象进行协同工作时，例如需要创建一个包含多个对象的组合对象，可以使用原型模式来复制一个已有的组合对象，然后进行修改来创建新的组合对象。 当需要动态地增加或者删除一些对象时，可以使用原型模式来复制一个已有的对象，然后进行修改来创建新的对象。 当需要保护对象的复杂状态时，例如当一个对象的创建需要大量的数据初始化时，可以使用原型模式来保护这些数据，避免因为对象的复制而产生意外的副作用。 代码实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 定义一个原型接口 interface Prototype { public Prototype clone(); } // 具体的原型类 class ConcretePrototype implements Prototype { public Prototype clone() { return new ConcretePrototype(); } } // 客户端代码 class Client { public static void main(String[] args) { Prototype prototype = new ConcretePrototype(); Prototype clone = prototype.clone(); } } 使用小结： Java中的Object类实现了Cloneable接口，这就意味着Java中的任何对象都可以实现原型模式。通过实现Cloneable接口，并重写Object类中的clone()方法，可以实现原型模式。例如 ArrayList、HashMap 等集合类都实现了Cloneable 接口，可以通过复制现有对象来创建新的对象。 Java中的线程池也是使用了原型模式，线程池中的每个线程都是从原型线程中复制而来，而不是每次创建新的线程。 工厂模式 分为简单工厂模式、工厂方法模式、抽象工厂模式。定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的创建与使用相分离。创建型模式可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。\n简单工厂模式 简单工厂类会很庞大，负责创建所有产品的创建，如果要新增产品类，会修改工厂类，违背了开闭原则。并且违背了高聚合原则。 工厂方法模式\n在简单工厂类基础上将工厂类也进行抽象化，每个工厂类只做一件事，那就是生产对应的对象，保证了单一职责原则，并且保证了开闭原则，如果要生产不同的对象，只需要提供对应的工厂实现类就可以。 抽象工厂模式\n和上面的工厂方法模式差不多，也是有对应的工厂实现类，区别是工厂类能生产不同级别的产品。 建造者模式 将一个复杂对象的构建与它的表示分离，使同样的构建过程可以创建不同的表示。将一个复杂对象进行一步步的构建而成，扩展性好，可以灵活配置的属性，来生成不同的对象。 构建指的是对象的创建过程，通过一步步组装的形式最终创建对象，而客户端在此过程中只需要提供组装的属性，而无需关心组装的过程 表示指的是对象创建完后的形态或结构，创建完后，对象就形成不可变的结构。此时客户端可以放心使用该对象。 静态代理模式 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用。 代理对象可以扩展目标对象的功能 其中静态代理要求代理类和被代理类实现同样的接口，旨在想扩展被代理类的某些功能，比如想添加些日志等行为 动态代理模式 动态代理模式和静态代理模式的区别是，静态代理在编译期就已经确定了代理类和被代理类的关系，而动态代理是在运行时通过Proxy创建了代理类，在代理类中通过反射动态调用了InvokeHandler接口的实现类的invoke方法，最后在invoke中统一调用被代理类的方法。\n总结： 代理模式主要是通过代理类来控制对象的访问，主要涉及到访问权限、延迟加载、日志记录。比如有一个用户角色权限比较低，不能访问数据库，此时在调用对象的时候，判断权限而抛异常。再者比如在代理类中，可以延迟初始化被代理类。再比如可以通过日志记录被代理类的访问。\n适配器模式 将一个类的接口转换成客户希望的另外一个接口，使得原本是由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式。类结构型模式的耦合度比后者高。 优点：客户端通过适配器可以透明地调用目标接口，复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。 角色：目标类，它是真正被调用的类；适配者类，它是被访问和适配的现存组件库中的组件接口；适配器类：它是一个转换器，把适配者接口转换成目标接口，让客户能通过适配者调用目标接口。 类适配器模式： 在上面Adaptee是业务要被适配的类，适配器类ClassAdapter通过继承自Adaptee和被适配器类耦合，不方便扩展，最好的方案是将被适配器类交给调用方自己传进来。 对象适配器模式： 从这里可以看出，对象适配模式更加的符合开闭原则，并且更加容易扩展。 桥接模式 强调的是抽象与实现分离，使它们可以独立变化。使用组合关系代替继承关系来实现。降低了抽象和实现两个可变维度的耦合度。和上面适配器模式不同，这里强调的是多种抽象的组合。它是有以下角色： 抽象化角色：定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化角色：定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化角色：给出实现化角色接口的具体实现。 实现化角色在这里是依附于抽象化角色上的，也就是最终是被扩展化角色所使用。 上面的color是一个实现化角色，其中具体实现化角色分为红色和黄色。抽象化角色是Bag类，它的扩展抽象化角色有Wallet和HandBag。他们使用了color这个实现化角色。 装饰者模式 在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。 有以下角色： 抽象构件角色：定义一个抽象接口以规范准备接收附加责任的对象。 具体构件角色：实现抽象构件，通过装饰角色为其添加一些职责。 抽象装饰角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。 具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。 上面ConcreteDecorator是具体的的装饰角色，它是持有了具体的构件角色ConcreteComponent，在调用具体的构建角色方法外，还调用了自己的另外一个方法，这个是和桥接模式的一个区别之处。并且装饰者模式的抽象的装饰角色实现了抽象构件角色，但是桥接模式中，抽象化构件角色中是不实现实现化角色接口的。 外观模式 是迪米特法则的体现，比如一个系统想调用子系统的某个方法的时候，为了降低客户端调用系统的时候，将调用子系统的方法，通过统一的中心来调用子系统。分为以下角色： 享元模式 相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。 具体有如下角色： 抽象享元角色：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。 具体享元角色：实现抽象享元角色中所规定的接口。 非享元角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。 享元工厂角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。 上面享元工厂通过key来管理不同的享元角色，而享元角色持有了非享元角色的接口引用。上面例子中前3次获取的是同一个享元角色，后两次获取的是同一个享元角色。 参考： Java常用设计模式(一) Java常用设计模式(二) Java常用设计模式(三) ","date":"2025-03-07T00:00:00Z","permalink":"http://xiangcman.xyz/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/","title":"java设计原则与模式"},{"content":"在看booster内联R的时候，看到过滤R$color这种内部类的时候，是通过正则表达式进行过滤的，然后它的匹配规则是：\n1 2 internal const val R_REGEX = \u0026#34;.*/R\\\\\\$.*|.*/R\\\\.*\u0026#34; Pattern.matches(R_REGEX, klass.name) 我是想匹配到com/xc/lib/R$color或com/xc/lib/R形如这种class的名字，第一眼看的时候有点懵，然后通过查看正则表达式的语法时候，发现正则是有规律可循的，先看一张表格：\n符号 含义 示例 . 匹配任意单个字符（除换行符） a.b 可匹配 acb、a1b \\d 数字 (0-9) \\d{3} 匹配 123 \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\w 单词字符 (a-z, A-Z, 0-9, _)，匹配单词、数字、下划线 \\w+ 匹配 abc_123 \\W 匹配非字母、数字、下划线 b\\Wt 可以匹配b#t / b@t等，但不能匹配but / b1t / b_t等 \\s 空白字符（空格、Tab、换行） Hello\\sWorld 匹配 Hello World \\S 单个非空白字符 任意单个非空格字符都匹配 \\b 单词边界 \\bcat\\b 仅匹配 cat，不匹配 catalog ^ 行首 ^Hello 仅匹配 Hello 在行首的情况 $ 行尾 end$ 仅匹配 end 在行尾的情况 * 匹配前一个字符 0 次或多次 ab*c 可匹配 ac、abc、abbc + 匹配前一个字符 1 次或多次 ab+c 仅匹配 abc、abbc，不匹配 ac ? 匹配前一个字符 0 次或 1 次 ab?c 可匹配 ac 或 abc {n} 匹配 n 次 a{3} 仅匹配 aaa {n,} 至少匹配 n 次 a{2,} 可匹配 aa、aaa {n,m} 匹配 n 到 m 次 a{2,4} 可匹配 aa、aaa、aaaa [] 字符集合 [aeiou] 匹配任意元音字母 ` ` 或（匹配左边或右边） () 分组 (ab)+ 匹配 ab、abab 上面\u0026quot;.*/R\\\\\\$.*|.*/R\\\\.*\u0026quot;可以拆解成两个正则，因为中间用了一个或，分别是.*/R\\\\\\$.*、.*/R\\\\.*，首先来看.*/R\\\\\\$.*它可以分解成:\n字符 含义 匹配字符 .* 表示有0次或多次的单个字符 com/xc/lib /R 直接匹配字符 /R \\$ 这里由于和$有冲突，所以前面加了转义，匹配的是$字符 $ .* 和开头的匹配一样，表示有0次或多次的单个字符 color 所以最终com/xc/lib/R$color能被匹配到，再来看.*/R\\\\.*它可以分解成：\n字符 含义 匹配字符 .* 表示有0次或多次的单个字符 com/xc/lib /R 直接匹配字符 /R \\.* 这里由于和.有冲突，所以前面加了转义，匹配的是0次或多次的.字符 . 所以最终com/xc/lib/R也能被匹配到。\n更多正则的匹配： 测试用例： #key_mmkv_migrate_version# ，正则表达式(#[^#]*[^#\\\\s]+[^#]*#)，使用\n1 2 Pattern pattern = Pattern.compile(\u0026#34;(#[^#]*[^#\\\\s]+[^#]*#)\u0026#34;); Matcher matcher = pattern.match(\u0026#34;#key_mmkv_migrate_version# \u0026#34;) 该正则表达式作用：用于匹配 以 # 开头和结尾的内容，并且内容中至少包含 一个非空白的非 # 字符。 正则解析：\n部分 含义 # 匹配 #（开始） [^#]* 匹配任意多个非 # 的字符（0 次或多次） [^#\\s]+ 至少匹配 1 个非 # 和非空格的字符（保证内容不是空的） [^#]* 再次匹配任意多个非 # 的字符（0 次或多次） # 匹配 #（结束） (\u0026hellip;) 括号用于捕获匹配内容 Matcher#replaceAll方法\n1 matcher.replaceAll(\u0026#34;\u0026lt;a type=\u0026#34;topic\u0026#34; \u0026gt;$1\u0026lt;/a\u0026gt;\u0026#34;) 会被替换成如下： \u0026lt;a type=\u0026quot;topic\u0026quot; \u0026gt;#key_mmkv_migrate_version#\u0026lt;/a\u0026gt; 正则: \u0026lt;a[^\u0026gt;]*?((\u0026gt;[\\s\\S]*?\u0026lt;/a\u0026gt;)|(/\u0026gt;))\n1 2 @kotlin.internal.InlineOnly public inline fun String.toRegex(): Regex = Regex(this) 将string转化成Regex:\n1 2 val regexStr = `\u0026lt;a[^\u0026gt;]*?((\u0026gt;[\\s\\S]*?\u0026lt;/a\u0026gt;)|(/\u0026gt;))` val regex = regexStr.toRegex() 用于 匹配 HTML 标签（包括自闭合 和 **带内容的 \u0026hellip; 形式）。 正则解析：\n部分 含义 \u0026lt;a 匹配 \u0026lt;a（开始的 标签） [^\u0026gt;]*? 非贪婪匹配 内的所有属性（不包括 \u0026gt;) `((… ) (/\u0026gt;))` \u0026gt;[\\s\\S]*? 情况 ①：匹配 \u0026gt; 后的内容，直到 / \u0026gt; 情况 ②：匹配 （自闭合标签） CharSequence.contains(regex: Regex):\n1 2 3 4 val source = `\u0026lt;a type=\u0026#34;topic\u0026#34; \u0026gt;#key_mmkv_migrate_version#\u0026lt;/a\u0026gt; ` val regexStr = `\u0026lt;a[^\u0026gt;]*?((\u0026gt;[\\s\\S]*?\u0026lt;/a\u0026gt;)|(/\u0026gt;))` val regex = regexStr.toRegex() source.contains(regex) contains方法表示是否符合这个正则判断。\nRegex.find(input: CharSequence, startIndex: Int = 0): MatchResult? Regex.find() 方法用于 查找字符串中第一个匹配的结果，返回 MatchResult?，如果找不到匹配项，则返回 null。 MatchResult.range:表示匹配的索引范围，分别用start和endInclusive来表示范围。 MatchResult.value:表示匹配到的内容\n正则：(\\\\S+)=\\\u0026quot;([^\\\u0026quot;]+)\\\u0026quot; 作用：主要是用来匹配html/xml属性及其值，比如\u0026lt;a type=\u0026quot;topic\u0026quot; \u0026gt;#key_mmkv_migrate_version#\u0026lt;/a\u0026gt; 能匹配到，它是匹配type=\u0026quot;topic\u0026quot;。 正则解析：\n正则部分 作用 (\\S+) 匹配属性名（非空字符 \\S，匹配至少一个字符 +） = 匹配等号（固定字符 =） \u0026quot;([^\u0026quot;]+)\u0026quot; 匹配属性值（被双引号 \u0026quot; 包裹，内容不含 \u0026ldquo;） Regex.findAll\n1 public actual fun findAll(input: CharSequence, startIndex: Int = 0): Sequence\u0026lt;MatchResult\u0026gt; 用于获取字符串中所有符合正则的结果，返回的是一个Sequence的MatchResult\n1 2 3 val attributeRegex = \u0026#34;(\\\\S+)=\\\u0026#34;([^\\\u0026#34;]+)\\\u0026#34;\u0026#34;.toRegex() val source = \u0026#34;\u0026lt;a type=\u0026#34;topic\u0026#34; \u0026gt;#key_mmkv_migrate_version#\u0026lt;/a\u0026gt; \u0026#34; val matchResultList = attributeRegex.findAll(source) MatchResult.destructured属性 用来提取匹配结果的捕获组，例如上面提取的是type和topic这一组内容。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 val regex = Regex(\u0026#34;(\\\\d{4})-(\\\\d{2})-(\\\\d{2})\u0026#34;) // 匹配日期格式 YYYY-MM-DD val input = \u0026#34;2024-03-07\u0026#34; val matchResult = regex.find(input) if (matchResult != null) { val (year, month, day) = matchResult.destructured println(\u0026#34;Year: $year, Month: $month, Day: $day\u0026#34;) } 输出： Year: 2024, Month: 03, Day: 07 然后通过MatchResult.destructured.toList()方法转成list，就可以获取type和topic内容了。\nSpannableStringBuilder使用\n在 Android 开发中，SpannableStringBuilder 主要用于富文本（Styled Text），可以让字符串的一部分具有不同的格式，比如 颜色、大小、样式、点击事件、图片等。它比 Html.fromHtml() 性能更好，更适合动态拼接文本。\n使用：\n1 2 3 4 5 6 7 8 9 10 11 val spannable = SpannableStringBuilder(\u0026#34;Hello, Android!\u0026#34;) // 给 \u0026#34;Android\u0026#34; 设置红色 spannable.setSpan( ForegroundColorSpan(Color.RED), 7, 14, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE ) // 应用到 TextView textView.text = spannable SpannableStringBuilder(\u0026ldquo;Hello, Android!\u0026rdquo;) 创建一个可变的 Spannable 对象。 setSpan(ForegroundColorSpan(Color.RED), 7, 14, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE) ForegroundColorSpan(Color.RED) → 设置前景色为红色。 7, 14 → 应用范围（“Android” 字符的索引）。 SPAN_EXCLUSIVE_EXCLUSIVE → 该 Span 只作用于当前字符范围，后续文本修改不会继承。 textView.movementMethod = LinkMovementMethod.getInstance()，设置 TextView 可点击 所以如果想要多个效果，可以添加多个span给SpannableStringBuilder，通过多次调用setSpan方法，然后设置不同的坐标信息。\nSpannableStringBuilder.append()，可以追加多个span的样式，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val spannable = SpannableStringBuilder() // 添加普通文本 spannable.append(\u0026#34;Normal Text \u0026#34;) // 添加红色文字 val redText = SpannableString(\u0026#34;Red Text\u0026#34;) redText.setSpan(ForegroundColorSpan(Color.RED), 0, redText.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE) spannable.append(redText) // 添加蓝色斜体文字 val blueText = SpannableString(\u0026#34; Blue Italic\u0026#34;) blueText.setSpan(ForegroundColorSpan(Color.BLUE), 0, blueText.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE) blueText.setSpan(StyleSpan(Typeface.ITALIC), 0, blueText.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE) spannable.append(blueText) // 应用到 TextView textView.text = spannable 上面用到了SpannableString，它是实现了CharSequence，是对字符串进行样式的扩展类，然后把它添加到SpannableStringBuilder中。\nspan中插入图片，通过imageSpan实现：\n1 2 3 4 5 6 7 8 9 10 11 12 val spannable = SpannableStringBuilder(\u0026#34;Text with image \u0026#34;) val drawable = ContextCompat.getDrawable(context, R.drawable.ic_launcher_foreground)!! drawable.setBounds(0, 0, drawable.intrinsicWidth, drawable.intrinsicHeight) // 在文本末尾添加图片 spannable.setSpan( ImageSpan(drawable, ImageSpan.ALIGN_BASELINE), spannable.length - 1, spannable.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE ) textView.text = spannable ","date":"2025-03-04T00:00:00Z","permalink":"http://xiangcman.xyz/p/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%B4%E7%90%86/","title":"正则表达式整理"},{"content":"上一节通过booster-transform-toast的使用，接着介绍了booster插件的主框架，最后自己简单使用了asm替换class中方法的调用，这一节讲解booster通过R内联来减少包体积。\n首先我们了解下多组件打包的时候，资源是怎么管理的，首先每个module都会有自己的R.class，分别存储了anim、animator、attr、bool等属性： 可以看到R.class中分别用静态内部类的形式保存各种资源属性，每一个属性是用一个静态常量的形式保存，其中每一个属性值是由PackageId+TypeId+EntryId组合的一个值： 就拿abc_face_in这个属性值，它是0x7f010000这个值。下面来拆解下这个值：\nPackageId：是包的id值，android中如何三方应用的话，这个值一直是0x7f，系统应用的话是0x01，它是占用一个字节。 TypeId：是资源的类型Id值，一般都是由anim、animator、attr等类型，比如anim是0x01，animator是0x02，attr是0x03，依次类推。它也是占用一个字节 EntryId：是具体类型下资源实例的id值，从0开始，依次递增，它是占用2个字节。 在多module下，每一个module打包后，都会有自己的R.class，其中module为library如果引用了资源的时候，编译apk的时候module中引用的还是R.class中的资源id。如果是主module，也就是application类型的，它会直接被替换成常量值了。因为module的class文件，在主工程编译时，不会再次进行编译，module的calss文件原封不动的打包进apk。而资源id为常量是在主工程编译时才形成的，但module生成class时，使用的是上面说到的变量，所以一直被保留了下来。 如果同一个资源分别在module1和module2都定义了，module1中引用了自己module的资源，此时主module先后依赖了module1和module2，那么此时module1中引用的资源是module1中的资源，如果主module先后依赖了module2和module1，那么此时module1中引用的资源是module2中定义的。出现上面的原因是因为主module在编译的时候，看谁先依赖，如果找到了对应的资源，那么就会以先依赖的module中的资源为主。 在编译的过程中，会把合并后的资源生成一个临时的R.txt文件，它的路径在app模块下的build/intermediates/symbols/debug/R.txt中： 在不同版本的agp上symbols文件夹可能不同，我这里用的agp是3.5.3，可以看到R.txt中每一行标明了资源的值类型、资源类型、资源名、资源对应的16进制值。最终通过aapt工具会构建resource.arsc文件。resource.arsc是一个资源映射表，里面通过16进制值找到对应的资源名。其中values文件夹下的资源都会在该文件中定义： 可以看到多语言默认打到apk中，所以如果不需要国际化是可以省去多语言的。而像非values文件夹下的资源直接在res目录中。\n总结 app打包过程中，总会用先依赖的module中定义的资源，即使该module用的是该module中的资源，最终由于打包合并资源的时候，优先去用先依赖的module中的资源。然后会生成R.txt文件，该文件是资源合并后生成的文件，里面每一行定义了某个资源的资源值类型、资源类型、资源名、资源16进制值，最终通过该文件生成resources.arsc，该文件是描述每个资源的资源值和资源名的一个对应关系，最终通过该关系找到资源。 在代码中，主module默认是通过常量引用资源，而library的module中默认引用资源的时候，是引用自己module的R中的变量，而资源最终会合并，所以最终使用的资源看合并时候哪个资源被打到apk中。\n上面提到谁先依赖的问题， 其实这个可以通过gradle命令查看依赖关系，比如我想看app这个module的依赖，比如我想看运行时的依赖：\n1 ./gradlew app:dependencies --configuration debugRuntimeClasspath 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 debugRuntimeClasspath - Resolved configuration for runtime for variant: debug +--- project :lib | +--- project :lib2 | | +--- androidx.constraintlayout:constraintlayout:1.1.3 | | | \\--- androidx.constraintlayout:constraintlayout-solver:1.1.3 | | +--- com.google.android.material:material:1.1.0 | | | +--- androidx.annotation:annotation:1.0.1 -\u0026gt; 1.1.0 | | | +--- androidx.appcompat:appcompat:1.1.0 | | | | +--- androidx.annotation:annotation:1.1.0 | | | | +--- androidx.core:core:1.1.0 | | | | | +--- androidx.annotation:annotation:1.1.0 | | | | | +--- androidx.lifecycle:lifecycle-runtime:2.0.0 -\u0026gt; 2.1.0 | | | | | | +--- androidx.lifecycle:lifecycle-common:2.1.0 | | | | | | | \\--- androidx.annotation:annotation:1.1.0 | | | | | | +--- androidx.arch.core:core-common:2.1.0 | | | | | | | \\--- androidx.annotation:annotation:1.1.0 | | | | | | \\--- androidx.annotation:annotation:1.1.0 | | | | | +--- androidx.versionedparcelable:versionedparcelable:1.1.0 | | | | | | +--- androidx.annotation:annotation:1.1.0 | | | | | | \\--- androidx.collection:collection:1.0.0 -\u0026gt; 1.1.0 | | | | | | \\--- androidx.annotation:annotation:1.1.0 | | | | | \\--- androidx.collection:collection:1.0.0 -\u0026gt; 1.1.0 (*) | | | | +--- androidx.cursoradapter:cursoradapter:1.0.0 | | | | | \\--- androidx.annotation:annotation:1.0.0 -\u0026gt; 1.1.0 | | | | +--- androidx.fragment:fragment:1.1.0 | | | | | +--- androidx.annotation:annotation:1.1.0 | | | | | +--- androidx.core:core:1.1.0 (*) | | | | | +--- androidx.collection:collection:1.1.0 (*) | | | | | +--- androidx.viewpager:viewpager:1.0.0 | | | | | | +--- androidx.annotation:annotation:1.0.0 -\u0026gt; 1.1.0 | | | | | | +--- androidx.core:core:1.0.0 -\u0026gt; 1.1.0 (*) | | | | | | \\--- androidx.customview:customview:1.0.0 | | | | | | +--- androidx.annotation:annotation:1.0.0 -\u0026gt; 1.1.0 | | | | | | \\--- androidx.core:core:1.0.0 -\u0026gt; 1.1.0 (*) | | | | | +--- androidx.loader:loader:1.0.0 | | | | | | +--- androidx.annotation:annotation:1.0.0 -\u0026gt; 1.1.0 | | | | | | +--- androidx.core:core:1.0.0 -\u0026gt; 1.1.0 (*) | | | | | | +--- androidx.lifecycle:lifecycle-livedata:2.0.0 | | | | | | | +--- androidx.arch.core:core-runtime:2.0.0 | | | | | | | | +--- androidx.annotation:annotation:1.0.0 -\u0026gt; 1.1.0 | | | | | | | | \\--- androidx.arch.core:core-common:2.0.0 -\u0026gt; 2.1.0 (*) | | | | | | | +--- androidx.lifecycle:lifecycle-livedata-core:2.0.0 | | | | | | | | +--- androidx.lifecycle:lifecycle-common:2.0.0 -\u0026gt; 2.1.0 (*) | | | | | | | | +--- androidx.arch.core:core-common:2.0.0 -\u0026gt; 2.1.0 (*) | | | | | | | | \\--- androidx.arch.core:core-runtime:2.0.0 (*) | | | | | | | \\--- androidx.arch.core:core-common:2.0.0 -\u0026gt; 2.1.0 (*) | | | | | | \\--- androidx.lifecycle:lifecycle-viewmodel:2.0.0 -\u0026gt; 2.1.0 | | | | | | \\--- androidx.annotation:annotation:1.1.0 | | | | | +--- androidx.activity:activity:1.0.0 | | | | | | +--- androidx.annotation:annotation:1.1.0 | | | | | | +--- androidx.core:core:1.1.0 (*) | | | | | | +--- androidx.lifecycle:lifecycle-runtime:2.1.0 (*) | | | | | | +--- androidx.lifecycle:lifecycle-viewmodel:2.1.0 (*) | | | | | | \\--- androidx.savedstate:savedstate:1.0.0 | | | | | | +--- androidx.annotation:annotation:1.1.0 | | | | | | +--- androidx.arch.core:core-common:2.0.1 -\u0026gt; 2.1.0 (*) | | | | | | \\--- androidx.lifecycle:lifecycle-common:2.0.0 -\u0026gt; 2.1.0 (*) | | | | | \\--- androidx.lifecycle:lifecycle-viewmodel:2.0.0 -\u0026gt; 2.1.0 (*) | | | | +--- androidx.appcompat:appcompat-resources:1.1.0 | | | | | +--- androidx.annotation:annotation:1.1.0 | | | | | +--- androidx.core:core:1.0.1 -\u0026gt; 1.1.0 (*) | | | | | +--- androidx.vectordrawable:vectordrawable:1.1.0 | | | | | | +--- androidx.annotation:annotation:1.1.0 | | | | | | +--- androidx.core:core:1.1.0 (*) | | | | | | \\--- androidx.collection:collection:1.1.0 (*) | | | | | +--- androidx.vectordrawable:vectordrawable-animated:1.1.0 | | | | | | +--- androidx.vectordrawable:vectordrawable:1.1.0 (*) | | | | | | +--- androidx.interpolator:interpolator:1.0.0 | | | | | | | \\--- androidx.annotation:annotation:1.0.0 -\u0026gt; 1.1.0 | | | | | | \\--- androidx.collection:collection:1.1.0 (*) | | | | | \\--- androidx.collection:collection:1.0.0 -\u0026gt; 1.1.0 (*) | | | | +--- androidx.drawerlayout:drawerlayout:1.0.0 | | | | | +--- androidx.annotation:annotation:1.0.0 -\u0026gt; 1.1.0 | | | | | +--- androidx.core:core:1.0.0 -\u0026gt; 1.1.0 (*) | | | | | \\--- androidx.customview:customview:1.0.0 (*) | | | | \\--- androidx.collection:collection:1.0.0 -\u0026gt; 1.1.0 (*) | | | +--- androidx.cardview:cardview:1.0.0 | | | | \\--- androidx.annotation:annotation:1.0.0 -\u0026gt; 1.1.0 | | | +--- androidx.coordinatorlayout:coordinatorlayout:1.1.0 | | | | +--- androidx.annotation:annotation:1.1.0 | | | | +--- androidx.core:core:1.1.0 (*) | | | | +--- androidx.customview:customview:1.0.0 (*) | | | | \\--- androidx.collection:collection:1.0.0 -\u0026gt; 1.1.0 (*) | | | +--- androidx.core:core:1.1.0 (*) | | | +--- androidx.fragment:fragment:1.0.0 -\u0026gt; 1.1.0 (*) | | | +--- androidx.lifecycle:lifecycle-runtime:2.0.0 -\u0026gt; 2.1.0 (*) | | | +--- androidx.recyclerview:recyclerview:1.0.0 -\u0026gt; 1.1.0 | | | | +--- androidx.annotation:annotation:1.1.0 | | | | +--- androidx.core:core:1.1.0 (*) | | | | +--- androidx.customview:customview:1.0.0 (*) | | | | \\--- androidx.collection:collection:1.0.0 -\u0026gt; 1.1.0 (*) | | | +--- androidx.transition:transition:1.2.0 | | | | +--- androidx.annotation:annotation:1.1.0 | | | | +--- androidx.core:core:1.0.1 -\u0026gt; 1.1.0 (*) | | | | \\--- androidx.collection:collection:1.0.0 -\u0026gt; 1.1.0 (*) | | | +--- androidx.vectordrawable:vectordrawable:1.1.0 (*) | | | \\--- androidx.viewpager2:viewpager2:1.0.0 | | | +--- androidx.annotation:annotation:1.1.0 | | | +--- androidx.fragment:fragment:1.1.0 (*) | | | +--- androidx.recyclerview:recyclerview:1.1.0 (*) | | | +--- androidx.core:core:1.1.0 (*) | | | \\--- androidx.collection:collection:1.1.0 (*) | | +--- androidx.cardview:cardview:1.0.0 (*) | | \\--- androidx.appcompat:appcompat:1.1.0 (*) | +--- androidx.constraintlayout:constraintlayout:1.1.3 (*) | +--- com.google.android.material:material:1.1.0 (*) | +--- androidx.cardview:cardview:1.0.0 (*) | \\--- androidx.appcompat:appcompat:1.1.0 (*) +--- project :lib1 | +--- project :lib3 | | +--- androidx.constraintlayout:constraintlayout:1.1.3 (*) | | +--- com.google.android.material:material:1.1.0 (*) | | +--- androidx.cardview:cardview:1.0.0 (*) | | \\--- androidx.appcompat:appcompat:1.1.0 (*) | +--- androidx.constraintlayout:constraintlayout:1.1.3 (*) | +--- com.google.android.material:material:1.1.0 (*) | +--- androidx.cardview:cardview:1.0.0 (*) | \\--- androidx.appcompat:appcompat:1.1.0 (*) +--- androidx.constraintlayout:constraintlayout:1.1.3 (*) +--- com.google.android.material:material:1.1.0 (*) +--- androidx.cardview:cardview:1.0.0 (*) +--- androidx.appcompat:appcompat:1.1.0 (*) \\--- com.didiglobal.booster:booster-android-instrument-toast:3.1.0 \\--- com.didiglobal.booster:booster-android-instrument:3.1.0 可以看出来app的module先是依赖了lib和lib1这两个module，并且lib这个module又依赖了lib2，lib1依赖了lib3，所以资源合并的时候，优先使用lib和lib2中的资源。 关于更多依赖的gradle命令：\n1 2 //查看编译时的依赖，它只会看直接依赖的子module，间接依赖的子module不会查看 ./gradlew app:dependencies --configuration debugCompileClasspath 1 2 //它会输出debug、release、test、compile、runtime组合的依赖 ./gradlew app:dependencies 注：下面介绍的R内联插件是在booster3.1.0版本上 介绍完上面资源文件引用问题，我们发现随着module和aar越来越多的时候，R.class的数量会急剧增加，导致包体积急增。那booster是怎么解决这个R.class剧增的呢？ 它是通过把子module的R.class中定义的变量都删除掉，然后子module中的代码引用的资源变量会直接被R.txt中定义的常量值所代替。这就是R文件内联的过程。那下面就分析下这个过程怎么实现的，前面介绍过各个插件是通过自己的ClassTransformer来实现字节码修改，其中R文件内联的插件是通过RInlineTransformer实现的，首先看下onPreTransform中的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 override fun onPreTransform(context: TransformContext) { this.appPackage = context.originalApplicationId.replace(\u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;) //①解析R.txt，生成sybols信息 this.symbols = SymbolList.from(context.artifacts.get(SYMBOL_LIST).single()) this.appRStyleable = \u0026#34;$appPackage/$R_STYLEABLE\u0026#34; this.ignores = context.getProperty(PROPERTY_IGNORES)?.split(\u0026#39;,\u0026#39;)?.map { Wildcard(it) }?.toSet() ?: emptySet() //②忽略constrainlayout中的id属性 val retainedSymbols: Set\u0026lt;String\u0026gt; val classpath = context.compileClasspath.map { it.absolutePath } if (classpath.any { it.contains(PREFIX_SUPPORT_CONSTRAINT_LAYOUT) || it.contains(PREFIX_JETPACK_CONSTRAINT_LAYOUT) }) { // Find symbols that should be retained retainedSymbols = context.findRetainedSymbols() if (retainedSymbols.isNotEmpty()) { this.ignores += setOf(Wildcard.valueOf(\u0026#34;android/support/constraint/R\\$id\u0026#34;)) this.ignores += setOf(Wildcard.valueOf(\u0026#34;androidx/constraintlayout/R\\$id\u0026#34;)) } } else { retainedSymbols = emptySet() } } 在onPreTransform①处首先解析R.txt文件，文章开头已经介绍过该文件，它主要是用来存储资源文件合并后的信息。在②处会忽略ConstrainLayout中的R.id.**的变量，因为在 ConstraintLayout 中，R.id.xxx 可能会被 ConstraintSet 或者其他代码 动态解析，比如：\n1 2 3 val constraintSet = ConstraintSet() constraintSet.clone(constraintLayout) constraintSet.connect(R.id.viewA, ConstraintSet.START, R.id.viewB, ConstraintSet.END) Booster 进行 代码压缩/重排 时，如果对 R.id.xxx 进行了内联或优化，可能会导致 ID 失效，进而导致约束布局无法正常工作。接着看下transform方法，它是操作字节码的关键方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 override fun transform(context: TransformContext, klass: ClassNode): ClassNode { if (this.symbols.isEmpty()) { return klass } if (this.ignores.any { it.matches(klass.name) }) { logger.println(\u0026#34;Ignore `${klass.name}`\u0026#34;) } else if (Pattern.matches(R_REGEX, klass.name) \u0026amp;\u0026amp; klass.name != appRStyleable) { //通过正则匹配删除R$color这种内部类的所有属性 klass.fields.clear() removedR[klass.name] = klass.bytes() } else { //如果是代码中调用了R.color.**这种，直接操作字节码 klass.replaceSymbolReferenceWithConstant() } return klass } 在transform方法中，通过正则匹配删除R$color这种内部类的所有属性，如果不是R$color这种内部类，则通过扩展函数replaceSymbolReferenceWithConstant直接操作字节码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 private fun ClassNode.replaceSymbolReferenceWithConstant() { methods.forEach { method -\u0026gt; //①：通过方法的指令集来过滤 val insns = method.instructions.iterator().asIterable().filter { //②：如果当前指令是getstatic it.opcode == GETSTATIC }.map { it as FieldInsnNode }.filter { //③：返回值是int类型并且是以**R$开头获取R文件中的常量形式并且不是以android内部的R开头的话 (\u0026#34;I\u0026#34; == it.desc || \u0026#34;[I\u0026#34; == it.desc) \u0026amp;\u0026amp; it.owner.substring(it.owner.lastIndexOf(\u0026#39;/\u0026#39;) + 1).startsWith(\u0026#34;R$\u0026#34;) \u0026amp;\u0026amp; !(it.owner.startsWith(COM_ANDROID_INTERNAL_R) || it.owner.startsWith(ANDROID_R)) } //④：过滤出返回值为int类型的指令 val intFields = insns.filter { \u0026#34;I\u0026#34; == it.desc } val intArrayFields = insns.filter { \u0026#34;[I\u0026#34; == it.desc } intFields.forEach { field -\u0026gt; //⑤：获取R文件的资源类型 val type = field.owner.substring(field.owner.lastIndexOf(\u0026#34;/R$\u0026#34;) + 3) try { //⑥：在获取R中常量指令之前插入常量的指令，LdcInsnNode中的参数是获取这个常量值 method.instructions.insertBefore(field, LdcInsnNode(symbols.getInt(type, field.name))) //⑦：移除当前获取变量的指令 method.instructions.remove(field) } catch (e: NullPointerException) { logger.println(\u0026#34;Unresolvable symbol `R.$type.${field.name}` : $name.${method.name}${method.desc}\u0026#34;) } } //⑧：int数组类型的指令直接把owner替换成app目录的包名 intArrayFields.forEach { field -\u0026gt; field.owner = \u0026#34;$appPackage/${field.owner.substring(field.owner.lastIndexOf(\u0026#39;/\u0026#39;) + 1)}\u0026#34; } } } 在上面字节码操作如果不太熟悉的话，我们可以在library模块中定义类去获取R中的资源，比如我下面定义一个TestView，获取自己的R中的color属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class TestView extends View { public TestView(Context context) { this(context, null); } public TestView(Context context, @Nullable AttributeSet attrs) { this(context, attrs, 0); } public TestView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); setBackgroundColor(getResources().getColor(R.color.black_bg)); } } 上面获取R.color.black_bg，那此处会用booster的R内联给替换成常量，怎么替换，先肯定是找到这个指令对不？看下此处的指令，我们通过jclasslib bytecode viewer来查看编译后的class：\n1 2 3 4 5 6 7 8 9 10 11 12 0 aload_0 1 aload_1 2 aload_2 3 iload_3 4 invokespecial #3 \u0026lt;android/view/View.\u0026lt;init\u0026gt; : (Landroid/content/Context;Landroid/util/AttributeSet;I)V\u0026gt; 7 aload_0 8 aload_0 9 invokevirtual #4 \u0026lt;com/xc/lib/TestView.getResources : ()Landroid/content/res/Resources;\u0026gt; 12 getstatic #5 \u0026lt;com/xc/lib/R$color.black_bg : I\u0026gt; 15 invokevirtual #6 \u0026lt;android/content/res/Resources.getColor : (I)I\u0026gt; 18 invokevirtual #7 \u0026lt;com/xc/lib/TestView.setBackgroundColor : (I)V\u0026gt; 21 return 在12行，通过getstatic来获取com/xc/lib/R$color.black_bg，返回类型是I，表示整形。所以上面①-④的操作就是在获取该指令，在⑤处获取该资源类型，上面TestView中是获取color类型的资源，加3是为了要获取在/R$后面的字符的开始位置，⑥处表示在该获取变量的指令前插入一条LdcInsnNode的常量指令，在⑦处移除当前获取变量的指令。在⑧处如果是int数组类型的指令直接把owner替换成app目录的包名。 其实还有个工具可以查看上面FieldInsnNode的owner、des、name信息，比如getstatic #5 \u0026lt;com/xc/lib/R$color.black_bg : I\u0026gt;这条指令在jclasslib bytecode viewer，比如上面的属性信息展示如下： 上面属性是一个常量，所以它是在常量池中，需要是05，类名对应了owner，也就是说该属性是属于哪个类下的，名字是black_bg，对应了name，I是返回值，int类型，对应了des。 结合修改后的字节码，查看TestView修改后的字节码，通过BytecodeViewer来查看编译后的class： 可以看到最终通过ldc指令来获取一个常量来替换之前获取R.color.black_bg变量。同时再来看下module下的R$color.class: 可以看到该内部类所有的属性被置为空了，包括主module下的R$color.class下的属性也是清空了。所以booster的方案是不区分主module还是lib的module。\n为什么R$styleable中的静态变量不会被移除？并且主module是原封不动，lib的module是只保留了数组类型的变量，并且是在static代码块中定义数组，并且数组的定义缺少public static final关键字：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 package com.xc.lib; public final class R$styleable { static { ActionBar = new int[]{2130903092, 2130903099, 2130903100, 2130903224, 2130903225, 2130903226, 2130903227, 2130903228, 2130903229, 2130903255, 2130903264, 2130903265, 2130903284, 2130903343, 2130903349, 2130903355, 2130903356, 2130903358, 2130903368, 2130903381, 2130903481, 2130903513, 2130903532, 2130903536, 2130903537, 2130903598, 2130903601, 2130903673, 2130903683}; ActionBarLayout = new int[]{16842931}; ActionMenuItemView = new int[]{16843071}; ActionMenuView = new int[0]; ActionMode = new int[]{2130903092, 2130903099, 2130903192, 2130903343, 2130903601, 2130903683}; ActivityChooserView = new int[]{2130903303, 2130903369}; AlertDialog = new int[]{16842994, 2130903142, 2130903143, 2130903470, 2130903471, 2130903510, 2130903566, 2130903568}; AnimatedStateListDrawableCompat = new int[]{16843036, 16843156, 16843157, 16843158, 16843532, 16843533}; AnimatedStateListDrawableItem = new int[]{16842960, 16843161}; AnimatedStateListDrawableTransition = new int[]{16843161, 16843849, 16843850, 16843851}; AppBarLayout = new int[]{16842964, 16843919, 16844096, 2130903284, 2130903304, 2130903462, 2130903463, 2130903592}; AppBarLayoutStates = new int[]{2130903586, 2130903587, 2130903589, 2130903590}; AppBarLayout_Layout = new int[]{2130903460, 2130903461}; AppCompatImageView = new int[]{16843033, 2130903578, 2130903671, 2130903672}; AppCompatSeekBar = new int[]{16843074, 2130903668, 2130903669, 2130903670}; AppCompatTextHelper = new int[]{16842804, 16843117, 16843118, 16843119, 16843120, 16843666, 16843667}; AppCompatTextView = new int[]{16842804, 2130903087, 2130903088, 2130903089, 2130903090, 2130903091, 2130903269, 2130903270, 2130903271, 2130903272, 2130903274, 2130903275, 2130903276, 2130903277, 2130903326, 2130903329, 2130903337, 2130903399, 2130903464, 2130903633, 2130903660}; AppCompatTheme = new int[]{16842839, 16842926, 2130903040, 2130903041, 2130903042, 2130903043, 2130903044, 2130903045, 2130903046, 2130903047, 2130903048, 2130903049, 2130903050, 2130903051, 2130903052, 2130903054, 2130903055, 2130903056, 2130903057, 2130903058, 2130903059, 2130903060, 2130903061, 2130903062, 2130903063, 2130903064, 2130903065, 2130903066, 2130903067, 2130903068, 2130903069, 2130903070, 2130903074, 2130903075, 2130903076, 2130903077, 2130903078, 2130903086, 2130903120, 2130903135, 2130903136, 2130903137, 2130903138, 2130903139, 2130903144, 2130903145, 2130903157, 2130903164, 2130903198, 2130903199, 2130903200, 2130903201, 2130903202, 2130903203, 2130903204, 2130903211, 2130903212, 2130903218, 2130903236, 2130903261, 2130903262, 2130903263, 2130903266, 2130903268, 2130903279, 2130903280, 2130903281, 2130903282, 2130903283, 2130903355, 2130903367, 2130903466, 2130903467, 2130903468, 2130903469, 2130903472, 2130903473, 2130903474, 2130903475, 2130903476, 2130903477, 2130903478, 2130903479, 2130903480, 2130903522, 2130903523, 2130903524, 2130903531, 2130903533, 2130903540, 2130903542, 2130903543, 2130903544, 2130903553, 2130903554, 2130903555, 2130903556, 2130903575, 2130903576, 2130903605, 2130903644, 2130903646, 2130903647, 2130903648, 2130903650, 2130903651, 2130903652, 2130903653, 2130903656, 2130903657, 2130903685, 2130903686, 2130903687, 2130903688, 2130903696, 2130903698, 2130903699, 2130903700, 2130903701, 2130903702, 2130903703, 2130903704, 2130903705, 2130903706, 2130903707}; Badge = new int[]{2130903093, 2130903103, 2130903105, 2130903505, 2130903515}; BottomAppBar = new int[]{2130903101, 2130903284, 2130903314, 2130903315, 2130903316, 2130903317, 2130903318, 2130903350}; BottomNavigationView = new int[]{2130903101, 2130903284, 2130903373, 2130903376, 2130903378, 2130903379, 2130903382, 2130903394, 2130903395, 2130903396, 2130903398, 2130903508}; BottomSheetBehavior_Layout = new int[]{16843840, 2130903101, 2130903111, 2130903112, 2130903113, 2130903114, 2130903116, 2130903117, 2130903118, 2130903557, 2130903560}; ButtonBarLayout = new int[]{2130903079}; CardView = new int[]{16843071, 16843072, 2130903148, 2130903149, 2130903150, 2130903152, 2130903153, 2130903154, 2130903230, 2130903231, 2130903232, 2130903233, 2130903234}; Chip = new int[]{16842804, 16842904, 16842923, 16843039, 16843087, 16843237, 2130903160, 2130903161, 2130903163, 2130903165, 2130903166, 2130903167, 2130903169, 2130903170, 2130903171, 2130903172, 2130903173, 2130903174, 2130903175, 2130903180, 2130903181, 2130903182, 2130903184, 2130903185, 2130903186, 2130903187, 2130903188, 2130903189, 2130903190, 2130903191, 2130903296, 2130903348, 2130903359, 2130903363, 2130903547, 2130903557, 2130903560, 2130903564, 2130903658, 2130903661}; ChipGroup = new int[]{2130903159, 2130903176, 2130903177, 2130903178, 2130903569, 2130903570}; CollapsingToolbarLayout = new int[]{2130903195, 2130903196, 2130903235, 2130903305, 2130903306, 2130903307, 2130903308, 2130903309, 2130903310, 2130903311, 2130903548, 2130903550, 2130903593, 2130903673, 2130903674, 2130903684}; CollapsingToolbarLayout_Layout = new int[]{2130903405, 2130903406}; ColorStateListItem = new int[]{16843173, 16843551, 2130903080}; CompoundButton = new int[]{16843015, 2130903140, 2130903146, 2130903147}; ConstraintLayout_Layout = new int[]{16842948, 16843039, 16843040, 16843071, 16843072, 2130903107, 2130903108, 2130903156, 2130903220, 2130903221, 2130903407, 2130903408, 2130903409, 2130903410, 2130903411, 2130903412, 2130903413, 2130903414, 2130903415, 2130903416, 2130903417, 2130903418, 2130903419, 2130903420, 2130903421, 2130903422, 2130903423, 2130903424, 2130903425, 2130903426, 2130903427, 2130903428, 2130903429, 2130903430, 2130903431, 2130903432, 2130903433, 2130903434, 2130903435, 2130903436, 2130903437, 2130903438, 2130903439, 2130903440, 2130903441, 2130903442, 2130903443, 2130903444, 2130903445, 2130903446, 2130903447, 2130903449, 2130903450, 2130903451, 2130903452, 2130903453, 2130903454, 2130903455, 2130903456, 2130903459}; ConstraintLayout_placeholder = new int[]{2130903222, 2130903287}; ConstraintSet = new int[]{16842948, 16842960, 16842972, 16842996, 16842997, 16842999, 16843000, 16843001, 16843002, 16843039, 16843040, 16843071, 16843072, 16843551, 16843552, 16843553, 16843554, 16843555, 16843556, 16843557, 16843558, 16843559, 16843560, 16843701, 16843702, 16843770, 16843840, 2130903107, 2130903108, 2130903156, 2130903221, 2130903407, 2130903408, 2130903409, 2130903410, 2130903411, 2130903412, 2130903413, 2130903414, 2130903415, 2130903416, 2130903417, 2130903418, 2130903419, 2130903420, 2130903421, 2130903422, 2130903423, 2130903424, 2130903425, 2130903426, 2130903427, 2130903428, 2130903429, 2130903430, 2130903431, 2130903432, 2130903433, 2130903434, 2130903435, 2130903436, 2130903437, 2130903438, 2130903439, 2130903440, 2130903441, 2130903442, 2130903443, 2130903444, 2130903445, 2130903446, 2130903447, 2130903449, 2130903450, 2130903451, 2130903452, 2130903453, 2130903454, 2130903455, 2130903456}; CoordinatorLayout = new int[]{2130903397, 2130903591}; CoordinatorLayout_Layout = new int[]{16842931, 2130903402, 2130903403, 2130903404, 2130903448, 2130903457, 2130903458}; DrawerArrowToggle = new int[]{2130903084, 2130903085, 2130903106, 2130903197, 2130903273, 2130903340, 2130903574, 2130903664}; ExtendedFloatingActionButton = new int[]{2130903284, 2130903312, 2130903348, 2130903564, 2130903567}; ExtendedFloatingActionButton_Behavior_Layout = new int[]{2130903109, 2130903110}; FloatingActionButton = new int[]{2130903101, 2130903102, 2130903119, 2130903284, 2130903296, 2130903319, 2130903320, 2130903348, 2130903357, 2130903506, 2130903535, 2130903547, 2130903557, 2130903560, 2130903564, 2130903694}; FloatingActionButton_Behavior_Layout = new int[]{2130903109}; FlowLayout = new int[]{2130903390, 2130903465}; FontFamily = new int[]{2130903330, 2130903331, 2130903332, 2130903333, 2130903334, 2130903335}; FontFamilyFont = new int[]{16844082, 16844083, 16844095, 16844143, 16844144, 2130903328, 2130903336, 2130903337, 2130903338, 2130903693}; ForegroundLinearLayout = new int[]{16843017, 16843264, 2130903339}; GradientColor = new int[]{16843165, 16843166, 16843169, 16843170, 16843171, 16843172, 16843265, 16843275, 16844048, 16844049, 16844050, 16844051}; GradientColorItem = new int[]{16843173, 16844052}; LinearConstraintLayout = new int[]{16842948}; LinearLayoutCompat = new int[]{16842927, 16842948, 16843046, 16843047, 16843048, 2130903265, 2130903267, 2130903507, 2130903563}; LinearLayoutCompat_Layout = new int[]{16842931, 16842996, 16842997, 16843137}; ListPopupWindow = new int[]{16843436, 16843437}; MaterialAlertDialog = new int[]{2130903094, 2130903095, 2130903096, 2130903097}; MaterialAlertDialogTheme = new int[]{2130903483, 2130903484, 2130903485, 2130903486, 2130903487}; MaterialButton = new int[]{16843191, 16843192, 16843193, 16843194, 16843237, 2130903101, 2130903102, 2130903243, 2130903284, 2130903358, 2130903360, 2130903361, 2130903362, 2130903364, 2130903365, 2130903547, 2130903557, 2130903560, 2130903594, 2130903595}; MaterialButtonToggleGroup = new int[]{2130903158, 2130903570}; MaterialCalendar = new int[]{16843277, 2130903256, 2130903257, 2130903258, 2130903259, 2130903541, 2130903708, 2130903709, 2130903710}; MaterialCalendarItem = new int[]{16843191, 16843192, 16843193, 16843194, 2130903374, 2130903383, 2130903384, 2130903391, 2130903392, 2130903396}; MaterialCardView = new int[]{16843237, 2130903151, 2130903160, 2130903162, 2130903547, 2130903557, 2130903560, 2130903588, 2130903594, 2130903595}; MaterialCheckBox = new int[]{2130903146, 2130903695}; MaterialRadioButton = new int[]{2130903695}; MaterialShape = new int[]{2130903557, 2130903560}; MaterialTextAppearance = new int[]{16844159, 2130903464}; MaterialTextView = new int[]{16842804, 16844159, 2130903464}; MenuGroup = new int[]{16842766, 16842960, 16843156, 16843230, 16843231, 16843232}; MenuItem = new int[]{16842754, 16842766, 16842960, 16843014, 16843156, 16843230, 16843231, 16843233, 16843234, 16843235, 16843236, 16843237, 16843375, 2130903053, 2130903071, 2130903073, 2130903081, 2130903223, 2130903364, 2130903365, 2130903516, 2130903562, 2130903689}; MenuView = new int[]{16842926, 16843052, 16843053, 16843054, 16843055, 16843056, 16843057, 2130903534, 2130903596}; NavigationView = new int[]{16842964, 16842973, 16843039, 2130903284, 2130903342, 2130903373, 2130903375, 2130903377, 2130903378, 2130903379, 2130903380, 2130903383, 2130903384, 2130903385, 2130903386, 2130903387, 2130903388, 2130903389, 2130903393, 2130903396, 2130903508}; PopupWindow = new int[]{16843126, 16843465, 2130903517}; PopupWindowBackgroundState = new int[]{2130903585}; RecycleListView = new int[]{2130903518, 2130903521}; RecyclerView = new int[]{16842948, 16842987, 16842993, 2130903321, 2130903322, 2130903323, 2130903324, 2130903325, 2130903401, 2130903546, 2130903573, 2130903579}; ScrimInsetsFrameLayout = new int[]{2130903370}; ScrollingViewBehavior_Layout = new int[]{2130903115}; SearchView = new int[]{16842970, 16843039, 16843296, 16843364, 2130903185, 2130903219, 2130903260, 2130903341, 2130903366, 2130903400, 2130903538, 2130903539, 2130903551, 2130903552, 2130903597, 2130903602, 2130903697}; ShapeAppearance = new int[]{2130903238, 2130903239, 2130903240, 2130903241, 2130903242, 2130903244, 2130903245, 2130903246, 2130903247, 2130903248}; Snackbar = new int[]{2130903571, 2130903572}; SnackbarLayout = new int[]{16843039, 2130903072, 2130903082, 2130903098, 2130903284, 2130903503}; Spinner = new int[]{16842930, 16843126, 16843131, 16843362, 2130903532}; StateListDrawable = new int[]{16843036, 16843156, 16843157, 16843158, 16843532, 16843533}; StateListDrawableItem = new int[]{16843161}; SwitchCompat = new int[]{16843044, 16843045, 16843074, 2130903565, 2130903577, 2130903603, 2130903604, 2130903606, 2130903665, 2130903666, 2130903667, 2130903690, 2130903691, 2130903692}; SwitchMaterial = new int[]{2130903695}; TabItem = new int[]{16842754, 16842994, 16843087}; TabLayout = new int[]{2130903607, 2130903608, 2130903609, 2130903610, 2130903611, 2130903612, 2130903613, 2130903614, 2130903615, 2130903616, 2130903617, 2130903618, 2130903619, 2130903620, 2130903621, 2130903622, 2130903623, 2130903624, 2130903625, 2130903626, 2130903627, 2130903628, 2130903630, 2130903631, 2130903632}; TextAppearance = new int[]{16842901, 16842902, 16842903, 16842904, 16842906, 16842907, 16843105, 16843106, 16843107, 16843108, 16843692, 16844165, 2130903329, 2130903337, 2130903633, 2130903660}; TextInputLayout = new int[]{16842906, 16843088, 2130903125, 2130903126, 2130903127, 2130903128, 2130903129, 2130903130, 2130903131, 2130903132, 2130903133, 2130903134, 2130903249, 2130903250, 2130903251, 2130903252, 2130903253, 2130903254, 2130903288, 2130903289, 2130903290, 2130903291, 2130903292, 2130903293, 2130903297, 2130903298, 2130903299, 2130903300, 2130903301, 2130903302, 2130903344, 2130903345, 2130903346, 2130903347, 2130903351, 2130903352, 2130903353, 2130903354, 2130903525, 2130903526, 2130903527, 2130903528, 2130903529, 2130903557, 2130903560, 2130903580, 2130903581, 2130903582, 2130903583, 2130903584}; ThemeEnforcement = new int[]{16842804, 2130903294, 2130903295}; Toolbar = new int[]{16842927, 16843072, 2130903141, 2130903193, 2130903194, 2130903224, 2130903225, 2130903226, 2130903227, 2130903228, 2130903229, 2130903481, 2130903482, 2130903504, 2130903508, 2130903511, 2130903512, 2130903532, 2130903598, 2130903599, 2130903600, 2130903673, 2130903675, 2130903676, 2130903677, 2130903678, 2130903679, 2130903680, 2130903681, 2130903682}; View = new int[]{16842752, 16842970, 2130903519, 2130903520, 2130903662}; ViewBackgroundHelper = new int[]{16842964, 2130903101, 2130903102}; ViewPager2 = new int[]{16842948}; ViewStubCompat = new int[]{16842960, 16842994, 16842995}; } private R$styleable() { } } 下面测试下R.styleable结果在class中的体现： 可以看到在lib中引用到的styleable数组属性被替换成主module中的属性了。lib的R.class中只有R$styleable的数组属性，并且在静态代码块中。\n","date":"2025-02-28T00:00:00Z","permalink":"http://xiangcman.xyz/p/booster%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96%E4%B9%8Br%E5%86%85%E8%81%94/","title":"booster包体积优化之R内联"},{"content":"创建脚本 首先在终端下创建一个脚本文件\n1 touch apkcompare 给脚本赋予执行权限 1 chmod +x apkcompare 打开脚本 使用zsh中装的sublime插件打开脚本文件\n1 st apkcompare 编辑脚本内容 1 2 3 4 5 6 7 #!/bin/bash echo \u0026#34;请输入改变前的apk路径：\u0026#34; read path1 echo \u0026#34;请输入改变后的apk路径：\u0026#34; read path2 cd /Users/xiangcheng/downloads java -jar apkcompare-1.0.jar $path1 $path2 compare_result_file 执行脚本 1 ./apkcompare 如何全局能执行脚本 上面执行脚本要到指定的目录才行，如果我想全局都能运行脚本的话，可以通过配置脚本的根目录的环境变量，比如我的脚本都放在了desktop/脚本文件夹中，那么我可以在.zshrc中配置如下：\n1 export PATH=\u0026#34;$HOME/desktop/脚本:$PATH\u0026#34; 这样我们就直接可以全局运行脚本，比如我这里有个jadx的脚本，则可以直接用如下命令启动jadx工具：\n1 jadx 将脚本定制成应用 平时使用shell脚本的时候，每次都要找到shell脚本的执行文件非常麻烦，然后想到如果能将shell脚本制作成一个应用那就非常nice了。 下面就以平时用的比较多的反编译脚本jadx为例来实践。\n先通过Alfred工具搜索出本机的Automator工具： 选取应用程序 添加shell脚本 在左侧搜索 “运行 Shell 脚本”（Run Shell Script）。 拖动到右侧工作区。 在 Shell 选项里，选择 /bin/bash（或 /bin/zsh）。 在文本框里输入如下代码： 1 2 #!/bin/bash /opt/homebrew/Cellar/jadx/1.5.1/bin/jadx-gui 我是通过homebrew装的jadx工具，所以指定下自己的jadx目录。\n保存应用 给应用定制图标 mac下应用的图标都是通过应用下的Info.plist文件来控制的： 它是通过CFBundleIconFile字段控制的，这里我把图标放在了应用的Resources文件下： 可以看到需要一个.icns的文件，这里我是通过在线网站https://cloudconvert.com/png-to-icns来实现png-\u0026gt;icns的。一切替换完后，还需要刷新 Launch Services，否则 macOS 可能不会立刻识别新图标，执行如下脚本：\n1 2 touch /Applications/Jadx.app killall Finder 我在chatgpt搜索的时候，它是通过touch ~/Applications/Jadx.app来执行的，但是我发现我的Jadx.app是在如下目录： 所以不用定位到Users/用户名，要不然会报错找不到Jadx应用。这里提一句mac下~表示的目录是Users/用户名，比如我的如下： 操作完后，一个带图标的shell脚本的应用就创建成功了。\n我的脚本工具集 apk比对脚本： apkcompare\n字节码查看脚本： bytecode-viewer\n批量删除指定后缀的图片脚本： delete_images\n反编译apk的脚本： jadx\n","date":"2025-02-19T00:00:00Z","permalink":"http://xiangcman.xyz/p/mac%E4%B8%8B%E5%BF%AB%E9%80%9F%E5%86%99%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/","title":"mac下快速写一个脚本"},{"content":"booster是基于gradle transform、asm进行字节码操作的框架，内部有很多gradle transform来操作对应的字节码，首先我们将对应的插件依赖进来，我们以toast插件替换为测试，看下效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 buildscript { ext { plugin_version = \u0026#34;0.3.0\u0026#34; booster_version = \u0026#34;1.0.0\u0026#34; } // ext.plugin_version = \u0026#34;0.3.0\u0026#34; repositories { google() jcenter() maven { url \u0026#34;https://artifact.bytedance.com/repository/byteX/\u0026#34; } } dependencies { classpath \u0026#39;com.android.tools.build:gradle:3.5.3\u0026#39; //booster classpath \u0026#34;com.didiglobal.booster:booster-gradle-plugin:$booster_version\u0026#34; //booster toast插件 classpath \u0026#34;com.didiglobal.booster:booster-transform-toast:$booster_version\u0026#34; //bytex base // classpath \u0026#34;com.bytedance.android.byteX:base-plugin:${plugin_version}\u0026#34; // Add bytex plugins\u0026#39; dependencies on demand. 按需添加插件依赖 // classpath \u0026#34;com.bytedance.android.byteX:method-call-opt-plugin:${plugin_version}\u0026#34; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } 然后使用插件：\n1 2 apply plugin: \u0026#39;com.android.application\u0026#39; apply plugin: \u0026#39;com.didiglobal.booster\u0026#39; // ③ 在MainActivity中添加如下代码： 然后看编译后的类，这里有个细节，大家得熟悉打包流程，javac编译成class后，然后把class转化成dex文件，transform就是作用于class转成dex之间，所以如果看javac之后的class是看不到最终toast插件作用的效果，需要反编译看最终的apk或者dex文件： 可以看到此时是替换成了ShadowToast中的show方法了。下面结合源码看下booster如何做到class替换的，本次通过gradle下载的插件源码来分析，booster插件下载的地址在/Users/xiangcheng/.gralde/cache/modules-2/files-2.1/com.didiglobal.booster下： booster-gradle-plugin 是booster定义插件的模块，下面打开它的源码，找到它的plugin： booster插件对应的类名是com.didiglobal.booster.gradle.BoosterPlugin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package com.didiglobal.booster.gradle import com.android.build.gradle.AppExtension import com.android.build.gradle.LibraryExtension import com.didiglobal.booster.task.spi.VariantProcessor import org.gradle.api.Plugin import org.gradle.api.Project import java.util.ServiceLoader /** * Represents the booster gradle plugin * * @author johnsonlee */ class BoosterPlugin : Plugin\u0026lt;Project\u0026gt; { override fun apply(project: Project) { when { //如果依赖booster插件的module是application类型 project.plugins.hasPlugin(\u0026#34;com.android.application\u0026#34;) || project.plugins.hasPlugin(\u0026#34;com.android.dynamic-feature\u0026#34;) -\u0026gt; project.getAndroid\u0026lt;AppExtension\u0026gt;().let { android -\u0026gt; //注册BoosterAppTransform android.registerTransform(BoosterAppTransform()) //project.afterEvaluate监听module配置阶段完成后 project.afterEvaluate { //通过ServiceLoader来找到所有的VariantProcessor子类，它是spi模块中定义的 ServiceLoader.load(VariantProcessor::class.java, javaClass.classLoader).toList().let { processors -\u0026gt; //首先遍历应用中所有的变体 android.applicationVariants.forEach { variant -\u0026gt; //遍历所有的VariantProcessor，把变体传到VariantProcessor的process方法中 processors.forEach { processor -\u0026gt; processor.process(variant) } } } } } //如果依赖booster插件的module是library类型 project.plugins.hasPlugin(\u0026#34;com.android.library\u0026#34;) -\u0026gt; project.getAndroid\u0026lt;LibraryExtension\u0026gt;().let { android -\u0026gt; //BoosterLibTransform android.registerTransform(BoosterLibTransform()) project.afterEvaluate { ServiceLoader.load(VariantProcessor::class.java, javaClass.classLoader).toList().let { processors -\u0026gt; android.libraryVariants.forEach { variant -\u0026gt; processors.forEach { processor -\u0026gt; processor.process(variant) } } } } } } } } 我们只看当前module是application类型的，library类型的module处理基本一致。首先注册BoosterAppTransform，然后监听project配置阶段完成，然后通过ServiceLoader找到所有的VariantProcessor子类，它是task.spi模块下的一个接口，然后调用所有子类的process方法，先来看下VariantProcessor接口的定义：\n1 2 3 4 5 6 7 8 9 package com.didiglobal.booster.task.spi import com.android.build.gradle.api.BaseVariant interface VariantProcessor { fun process(variant: BaseVariant) } 比如在toast模块下有如下子类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.didiglobal.booster.transform.toast import com.android.build.gradle.api.BaseVariant import com.android.build.gradle.api.LibraryVariant import com.didiglobal.booster.gradle.isDynamicFeature import com.didiglobal.booster.gradle.scope import com.didiglobal.booster.gradle.variantData import com.didiglobal.booster.task.spi.VariantProcessor import com.google.auto.service.AutoService @AutoService(VariantProcessor::class) class ToastVariantProcessor : VariantProcessor { override fun process(variant: BaseVariant) { //如果变体不是LibraryVariant，LibraryVariant只出现在library的module中，并且变体不是一个动态模块，动态模块是Android App Bundle(.aab)结构中一的一部分，允许按需下载和安装模块，然后添加instrument-toast的aar依赖 if (variant !is LibraryVariant \u0026amp;\u0026amp; !variant.variantData.isDynamicFeature()) { variant.scope.globalScope.project.dependencies.add(\u0026#34;implementation\u0026#34;, \u0026#34;${Build.GROUP}:booster-android-instrument-toast:${Build.VERSION}\u0026#34;) } } } 通过AutoService注解找到ToastVariantProcessor这个子类，而上面分析boosterPlugin的时候，VariantProcessor的process方法是在配置完后调用的，也就是每一个module的build.gradle解析完事之后。ToastVariantProcessor中的process方法判断如果变体不是LibraryVariant，LibraryVariant只出现在library的module中，并且变体不是一个动态模块，动态模块是Android App Bundle(.aab)结构中一的一部分，允许按需下载和安装模块，然后添加instrument-toast的aar依赖。\n来看下booster-android-instrument-toast的主要构成： 这不就是上面要将Toast的调用要替换成目标ShadowToast类吗？所以不难看出，其实对应的booster-android-instrument-toast模块就是将ShadowToast引入进来，方便asm操作字节码的时候能够替换，下面来看下如何替换的字节码。\n我们回到上面注册的BoosterAppTransform，它是核心流程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.didiglobal.booster.gradle import com.android.build.api.transform.QualifiedContent /** * Represents android transform for application project * * @author johnsonlee */ class BoosterAppTransform : BoosterTransform() { override fun getScopes(): MutableSet\u0026lt;in QualifiedContent.Scope\u0026gt; = SCOPE_FULL_WITH_FEATURES } 它是继承自BoosterTransform，所以接着看BoosterTransform的transform方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 final override fun transform(invocation: TransformInvocation?) { invocation?.let { //BoosterTransformInvocation是一个代理类 BoosterTransformInvocation(it).apply { //① dumpInputs(this) //② if (isIncremental) { //③ onPreTransform(this) doIncrementalTransform() } else { buildDir.file(AndroidProject.FD_INTERMEDIATES, \u0026#34;transforms\u0026#34;, \u0026#34;dexBuilder\u0026#34;).let { dexBuilder -\u0026gt; if (dexBuilder.exists()) { dexBuilder.deleteRecursively() } } outputProvider.deleteAll() onPreTransform(this) doFullTransform() } //④ this.onPostTransform(this) }.executor.apply { shutdown() awaitTermination(1, TimeUnit.MINUTES) } } } //将扫描到的jar写到inputs.txt文件中 private fun dumpInputs(invocation: BoosterTransformInvocation) { //invocation.context.temporaryDir：获取当前transform的临时目录，然后创建inputs.txt文件 invocation.context.temporaryDir.file(\u0026#34;inputs.txt\u0026#34;).touch().printWriter().use { printer -\u0026gt; invocation.inputs.flatMap { it.jarInputs }.map { it.file }.forEach(printer::println) } } 在transform方法中TransformInvocation对象是Transform核心类，它是获取所有class和输出class的处理类。接着将TransformInvocation代理到了BoosterTransformInvocation中，它是一个静态代理模式。在①处，dumpInputs方法将项目中使用到的jar都打印到transform的临时目录中的inputs.txt中： 不知道这个是干嘛的，可能是为了记录所有的jar吧。在②处，判断是不是增量编译，默认是增量的，在③处，调用了BoosterTransformInvocation的onPreTransform，接着调用了doIncrementalTransform，在④处，调用了onPostTransform，这些都是BoosterTransformInvocation的方法，注意了最后是调用了executor的shutdown和awaitTermination方法。此处的executor是一个ForkJoinPool。所以重点来到BoosterTransformInvocation：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 internal class BoosterTransformInvocation(private val delegate: TransformInvocation) : TransformInvocation, TransformContext, TransformListener, ArtifactManager { /* * Preload transformers as List to fix NoSuchElementException caused by ServiceLoader in parallel mode */ private val transformers = ServiceLoader.load(Transformer::class.java, javaClass.classLoader).toList() override fun onPreTransform(context: TransformContext) = transformers.forEach { it.onPreTransform(this) } @Suppress(\u0026#34;NON_EXHAUSTIVE_WHEN\u0026#34;) internal fun doIncrementalTransform() { //① this.inputs.parallelStream().forEach { input -\u0026gt; //② input.jarInputs.parallelStream().filter { it.status != NOTCHANGED }.forEach { jarInput -\u0026gt; when (jarInput.status) { REMOVED -\u0026gt; jarInput.file.delete() CHANGED, ADDED -\u0026gt; { //③ val root = outputProvider.getContentLocation(jarInput.name, jarInput.contentTypes, jarInput.scopes, Format.JAR) project.logger.info(\u0026#34;Transforming ${jarInput.file}\u0026#34;) //④ jarInput.file.transform(root) { bytecode -\u0026gt; //⑤ bytecode.transform(this) } } } } input.directoryInputs.parallelStream().forEach { dirInput -\u0026gt; val base = dirInput.file.toURI() dirInput.changedFiles.ifNotEmpty { it.forEach { file, status -\u0026gt; when (status) { REMOVED -\u0026gt; file.delete() ADDED, CHANGED -\u0026gt; { val root = outputProvider.getContentLocation(dirInput.name, dirInput.contentTypes, dirInput.scopes, Format.DIRECTORY) project.logger.info(\u0026#34;Transforming $file\u0026#34;) file.transform(File(root, base.relativize(file.toURI()).path)) { bytecode -\u0026gt; bytecode.transform(this) } } } } } } } } private fun ByteArray.transform(invocation: BoosterTransformInvocation): ByteArray { return transformers.fold(this) { bytes, transformer -\u0026gt; transformer.transform(invocation, bytes) } } override fun onPostTransform(context: TransformContext) = transformers.forEach { it.onPostTransform(this) } } 这里我把几个重点方法给搬过来了，BoosterTransformInvocation继承自TransformInvocation，而构造器中传入了BoosterTransform中的TransformInvocation，最终代理到了这个TransformInvocation。在onPreTransform中遍历Transformer，然后调用onPreTransform。 在doIncrementalTransform的①处中通过parallelStream遍历TransformInput集合，其中parallelStream是集合流的一种处理方式，它能并行遍历对象，一般适合大量数据的时候，在②处遍历TransformInput中的jarInputs，如果是REMOVED状态则直接删除，如果是更新、添加状态，则会走到③处，通过TransformOutputProvider获取到jar的输出路径。在④处拿到jar的file对象，然后调用扩展的transform，获取到jar中的byteArray。经过⑤处的byteArray的transform操作后，也就是字节码操作，然后在jar的transform中再写回到③中的root中。下面看下File的transform扩展方法是如何获取到byteArray，并回写到root中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Transform this file or directory to the output by the specified transformer * * @param output The output location * @param transformer The byte data transformer */ fun File.transform(output: File, transformer: (ByteArray) -\u0026gt; ByteArray = { it -\u0026gt; it }) { when { isDirectory -\u0026gt; { val base = this.toURI() this.search().forEach { it.transform(File(output, base.relativize(it.toURI()).path), transformer) } } isFile -\u0026gt; { when (output.extension.toLowerCase()) { //如果当前file是一个jar，① \u0026#34;jar\u0026#34; -\u0026gt; JarFile(this).use { //② it.transform(output, ::JarArchiveEntry, transformer) } //如果当前file是一个class，③ \u0026#34;class\u0026#34; -\u0026gt; inputStream().use { logger.info(\u0026#34;Transforming ${this.absolutePath}\u0026#34;) //④ it.transform(transformer).redirect(output) } else -\u0026gt; this.copyTo(output, true) } } else -\u0026gt; TODO(\u0026#34;Unexpected file: ${this.absolutePath}\u0026#34;) } } 整个transform方法，有两个参数一个是目标路径，第二个参数就是字节码操作的闭包。闭包返回的是ByteArray，也就是修改前的字节码数据。 在①处，如果当前File是一个jar的时候，会初始化一个JarFile，然后调用use扩展函数，其中use方法是对Closeable类型做的异常处理，流的关闭处理。在②处调用JarFile的transform扩展函数，其中JarFile是ZipFile的子类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 fun ZipFile.transform(output: File, entryFactory: (ZipEntry) -\u0026gt; ZipArchiveEntry = ::ZipArchiveEntry, transformer: (ByteArray) -\u0026gt; ByteArray = { it -\u0026gt; it }) { //① val creator = ParallelScatterZipCreator(Executors.newWorkStealingPool()) val entries = mutableSetOf\u0026lt;String\u0026gt;() //② entries().asSequence().forEach { entry -\u0026gt; //③ if (!entries.contains(entry.name)) { //④ val zae = entryFactory(entry) //⑤ val stream = InputStreamSupplier { when (entry.name.substringAfterLast(\u0026#39;.\u0026#39;, \u0026#34;\u0026#34;)) { //⑥ \u0026#34;class\u0026#34; -\u0026gt; getInputStream(entry).use { src -\u0026gt; logger.info(\u0026#34;Transforming ${this.name}!/${entry.name}\u0026#34;) src.transform(transformer).inputStream() } //⑦ else -\u0026gt; getInputStream(entry) } } //⑧ creator.addArchiveEntry(zae, stream) entries.add(entry.name) } else { logger.error(\u0026#34;Duplicated jar entry: ${this.name}!/${entry.name}\u0026#34;) } } //⑨ ZipArchiveOutputStream(output.touch()).use { it -\u0026gt; creator.writeTo(it) } } 在①处创建ParallelScatterZipCreator，它是多线程并行压缩多个文件，然后再合并到一个总的压缩文件中，常见的ZipOutputStream是单线程进行压缩所有的文件。在②处拿到ZipFile的entries数组，然后调用asSequence进行遍历，entries方法是一个ZipEntryIterator对象，其实它也有toList方法，在此处都是遍历，其实和list没有区别，Sequence区别是在处理中间操作符的时候不会创建临时的集合对象，比如map，filter等。在③主要是去重，在④处将ZipEntry转化成ZipArchiveEntry，方便给到ParallelScatterZipCreator。在⑤处构建InputStreamSupplier，它是一个接口，在get方法中返回InputStream，方便使用闭包。在⑥处通过ZipEntry获取到对应的inputStream，然后调用src（inputStream）的transform扩展方法，并把transformer闭包传入其中：\n1 2 3 fun InputStream.transform(transformer: (ByteArray) -\u0026gt; ByteArray): ByteArray { return transformer(readBytes()) } 可以看到通过InputStream的readBytes扩展方法获取到ByteArray：\n1 2 3 4 5 private fun InputStream.readBytes(estimatedSize: Int = DEFAULT_BUFFER_SIZE): ByteArray { val buffer = ByteArrayOutputStream(Math.max(estimatedSize, this.available())) copyTo(buffer) return buffer.toByteArray() } 其中最终通过构造ByteArrayOutputStream对象，然后调用InputStream的copyTo扩展方法将buffer复制到ByteArrayOutputStream中L\n1 2 3 4 5 6 7 8 9 10 11 private fun InputStream.copyTo(out: OutputStream, bufferSize: Int = DEFAULT_BUFFER_SIZE): Long { var bytesCopied: Long = 0 val buffer = ByteArray(bufferSize) var bytes = read(buffer) while (bytes \u0026gt;= 0) { out.write(buffer, 0, bytes) bytesCopied += bytes bytes = read(buffer) } return bytesCopied } 获取到file的byteArray后，交给了transformer进行修改字节码，剩下就是写回到目标路径中，回到上面ZipFile的transform⑥处，最终将ByteArray通过inputStream扩展方法转化成 ByteArrayInputStream：\n1 2 @kotlin.internal.InlineOnly public inline fun ByteArray.inputStream(): ByteArrayInputStream = ByteArrayInputStream(this) 所以最终的ByteArrayInputStream给到了⑤处InputStreamSupplier的get方法返回值了。在⑦中，如果不是class类型的entry，则不进行transform的闭包修改。在⑧处将修改后的InputStream添加到ParallelScatterZipCreator中，并添加到entries集合中，方便去重。在⑨处，通过ZipArchiveOutputStream的输出流回写到output目标文件中。整个修改并回写过程分为这9大步骤。关于file是目录结构和非目录结构中的class文件处理就不说了，代码很简单。\nBoosterTransformInvocation中全量编译过程就不分析了，和增量编译大差不差。\n小结： booster中修改字节码过程是在BoosterTransformInvocation中，它将具体的修改交给了Transformer的子类，其中修改步骤是先遍历TransformInput中JarInput和directoryInput的class文件，然后获取到class的byteArray，然后经过Transformer子类的transform方法修改byteArray，修改完后，再回写到原始class对应的目录中，这样就达到了修改并覆盖class的目的。\nbooster-transform-asm 前面分析了boosterPlugin中会遍历Transform的子类然后执行它的transform方法，其中AsmTransformer是实现了Transformer接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @AutoService(Transformer::class) class AsmTransformer : Transformer { /* * Preload transformers as List to fix NoSuchElementException caused by ServiceLoader in parallel mode */ private val transformers = ServiceLoader.load(ClassTransformer::class.java, javaClass.classLoader).toList() override fun transform(context: TransformContext, bytecode: ByteArray): ByteArray { return ClassWriter(ClassWriter.COMPUTE_MAXS).also { writer -\u0026gt; transformers.fold(ClassNode().also { klass -\u0026gt; ClassReader(bytecode).accept(klass, 0) }) { klass, transformer -\u0026gt; transformer.transform(context, klass) }.accept(writer) }.toByteArray() } override fun onPreTransform(context: TransformContext) { transformers.forEach { it.onPreTransform(context) } } override fun onPostTransform(context: TransformContext) { transformers.forEach { it.onPostTransform(context) } } } AsmTransformer通过AutoService注解被扫描到是Transformer的子类，我们将它的transform写成如下方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 override fun transform(context: TransformContext, bytecode: ByteArray): ByteArray { // ClassNode是ASM tree API的类 var classNode = ClassNode() val classReader = ClassReader(bytecode) // accept()方法，读取bytecode的相关.class信息赋值到classNode对象的相应字段 classReader.accept(classNode,0) transformers.foreach { transformer -\u0026gt; // 每次transform后，class的内容变化都缓存在classNodes中 // 注意此时的classNode对象的内容就是bytecode的内容，只是格式不同而已 transformer.transform(context, classNode) } //ClassWriter是ASM core API的类 ，专门用来写出修改后class的类 val classWriter = ClassWriter(ClassWriter.COMPUTE_MAXS) //将写好后的classNode回写到classWriter中 classNode.accept(classWriter) // classWriter把被洗礼后的classNode，即ClassNode对象， // 写成ByteArray返回到上层BoosterTransformInvocation return classWriter.toByteArray() } 小结: 可以发现asm字节码操作，基本都是模版代码，首先通过classReader读取到byteArray（在前面学习asm的时候，是通过FileInputStream来读取的），然后把class信息映射到classNode对象上。然后遍历字节码操作类，将要修改的classNode给到操作类，修改完后，将classNode同步到classWriter上，最后把修改后的byteArray回写到上层中。\nbooster-transform-toast 上面分析过会通过ClassTransformer的子类来修改字节码，toast字节码的修改是在ToastTransformer这个子类中，主要来看下它的transform方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 private const val TOAST = \u0026#34;android/widget/Toast\u0026#34; private const val SHADOW_TOAST = \u0026#34;com/didiglobal/booster/instrument/ShadowToast\u0026#34; override fun transform(context: TransformContext, klass: ClassNode): ClassNode { //① if (klass.name == SHADOW_TOAST) { return klass } klass.methods.forEach { method -\u0026gt; //② method.instructions?.iterator()?.asIterable()?.filterIsInstance(MethodInsnNode::class.java)?.filter { //③ it.opcode == Opcodes.INVOKEVIRTUAL \u0026amp;\u0026amp; it.name == \u0026#34;show\u0026#34; \u0026amp;\u0026amp; it.desc == \u0026#34;()V\u0026#34; \u0026amp;\u0026amp; (it.owner == TOAST || context.klassPool.get(TOAST).isAssignableFrom(it.owner)) }?.forEach { //④ it.optimize(klass, method) } } return klass } //⑤ private fun MethodInsnNode.optimize(klass: ClassNode, method: MethodNode) { logger.println(\u0026#34; * ${this.owner}.${this.name}${this.desc} =\u0026gt; $SHADOW_TOAST.apply(L$SHADOW_TOAST;)V: ${klass.name}.${method.name}${method.desc}\u0026#34;) this.owner = SHADOW_TOAST this.name = \u0026#34;show\u0026#34; this.desc = \u0026#34;(L$TOAST;)V\u0026#34; this.opcode = Opcodes.INVOKESTATIC this.itf = false } 上面transform方法中，在①处如果当前class是com/didiglobal/booster/instrument/ShadowToast，则不处理，在②处通过method.instructions拿到当前方法的所有的指令集，然后通过filterIsInstance过滤是方法调用指令，比如INVOKEVIRTUAL、INVOKESTATIC、INVOKESPECIAL 和 INVOKEINTERFACE，因为MethodInsnNode代表的是方法调用指令。所以在③处通过opcode、name、desc、owner来判断是不是要修改的字节码，我们可以通过工具来看下： 可以看到，修改前的字节码的opcode=invokevirtual，name=show，desc = ()V，owner = android/widget/Toast，所以通过上面的过滤条件，就能过滤出要修改的指令。在④处，调用了MethodInsnNode的扩展方法optimize，在⑤处就是修改字节码了，如果不知道修改后的字节码，我们可以借助工具查看： 可以看到最终的opcode= invokestatic，name = show，desc = (Landroid/widget/Toast;)V，owner = com/didiglobal/booster/instrument/ShadowToast。和上面optimize方法中修改的指令一样，新加了itf = false，表示新替换的owner是否是接口，此处的ShadowToast不是一个接口，所以为false，这就是替换指令的过程，是不是很简单。\n下面来实操一波，将某个类中的方法调用改成其它的方法调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.xc.asm; public class Main { public static void main(String[] args) { System.out.println(\u0026#34;Hello world!\u0026#34;); } public static void test(){ System.out.println(\u0026#34;Main中的test方法\u0026#34;); } public static void test1(){ System.out.println(\u0026#34;Main中的test1方法\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 package com.xc.asm; public class C { public void m() throws Exception { Thread.sleep(100); } public void n(){ Main.test(); } } 在C类中调用了Main类中的test静态方法，我们这里是想把调用test方法给替换成test1方法，话不多说，直接撸🐴：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class MethodReplaceTest { public static void main(String[] args) throws Exception { Class clazz = C.class; String clazzFilePath = Utils.getClassFilePath(clazz); ClassReader classReader = new ClassReader(new FileInputStream(clazzFilePath)); //ClassWriter.COMPUTE_FRAMES表示自动计算方法栈数 ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES); //通过构造一个新的classVisitor，然后将classWriter传入到该classVistor中，实际干活的还是classWriter，MethodReplaceClassVisitor只是作为一个代理类，进行添加属性 MethodReplaceClassVisitor methodReplaceClassVisitor = new MethodReplaceClassVisitor(Opcodes.ASM5, classWriter); classReader.accept(methodReplaceClassVisitor, 0); // 写入文件 byte[] bytes = classWriter.toByteArray(); FileOutputStream fos = new FileOutputStream(clazzFilePath); fos.write(bytes); fos.flush(); fos.close(); //验证结果 C c = new C(); c.n(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class MethodReplaceClassVisitor extends ClassVisitor { protected MethodReplaceClassVisitor(int api, ClassVisitor classVisitor) { super(api, classVisitor); } @Override public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) { MethodVisitor methodVisitor = super.visitMethod(access, name, descriptor, signature, exceptions); if(name.equals(\u0026#34;n\u0026#34;)){ return new MethodReplaceMethodVisitor(Opcodes.ASM5,methodVisitor); } return methodVisitor; } } 1 2 3 4 5 6 7 8 9 10 11 12 public class MethodReplaceMethodVisitor extends MethodVisitor { protected MethodReplaceMethodVisitor(int api, MethodVisitor methodVisitor) { super(api, methodVisitor); } @Override public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) { if (mv != null) { mv.visitMethodInsn(Opcodes.INVOKESTATIC,\u0026#34;com/xc/asm/Main\u0026#34;,\u0026#34;test1\u0026#34;,\u0026#34;()V\u0026#34;,false); } } } 关于asm的基础操作就不多说了，主要看下MethodReplaceMethodVisitor的visitMethodInsn方法是操作方法指令的，通过传进来的MethodVisitor，来进行修改指令，其中指令中的name字段传test1，其余的字段和原来调用test方法一致的。\n参考: 滴滴开源库Booster:架构运作及源码分析\n","date":"2025-02-17T00:00:00Z","permalink":"http://xiangcman.xyz/p/booster%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","title":"booster源码分析"},{"content":"gradle的很多插件涉及到了字节码修改，内部修改字节码基本都是通过asm来修改，本文章就是通过asm来修改class。本文基于intellij idea来体验的。\n下载依赖 首先我创建的工程是一个java工程，然后将项目配置成maven工程： 接着去maven官网找下对应依赖： 然后在工程里面添加依赖： 读取class 首先定义一个普通的类： 1 2 3 4 5 6 7 8 9 10 11 public class User { private String name;//Ljava/lang/String表示string类型 private int age;//I表示int类型 private long lang;//在class中J表示long类型 public String getName() { return name; } public int getAge() { return age; } } 读取到User类对应class的路径 1 2 3 4 5 6 7 8 9 public class Utils { public static String getClassFilePath(Class clazz) { // file:/Users/xiangcheng/IdeaProject/Asm/target/classes/ String buildDir = clazz.getProtectionDomain().getCodeSource().getLocation().getFile();//获取到文件所在位置 String fileName = clazz.getSimpleName() + \u0026#34;.class\u0026#34;; File file = new File(buildDir + clazz.getPackage().getName().replaceAll(\u0026#34;[.]\u0026#34;, \u0026#34;/\u0026#34;) + \u0026#34;/\u0026#34;, fileName); return file.getAbsolutePath(); } } 通过ClassReader获取到class的读取 1 2 3 4 Class clazz = User.class; String clazzFilePath = Utils.getClassFilePath(clazz); //首先通过class的路径获取到classReader，然后通过classReader的accept方法，传入一个classNode，然后使用classNode获取到方法和属性 ClassReader classReader = new ClassReader(new FileInputStream(clazzFilePath)); 通过classReader获取到classNode 1 2 ClassNode classNode = new ClassNode(Opcodes.ASM5); classReader.accept(classNode, 0); ClassNode读取方法和属性 1 2 3 4 5 6 7 8 9 10 List\u0026lt;MethodNode\u0026gt; methods = classNode.methods; List\u0026lt;FieldNode\u0026gt; fields = classNode.fields; System.out.println(\u0026#34;methods:\u0026#34;); for (MethodNode methodNode : methods) { System.out.println(methodNode.name + \u0026#34;, \u0026#34; + methodNode.desc); } System.out.println(\u0026#34;fields:\u0026#34;); for (FieldNode fieldNode : fields) { System.out.println(fieldNode.name + \u0026#34;, \u0026#34; + fieldNode.desc); } 获取信息如下：\n1 2 3 4 5 6 7 8 methods: \u0026lt;init\u0026gt;, ()V getName, ()Ljava/lang/String; getAge, ()I fields: name, Ljava/lang/String; age, I lang, J 我们通过jclasslib验证下： 其中属性的名字，描述符，访问标识都和上面的对应的上。方法也是如此。 上面是通过classNode树形结构访问的，下面通过visit回调的形式访问属性和方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Class clazz = User.class; String clazzFilePath = Utils.getClassFilePath(clazz); ClassReader classReader = new ClassReader(new FileInputStream(clazzFilePath)); //前面介绍的classNode是继承自classVisitor，classNode是把所有的方法和属性全部都读到内存中，然后再遍历，ClassVisitor边读边遍历 ClassVisitor classVisitor = new ClassVisitor(Opcodes.ASM5) { @Override public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) { System.out.println(\u0026#34;visit field:\u0026#34; + name + \u0026#34; , desc = \u0026#34; + descriptor); return super.visitField(access, name, descriptor, signature, value); } @Override public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) { System.out.println(\u0026#34;visit method:\u0026#34; + name + \u0026#34; , desc = \u0026#34; + descriptor); return super.visitMethod(access, name, descriptor, signature, exceptions); } }; classReader.accept(classVisitor, 0); 通过ClassVisitor也能访问到属性和方法，上面介绍的ClassNode是继承自ClassVisitor，ClassVisitor是边读边遍历，而ClassNode是把方法和属性全部都读到内存中，然后再遍历。\n修改class 上面介绍的都是读取class，我们最终的目的是修改class，下面也通过一个🌰来介绍如何修改class，还是先来一个类：\n1 2 3 4 5 6 7 public class C { public void m() throws Exception { Thread.sleep(100); } } 我们要把它修改成如下：\n1 2 3 4 5 6 7 8 9 public class C { public static long timer; public void m() throws Exception { timer -= System.currentTimeMillis(); Thread.sleep(100L); timer += System.currentTimeMillis(); } } asm修改字节码先通过ClassReader把class信息读取到，然后通过ClassWriter把修改后的class再写会到文件里面，先介绍下通过ClassWriter把class写到文件中：\n1 2 3 4 5 6 7 8 9 10 11 12 Class clazz = C.class; String clazzFilePath = Utils.getClassFilePath(clazz); ClassReader classReader = new ClassReader(new FileInputStream(clazzFilePath)); ClassWriter classWriter = new ClassWriter(0); classReader.accept(classWriter, 0); // 写入文件 byte[] bytes = classWriter.toByteArray(); String buildDir = clazz.getProtectionDomain().getCodeSource().getLocation().getFile(); FileOutputStream fos = new FileOutputStream(buildDir + clazz.getPackage().getName().replaceAll(\u0026#34;[.]\u0026#34;, \u0026#34;/\u0026#34;) +\u0026#34;/copyed.class\u0026#34;); fos.write(bytes); fos.flush(); fos.close(); 可以看到classReader的accept方法也可以接受一个classWriter对象，它也是继承自classVisitor，然后把它转化成byte数组，最后通过文件输出流把byte数组写会到文件中，整个过程很简单。修改class也是如此把修改后的byte数组也是写会到文件中的。\n在上面我们知道classVisitor是读取class的核心类，最终把该classVistor传到accept方法中，而classWriter也需要传到accept方法中。所以看下两者都要使用的话，该怎么处理： 可以看到构造器中可以传入classVisitor，最终里面的所有visit**方法都是调用了传入进来的classVisitor方法。所以不难看出来这是个代理模式，传入进来的classVisitor是一个被代理对象，该classVisitor是一个代理对象，首先自定义一个classVisitor：\n1 2 3 4 5 6 public class AddTimerClassVisitor extends ClassVisitor { public AddTimerClassVisitor(int api, ClassVisitor classVisitor) { super(api, classVisitor); } } 然后看下怎么调用AddTimerClassVisitor：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Class clazz = C.class; String clazzFilePath = Utils.getClassFilePath(clazz); ClassReader classReader = new ClassReader(new FileInputStream(clazzFilePath)); //ClassWriter.COMPUTE_FRAMES表示自动计算方法栈数 ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES); //通过构造一个新的classVisitor，然后将classWriter传入到该classVistor中，实际干活的还是classWriter，AddTimerClassVisitor只是作为一个代理类，进行添加属性 AddTimerClassVisitor addTimerClassVisitor = new AddTimerClassVisitor(Opcodes.ASM5, classWriter); classReader.accept(addTimerClassVisitor, 0); // 写入文件 byte[] bytes = classWriter.toByteArray(); FileOutputStream fos = new FileOutputStream(clazzFilePath); fos.write(bytes); fos.flush(); fos.close(); 将ClassWriter传到AddTimerClassVisitor中，可以看出来ClassWriter是被代理的对象，AddTimerClassVisitor是代理对象，在前面我们通过重写visitField访问到属性，通过visitMethod访问到方法，这两个方法是多次被调用，而我们是想添加一个静态的timer属性，和修改方法m，那此时visitField肯定不会被调用到，在class开始访问和结束访问的时候会分别调用visit和visitEnd方法，那添加timer属性可以放到visitEnd中，修改方法可以在visitMethod中通过过滤来达到修改的目的，而最终的字节码照样可以先把结果通过jclasslib来查看： 在class中名字是timer，描述符是J，访问标志是public+static，那么通过asm如何添加该属性：\n1 2 3 4 5 6 7 8 9 10 11 @Override public void visitEnd() { System.out.println(\u0026#34;AddTimerClassVisitor visitEnd\u0026#34;); //通过visitField方法添加属性,cv是传进来的classWriter，实际干活的还是classWriter，此处用到了代理模式 FieldVisitor fv = cv.visitField(Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC, \u0026#34;timer\u0026#34;, \u0026#34;J\u0026#34;, null, null);//visitField方法第一个参数定义访问标志，它是public+static类型，第二个参数是参数的名字，第三个参数是参数的描述符，表示什么类型，long类型用J表示 if (fv != null) { fv.visitEnd(); } cv.visitEnd(); } 通过cv（传进来的classWriter）来访问属性来添加timer属性，和上面用jclasslib工具查看的结果一样。下面再看下如果修改m方法：\n1 2 3 4 5 6 7 8 9 10 @Override public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) { System.out.println(\u0026#34;AddTimerClassVisitor visitMethod\u0026#34;); MethodVisitor methodVisitor = super.visitMethod(access, name, descriptor, signature, exceptions); if (methodVisitor != null \u0026amp;\u0026amp; !name.equals(\u0026#34;\u0026lt;init\u0026gt;\u0026#34;)) { NewMethodVisitor newMethodVisitor = new NewMethodVisitor(Opcodes.ASM5, methodVisitor, mOwner); return newMethodVisitor; } return methodVisitor; } 首先是拿到当前的MethodVisitor，然后判断方法不是构造函数，最后放回一个新的NewMethodVisitor，否则返回原来的MethodVisitor，下来来看下NewMethodVisitor如何修改方法m，先看下jclasslib修改后class的方法m： 其实我们通过javap -v com.xc.asm.C来查看字节码： 更多的javap命令如下： 有了上面反编译的字节码后，其实就是asm对应的方法操作了，在NewMethodVisitor中重写visitCode方法，在访问该方法之前添加对应的字节码，重写visitInsn方法，在方法return之前添加对应的字节码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class NewMethodVisitor extends MethodVisitor { private String mOwner; public NewMethodVisitor(int api, MethodVisitor methodVisitor, String mOwner) { super(api, methodVisitor); this.mOwner = mOwner; } @Override public void visitCode() { mv.visitCode(); mv.visitFieldInsn(GETSTATIC, mOwner, \u0026#34;timer\u0026#34;, \u0026#34;J\u0026#34;); mv.visitMethodInsn(INVOKESTATIC, \u0026#34;java/lang/System\u0026#34;, \u0026#34;currentTimeMillis\u0026#34;, \u0026#34;()J\u0026#34;); mv.visitInsn(LSUB); mv.visitFieldInsn(PUTSTATIC, mOwner, \u0026#34;timer\u0026#34;, \u0026#34;J\u0026#34;); } @Override public void visitInsn(int opcode) { if ((opcode \u0026gt;= IRETURN \u0026amp;\u0026amp; opcode \u0026lt;= RETURN) || opcode == ATHROW) { mv.visitFieldInsn(GETSTATIC, mOwner, \u0026#34;timer\u0026#34;, \u0026#34;J\u0026#34;); mv.visitMethodInsn(INVOKESTATIC, \u0026#34;java/lang/System\u0026#34;, \u0026#34;currentTimeMillis\u0026#34;, \u0026#34;()J\u0026#34;); mv.visitInsn(LADD); mv.visitFieldInsn(PUTSTATIC, mOwner, \u0026#34;timer\u0026#34;, \u0026#34;J\u0026#34;); } mv.visitInsn(opcode); } } 可以结合上面的反编译的字节码，对应着看asm的操作。最后asm操作完后，就是通过输出流把byte数组写会到文件中。\n参考: Android 进阶之路：ASM 修改字节码，这样学就对了！ asm依赖 asm官网 jclasslib\n","date":"2025-02-10T00:00:00Z","permalink":"http://xiangcman.xyz/p/asm%E4%BF%AE%E6%94%B9%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%9D%E4%BD%93%E9%AA%8C/","title":"asm修改字节码初体验"},{"content":"平时工作中需要经常变jdk的版本配置，使用jenv来管理jdk的时候，不用来回配置环境变量。\n安装jenv 1 brew install jenv 配置.zshrc 1 2 export PATH=\u0026#34;$HOME/.jenv/bin:$PATH\u0026#34; eval \u0026#34;$(jenv init -)\u0026#34; 同步.zshrc 1 source ~/.zshrc 查看本机安装了哪些jdk 1 /usr/libexec/java_home -V 结果如下： 添加jdk 1 2 3 jenv add /Users/xiangcheng/Library/Java/JavaVirtualMachines/corretto-18.0.2/Contents/Home jenv add /Users/xiangcheng/Library/Java/JavaVirtualMachines/corretto-11.0.23/Contents/Home jenv add /Users/xiangcheng/Library/Java/JavaVirtualMachines/corretto-1.8.0_412/Contents/Home 查看jenv管理的jdk版本 1 jenv versions 结果如下： 切换全局的jdk版本 1 jenv global 18 当前 shell 切换 JDK 1 jenv shell 18 项目目录指定 JDK 1 2 cd ~/my_project jenv local 18 ","date":"2025-02-10T00:00:00Z","permalink":"http://xiangcman.xyz/p/%E4%BD%BF%E7%94%A8jenv%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAjdk/","title":"使用jenv管理多个jdk"},{"content":"zsh的插件分为预装的插件和自定义的插件，自定义插件在.oh-my-zsh/custom文件夹下，预装的插件在plugins文件夹下： 我是装了4个自定义插件，关于自定义插件的安装可以在对应的插件介绍中找到\nsublime插件 sublime插件能快速打开某个文件或文件，并在sublime应用中展示。它是预装的插件，所以不用单独安装 使用：\n1 2 st . # 打开当前目录 st myfile.txt # 打开 myfile.txt 参考： ohmyzsh zsh-autosuggestions zsh-completions zsh-syntax-highlighting\n","date":"2025-02-08T00:00:00Z","permalink":"http://xiangcman.xyz/p/oh-my-zsh%E6%8F%92%E4%BB%B6%E5%BF%85%E5%A4%87/","title":"oh-my-zsh插件必备"},{"content":"Gradle基础 gradle是一个脚本框架，用来构建android程序的一个脚本，在认识前，我们先以最基础的方式来认识它。\ngradle配置 首先在官网下载对应的版本，这里我选择6.6.1-all的版本，下载完后，放到指定的目录，然后配置gradle的环境变量:\nopen -e .bash_profile 打开配置文件 添加 GRADLE_HOME、PATH 1 2 3 4 5 6 7 export GRADLE_HOME=/Users/xiangcheng/gradle/gradle-6.6.1 export PATH=${PATH}:/Users/xiangcheng/gradle/gradle-6.6.1/bin ----------------官方写法如下-------------------------------- export GRADLE_HOME=/Users/xiangcheng/gradle/gradle-6.6.1 export PATH=$PATH:$GRADLE_HOME/bin source .bash_profile 重置配置文件，以便新 path 生效 open -e ~/.zshrc 打开另一个配置 在最后一行添加 source ~/.bash_profile source ~/.zshrc 重置配置文件 配置 zshrc 是因为有的机器 bash_profile 配置不管用，添加这个就行了\n运行 gradle \u0026ndash;version，出现版本号则 Gradle 配置成功 注意：gradle版本和jdk版本需要有对应关系： 这里我安装的是gradle-6.6.1的版本，因此我需要设置JDK8，如果本地安装的jdk版本多个的话，mac会使用最高的版本，先查看本地安装了哪些jdk版本 1 /usr/libexec/java_home -V 输出如下：\n1 2 3 4 Matching Java Virtual Machines (3): 18.0.2 (arm64) \u0026#34;Amazon.com Inc.\u0026#34; - \u0026#34;Amazon Corretto 18\u0026#34; /Users/xiangcheng/Library/Java/JavaVirtualMachines/corretto-18.0.2/Contents/Home 11.0.23 (arm64) \u0026#34;Amazon.com Inc.\u0026#34; - \u0026#34;Amazon Corretto 11\u0026#34; /Users/xiangcheng/Library/Java/JavaVirtualMachines/corretto-11.0.23/Contents/Home 1.8.0_412 (arm64) \u0026#34;Amazon\u0026#34; - \u0026#34;Amazon Corretto 8\u0026#34; /Users/xiangcheng/Library/Java/JavaVirtualMachines/corretto-1.8.0_412/Contents/Home 所以默认用的是jdk18，我需要改下环境变量，将jdk改成8：\n1 2 export JAVA_HOME=/Users/xiangcheng/Library/Java/JavaVirtualMachines/corretto-1.8.0_412/Contents/Home export PATH=$JAVA_HOME/bin:$PATH 再运行：\n1 source ~/.bash_profile 上面的jdk配置好后，然后找个文件夹，创建build.gradle，然后输入：\n1 println(\u0026#34;hello world!\u0026#34;) 然后用gradle build.gradle运行该文件，输出如下： 说明已经成功了。\ngradle初始化工程 平时都是直接通过as创建工程，下面通过gradle来创建一个工程：\n输入gradle init来初始化 接着会输入相关配置信息： 命令行提示选择项目模板 命令行提示选择开发语言 命令行提示选择脚本语言 输入工程名 输入包名 最终工程创建如下： 和android studio创建的工程结构是一致的。 Gradle Wrapper as创建一个工程的时候，默认会有Gradle Wrapper文件夹，它里面会有个wrapper.properties文件夹，配置了gradle相关信息。 Gradle Wrapper 文件的作用就是可以让你的电脑在不安装配置 Gradle 环境的前提下运行 Gradle 项目，你的机器要是没有配 Gradle 环境，那么你 clone gradle 项目下来，执行 init 命令，会根据 gradle-wrapper.properties 文件中声明的 gradle URL 远程路径去下载 gradle 构建工具，cd 进该项目，执行了./gradlew -v，然后下载了对应版本的gradle，如果此时执行的是gradle -v，就用的是本地配置的环境变量中的gradle版本，此时不会去下载。 然后就可以在项目目录下运行 gradle 命令了，不过还是推荐大家在机器配置统一的 Gradle 环境\ngradlew \u0026ndash;\u0026gt; linux 平台脚本 gradlew.bat \u0026ndash;\u0026gt; window 平台脚本 gradle-wrapper.jar \u0026ndash;\u0026gt; Gradle 下载、管理相关代码 gradle-wrapper.properties \u0026ndash;\u0026gt; Gradle 下载、管理配置参数 gradle-wrapper.properties 文件中参数详解：\ndistributionUrl \u0026ndash;\u0026gt; Gradle 压缩包下载地址\nzipStoreBase \u0026ndash;\u0026gt; 本机存放 Gradle 压缩包主地址\nzipStorePath \u0026ndash;\u0026gt; 本机存放 Gradle 压缩包主路径\nGradle 压缩包完整的路径是 zipStoreBase + zipStorePath distributionBase \u0026ndash;\u0026gt; 本机 Gradle 压缩包解压后主地址\ndistributionPath \u0026ndash;\u0026gt; 本机 Gradle 压缩包解压后路径\nGradle 解压完整的路径是 distributionBase + distributionPath distributionBase 的路径是环境 path 中 GRADLE_USER_HOME 的地址 Windows：C:/用户/你电脑登录的用户名/.gradle/ MAC：～/.gradle/ 你 MAC 要是配了 Gradle 环境变量，distributionBase 就是你自己解压缩的 gradle 路径 这几个地址还是要搞清楚的~\n关于as如果配置统一的gradle版本，可以看如下截图： gradle-wrapper.properties \u0026ndash; 使用 wrapper 也就是 AS 来管理 Gradle Specifiled location \u0026ndash; 使用本地文件，也就是我们自己管理 Gradle，这样每个工程的gradle-wrapper.properties就不起作用了，使用本机配置的gradle版本 gradlw和gradle区别 gradlew实际是一个脚本文件，它是在gradle工程的根目录下面，如果是windows的话，会执行gradlew.bat文件，这个在前面通过命令初始化工程的时候可以看到，其中gradlew脚本会通过gradle/wrapper/gradle-wrapper.jar来使用项目中配置的gradle版本，而gradle命令是使用本机配置的gradle版本。\nGradle中task task可以认为是gradle中最小执行单元，正是因为有了task，gradle框架才能有序的工作。实际上根据 Gradle 构建项目的流程，是先把所有的 .gradle 脚本执行一遍，编译生成对应的 Gradle、Setting、Project 对象，然后根据我们在构建脚本中设置的构建配置，生成一张 Task 组成的：有向无环图，先来看看这张图: 左边表示的是task之间的依赖关系，右边表示的是项目构建过程中要经过的任务，正是因为有了这些任务，项目才能构建出来。\n实际上在gradle构建过程中，会把每一个工程的build.gradle文件会构建成一个project对象，而该project对象由一个个的task组成，比如在构建android项目的时候会有编译java代码的task，编译资源的task等。这些task其实是定义在android插件中，关于插件后面再说。\n比如android工程中有很多我们熟悉的task： 可以看到在build这个分组下面有很多熟悉的task，比如有assemble的task，它是用来打包的task。而它们又依赖其它的task，最终一个个的task被执行完，包也打出来了。 比如我在终端上运行./gradlew build的时候，会执行一大堆的task： Task 是完成一类任务，实际上对应的也是一个对象。而 Task 是由无数个 Action 组成的，Action 代表的是一个个函数、方法，每个 Task 都是一堆 Action 按序组成的执行图，就好像我们在 Class 的 main 函数中按照逻辑调用一系列方法一样。\n创建task 1 2 3 4 5 6 7 8 9 10 11 task hello{ println \u0026#34;hello world\u0026#34; } task(hello2){ println \u0026#34;hello world2\u0026#34; } task (\u0026#39;hello3\u0026#39;){ println \u0026#34;hello world3\u0026#34; } 运行task 通过./gradlew task名来运行task，运行结果如下： 如果是子模块的话，则通过./gradlew 模块名:task名运行task，运行结果如下： 这是在工程的根目录下build.gradle定义的三个task，然后通过./gradlew hello命令来执行hello这个task，而其它两个task也输出日志，是因为这几条日志都是在配置阶段输出，关于gradle的生命周期后面会说。那为什么gradlew执行脚本就在根目录下，还需要./来执行该脚本呢？ 这是因为在终端里面，需要通过./来获取当前目录，如果不加的话，会导致终端在目录下找不到。\n其实task是project的方法，project表示的是模块在初始化阶段会生成，上面使用task hello{}，创建的task实际是传入了action的闭包，它是在构建的时候被调用的： 在创建task的时候可以指定其他属性，可以通过task其他的重载方法来创建：\n1 2 3 task demo1(group: \u0026#34;demo组\u0026#34;,name:\u0026#34;demo2\u0026#34;,description:\u0026#34;我是demo2的task\u0026#34;,action:{ println(\u0026#34;我是demo2 task的action\u0026#34;) }) 比如在构建demo1的时候，申明了其它属性，此处的action跟上面写在括号外面是一回事，只不过此处是通过map来创建的，还有一点，map中指定的name不会生效，会被demo1的名字给覆盖了，目前发现没什么作用，执行结果如下： task.dofirst和dolast doFirst是task执行前要调用的action，doLast是task执行后要调用的action：\n1 2 3 4 5 6 7 8 9 task demo2{ println(\u0026#34;demo2\u0026#34;) doFirst{ println(\u0026#34;demo2 的 doFirst\u0026#34;) } doLast{ println(\u0026#34;demo2 的 doLast\u0026#34;) } } 关于task其它的使用可以在看三方插件的时候再看。\nGradle插件 gradle插件（plugin）是构建项目时候用到的，它其实是由一系列的task组成的，其实android的工程，google已经帮我们实现了android gradle plugin（agp）。google也是遵循了gradle的task依赖法则，构成一个有序无向图。最终去执行一个个的tak。\n插件主要通过定义仓库，然后定义插件的名字，比如安卓中依赖agp是通过如下的方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 buildscript { repositories { google() jcenter() } dependencies { classpath \u0026#39;com.android.tools.build:gradle:3.5.3\u0026#39; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { repositories { google() jcenter() } } buildscript是rootProject的方法，它声明插件的仓库、添加插件专用闭包 allprojects主要是指所有的模块需要的三方依赖库时候的仓库 像上面定了agp插件3.5.3，然后在app模块中通过apply plugin: 'com.android.application'来使用这个插件，而app模块选的android{}就是来自于该插件，我们叫他是DSL配置块。 其实像android{}的实现在插件中是通过delegate+闭包实现 DSL 配置块\n首先把闭包定义好： 1 2 3 4 5 6 7 8 9 10 11 12 def android = { compileSdkVersion 25 buildToolsVersion \u0026#34;25.0.2\u0026#34; // 这个对应相应的方法 defaultConfig { minSdkVersion 15 targetSdkVersion 25 versionCode 1 versionName \u0026#34;1.0\u0026#34; } } 定义数据模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Android { int mCompileSdkVersion String mBuildToolsVersion BefaultConfig mBefaultConfig Android() { this.mBefaultConfig = new BefaultConfig() } void defaultConfig(Closure closure) { closure.setDelegate(mProductFlavor) closure.setResolveStrategy(Closure.DELEGATE_FIRST) closure.call() } } class BefaultConfig { int mVersionCode String mVersionName int mMinSdkVersion int mTargetSdkVersion } 绑定数据 1 2 3 Android bean = new Android() android.delegate = bean//将上面定义好的bean给设置到闭包里面 android.call()//闭包的调用 Gradle构建过程 其实构建过程就是指编译对应的.gradle文件，然后生成对象，最后执行task。 主要分为三个步骤：\nInitialization：初始化阶段，按顺序执行init.gradle，setting.gradle，生成Gradle、Setting、Project对象 Configuration：配置阶段，按顺序执行 root build.gradle -\u0026gt; 子项目 build.gradle 脚本，生成 Task 执行流程图 Execution：执行阶段，按照 Task 执行图顺序运行每一个 Task，完成一个个步奏，生成最终 APK 文件 整个流程如下： 通过流程图观察，我们可以在合适的时机监听gradle的构建过程，也就是钩子方法。 下面通过这些钩子方法来获取项目构建各个阶段、任务的耗时情况，在setting.gradle中添加如下代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 long beginOfSetting = System.currentTimeMillis() def beginOfConfig def configHasBegin = false def beginOfProjectConfig = new HashMap() def beginOfProjectExcute gradle.projectsLoaded { println \u0026#39;初始化阶段，耗时：\u0026#39; + (System.currentTimeMillis() - beginOfSetting) + \u0026#39;ms\u0026#39; } gradle.beforeProject { project -\u0026gt; if (!configHasBegin) { configHasBegin = true beginOfConfig = System.currentTimeMillis() } beginOfProjectConfig.put(project, System.currentTimeMillis()) } gradle.afterProject { project -\u0026gt; def begin = beginOfProjectConfig.get(project) println \u0026#39;配置阶段，\u0026#39; + project + \u0026#39;耗时：\u0026#39; + (System.currentTimeMillis() - begin) + \u0026#39;ms\u0026#39; } gradle.taskGraph.whenReady { println \u0026#39;配置阶段，总共耗时：\u0026#39; + (System.currentTimeMillis() - beginOfConfig) + \u0026#39;ms\u0026#39; beginOfProjectExcute = System.currentTimeMillis() } gradle.taskGraph.beforeTask { task -\u0026gt; task.doFirst { task.ext.beginOfTask = System.currentTimeMillis() } task.doLast { println \u0026#39;执行阶段，\u0026#39; + task + \u0026#39;耗时：\u0026#39; + (System.currentTimeMillis() - task.beginOfTask) + \u0026#39;ms\u0026#39; } } gradle.buildFinished { println \u0026#39;执行阶段，耗时：\u0026#39; + (System.currentTimeMillis() - beginOfProjectExcute) + \u0026#39;ms\u0026#39; } 由于在setting.gradle执行前，Gradle对象其实已经生成，所以通过gradle对象的projectsLoaded回调获取初始化时间。第一次进入到beforeProject的时候记录配置的起始时间，并记录每一个project的配置起始时间，然后在afterProject中算出每一个project配置的时间。然后通过gradle.taskGraph来获取有序无向图，然后通过whenReady方法回调算出总的配置时间。最后通过有序无向图的beforeTask来添加task的开始和结束的执行时间来算出task的执行耗时。最后通过gradle的buildFinish来获取总共的构建时间。\ngradle打包速度优化 首先了解下安卓中的variant是什么意思，它表示一个包的变体，其中变体是由productFlavor（产品风味）和buildType（构建类型）组合而成的。其中productFlavor是由维度和渠道构成的，buildType指的是debug还是release，比如维度可以配置价格和渠道的两个维度，而渠道可以配置google、xiaomi等渠道：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 android { // 定义 buildTypes（构建类型） buildTypes { debug { minifyEnabled false applicationIdSuffix \u0026#34;.debug\u0026#34; } release { minifyEnabled true proguardFiles getDefaultProguardFile(\u0026#39;proguard-android-optimize.txt\u0026#39;), \u0026#39;proguard-rules.pro\u0026#39; } } // 定义 productFlavors（产品风味） flavorDimensions \u0026#39;channel\u0026#39;, \u0026#39;pricing\u0026#39; productFlavors { //配置渠道维度下两个变体 google { dimension \u0026#39;channel\u0026#39; } xiaomi { dimension \u0026#39;channel\u0026#39; } //配置价格下两个变体 free { dimension \u0026#39;pricing\u0026#39; } vip { dimension \u0026#39;pricing\u0026#39; } } // 在这里的 `productFlavors` 和 `buildTypes` 组合形成不同的 variants } 所以上面通过维度和渠道组合后的productFlavor有googleFree、googleVip、xiaomiFree、xiaomiVip四个，再和buildType组合后，就是8个变体，分别是：\ngoogleFreeDebug googleFreeRelease googleVipDebug googleVipRelease xiaomiFreeDebug xiaomiFreeRelease xiaomiVipDebug xiaomiVipRelease 知道了variant后，下面就是了解下打包了，一般通过build Analyze查看build过程中的一些警告，使用该工具需要先进行build，第二个工具是gradle profile工具，一般通过如下命令：\n1 2 ./gradlew installGoogleFreeDebug --build-cache -x lint -x test --warning-mode=none -Pkotlin.compiler.execution.strategy=in-process -PcompilerArgs=-Xlint:deprecation --no-configuration-cache --profile adb shell am start -n 包名/应用主入口 如果通过adb命令启动主入口的话，需要在清单文件中给主入口加上android:exported=\u0026quot;true\u0026quot;属性，装包完了后，本地会生成一个html文件，该文件会有gradle每个阶段的耗时情况，并且会有每个task的耗时。\n再个就是gradle scan工具，一般通过如下命令：\n1 2 ./gradlew installGoogleFreeDebug --build-cache -x lint -x test --warning-mode=none -Pkotlin.compiler.execution.strategy=in-process -PcompilerArgs=-Xlint:deprecation --no-configuration-cache --scan adb shell am start -n 包名/应用主入口 scan会生成一个在线的网页，第一次使用需要邮箱校验，它的信息比profile更全面，更加智能，其中performance跟profile中效果差不多，它多了timeline选项，表示什么时候执行了什么task，switchs选项表示一些建议，比如缓存没开，会提示off。 其实gradle优化最直接是通过组件化来开发，如果全app编译的话，组件越多，需要的时间越长，所以通过组件化来降低打包时间是最直接的，把一些其他依赖的组件通过aar进行依赖或远程依赖。 参考： Gradle 爬坑指南 \u0026ndash; 概念初解、Grovvy 语法、常见 API Gradle 爬坑指南 \u0026ndash; 理解 Plugin、Task、构建流程 深度探索 Gradle 自动化构建技术（三、Gradle 核心解密）\n","date":"2025-02-07T00:00:00Z","permalink":"http://xiangcman.xyz/p/gradle%E5%BF%85%E5%A4%87/","title":"Gradle必备"},{"content":"Recyclerview系列 缓存相关 RecyclerView 缓存机制 | 如何复用表项？ RecyclerView 缓存机制 | 回收些什么？ RecyclerView 缓存机制 | 回收到哪去？ RecyclerView缓存机制 | scrap view 的生命周期 RecyclerView 面试题 | 滚动时表项是如何被填充或回收的？ RecyclerView 面试题 | 哪些情况下表项会被回收到缓存池？ RecyclerView 刷新列表数据的 notifyDataSetChanged() 为什么是昂贵的? 掌握这17张图，没人比你更懂RecyclerView的预加载 【动画图解】这个值取对了，ViewPager2才能纵享丝滑 动画相关 RecyclerView 动画原理 | 换个姿势看源码（pre-layout） RecyclerView 动画原理 | pre-layout，post-layout 与 scrap 缓存的关系） RecyclerView 动画原理 | 如何存储并应用动画属性值？） 优化相关 浅谈RecyclerView的性能优化 RecyclerView 性能优化 | 把加载表项耗时减半 (一) RecyclerView性能优化之异步预加载 Kotlin系列 Kotlin中的协程、上下文和作用域 抽丝剥茧聊协程之深入理解Continuation原理 Kotlin 源码里成吨的 noinline 和 crossinline 是干嘛的？看完这个视频你转头也写了一吨 抽丝剥茧聊Kotlin协程之协程异常处理机制分析 kotlin的泛型 SurfaceFlinger系列 Android应用程序与SurfaceFlinger服务的关系概述和学习计划 Android系统Surface机制的SurfaceFlinger服务简要介绍和学习计划 Activity系列 Android应用程序窗口（Activity）实现框架简要介绍和学习计划 WMS系列 Android窗口管理服务WindowManagerService的简要介绍和学习计划 资源打包系列 Android应用程序资源的编译和打包过程分析 Android应用程序资源的查找过程分析 Android Apk 编译打包流程，了解一下~ AssetManager系列 Android资源管理框架（Asset Manager）简要介绍和学习计划 硬件加速系列 Android应用程序UI硬件加速渲染技术简要介绍和学习计划 ASM相关 Android 进阶之路：ASM 修改字节码，这样学就对了！ Gradle相关 Gradle 爬坑指南 \u0026ndash; 导论 Gradle 爬坑指南 \u0026ndash; 概念初解、Grovvy 语法、常见 API Gradle 爬坑指南 \u0026ndash; 理解 Plugin、Task、构建流程 Gradle 爬坑指南 \u0026ndash; Gradle 核心模型、Hook 函数、ext 扩展属性、Project API 深度探索 Gradle 自动化构建技术（一、Gradle 核心配置篇） 深度探索 Gradle 自动化构建技术（二、Groovy 筑基篇） 深度探索 Gradle 自动化构建技术（三、Gradle 核心解密） 深度探索 Gradle 自动化构建技术（四、自定义 Gradle 插件） 深度探索 Gradle 自动化构建技术（五、Gradle 插件架构实现原理剖析 — 上） 深度探索 Gradle 自动化构建技术（五、Gradle 插件架构实现原理剖析 — 下） 深入探索 Gradle 自动化构建技术（九、Gradle 插件平台化框架 ByteX 探秘之旅） 设计模式相关 Java常用设计模式(一) Java常用设计模式(二) Java常用设计模式(三) 《Android源码设计模式解析》读书笔记——Android中你应该知道的设计模式 性能分析 Profiler相关使用 Android Studio中System Trace几大板块 Android Studio中方法调用(Call Chart、Flame Chart、Top Down、Bottom Up、Event)的几种展现形式讲解 Android Studio中卡顿检测模块讲解 Android Studio中耗电量讲解 Android Studio中生成trace的路径 Android Studio中Heap Dump获取堆的快照 Android Studio中对trace进行采样收集 Android Studio中采集Java或Kotlin的内存占用 Android Studio中采集Java或Kotlin的方法调用 Android Studio中采集native方法的内存占用 渲染相关 检查GPU渲染速度和过度绘制 减少过度绘制 性能和视图层次结构 使用 GPU 渲染模式分析工具进行分析 改善布局性能 perfetto 使用adb进行捕捉perfetto文件 perfetto官网介绍 在安卓平台进行捕捉perfetto文件 SystemTrace 如何进行浏览systemtrace报告 通过命令启动System Trace 手机上启动System Trace 大佬博客系列 老罗 Gracker 程序员江同学 ","date":"2025-01-22T00:00:00Z","permalink":"http://xiangcman.xyz/p/%E9%AB%98%E8%B4%A8%E9%87%8F%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/","title":"高质量文章汇总"},{"content":"上一篇(RecyclerView性能优化)理论知识讲过recyclerview有哪些优化点，该篇主要结合理论知识来实践下优化手段。\nxml布局替换为动态创建 一个简单的textview先通过xml创建，通过traceview观察耗时 这次三次创建viewholder的耗时，其中第一次由于需要类加载到jvm中，所以会耗时长一些，后面的话，基本在5ms左右。 通过new的形式创建viewholder： 第一次耗时在6ms，第二次耗时在4ms，基本比xml的形式要少个1ms 注意：这里演示的只是一个简单的textview，如果平时开发的布局是比较复杂，并且嵌套层级比较深的话，这种差距会更加明显。 通过perfetto观察create过程： 基本数据和traceview保持一致。 recyclerview.setHasFixSize(true) 用了sethasfixsize(true)的时候，会通过consumePendingUpdateOperations触发recyclerview的layout过程，没有走从根view到recyclerview的measure、layout过程，实际sethasfixsize(true)会给choreographer发送一条callback_animal的消息： 其实我们的属性动画也是这么做的，给choreographer发送一条animal的消息。sethasfixsize(true)在表项尺寸不发生变化的时候使用，减少不必要的measure过程。\nsethasstableids(true)和重写getItemId： 调用notifydatasetChange后，不会走oncreateviewholder： 从trace分析： detach过程调用的是scrap的缓存，并且此时不会回调ondetachfromwindow过程，并且都加入到了attach的scrap缓存中，在fill阶段通过重写的getItemId拿到了viewholder： 至于为什么会onbind，是因为notify过后的item的状态变成了invalid状态，所以会重新走onbind过程。\nrecyclerpool减少oncreateviewholder次数： tablayout+viewpager2，子页面是fragment，每个fragment中的rv用的viewholder是同种类型，我们将recyclerpool设置在activity中，然后传给子fragment，设置recyclerpool需要在setadapter之前。 我们在第一个页面滑动的时候，会有viewholder放到了recyclerpool中，此时我们滑动到第二个fragment的时候会用到recycerlpool中的viewholder。 从debug看，给另外一个recyclerview设置recyclerpool时候，已经存在一个viewholder，所以猜测该fragment会使用到viewholder，日志验证： 从日志来看，第一个viewholder只有bind过程，没有create。\n","date":"2025-01-17T00:00:00Z","permalink":"http://xiangcman.xyz/p/recyclerview%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/","title":"RecyclerView优化实践"},{"content":" 说起预加载，其实之前面试的时候被问到的，然后最近看到一篇关于预加载的文章，然后颇有感受，因此才有该篇文章。 在recyclerview的onAttachedToWindow有这么一句：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * On L+, with RenderThread, the UI thread has idle time after it has passed a frame off to * RenderThread but before the next frame begins. We schedule prefetch work in this window. */ static final boolean ALLOW_THREAD_GAP_WORK = Build.VERSION.SDK_INT \u0026gt;= 21; @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); //省略代码 if (ALLOW_THREAD_GAP_WORK) { // Register with gap worker mGapWorker = GapWorker.sGapWorker.get(); if (mGapWorker == null) { mGapWorker = new GapWorker(); // break 60 fps assumption if data from display appears valid // NOTE: we only do this query once, statically, because it\u0026#39;s very expensive (\u0026gt; 1ms) Display display = ViewCompat.getDisplay(this); float refreshRate = 60.0f; if (!isInEditMode() \u0026amp;\u0026amp; display != null) { float displayRefreshRate = display.getRefreshRate(); if (displayRefreshRate \u0026gt;= 30.0f) { refreshRate = displayRefreshRate; } } mGapWorker.mFrameIntervalNs = (long) (1000000000 / refreshRate); GapWorker.sGapWorker.set(mGapWorker); } mGapWorker.add(this); } } 可以看到有一个静态变量，ALLOW_THREAD_GAP_WORK是大于等于21（Android5.0）才会为true，这是因为在5.0之后，引进了RenderThread线程，专门用来渲染ui线程绘制好的数据，渲染完后，会提交到事先申请的bufferqueue中，然后当vsync-sf信号来的时候，sufaceflinger会去对应app的bufferqueue中取出前面提交的buffer数据，然后进行合成layer，最终屏幕（hwc）收到该请求后，进行图层进行合成，最终送到屏幕硬件上显示。这就是一针从创建到消费的过程。 由于ui线程把绘制好的数据绘制好后，会通知renderthread线程进行渲染，直到下一针来的时候才开始工作，此时会有主线程空闲的时候，recyclerview正是利用此空闲时间来进行预加载，而如果在下一针来临的时候，预加载还没有完成，那么此时会放弃此次的预加载，了解原理后，开始分析过程： 预加载的处理类是GapWorker类，一个线程对应一个GapWorker，它是存储在ThreadLocal中。GapWorker是一个runnable类，它如何要工作的话，是通过GapWorker.postFromTraversal工作的：\n1 2 3 4 5 6 7 8 9 10 11 12 void postFromTraversal(RecyclerView recyclerView, int prefetchDx, int prefetchDy) { if (recyclerView.isAttachedToWindow()) { if (RecyclerView.DEBUG \u0026amp;\u0026amp; !mRecyclerViews.contains(recyclerView)) { throw new IllegalStateException(\u0026#34;attempting to post unregistered view!\u0026#34;); } if (mPostTimeNs == 0) { mPostTimeNs = recyclerView.getNanoTime(); recyclerView.post(this); } } recyclerView.mPrefetchRegistry.setPrefetchVector(prefetchDx, prefetchDy); } 可以看出来实际是通过recyclerview.post，然后传的是自己，因此会直接run方法。预加载时机在源码里面有两处调用了：\nRecyclerview被拖动时： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Override public boolean onTouchEvent(MotionEvent e) { ... switch (action) { ... case MotionEvent.ACTION_MOVE: { ... if (mScrollState == SCROLL_STATE_DRAGGING) { ... // 处于拖动状态并且存在有效的拖动距离时 if (mGapWorker != null \u0026amp;\u0026amp; (dx != 0 || dy != 0)) { mGapWorker.postFromTraversal(this, dx, dy); } } } break; ... } ... return true; } Recyclerview惯性滑动时： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class ViewFlinger implements Runnable { ... @Override public void run() { ... if (!smoothScrollerPending \u0026amp;\u0026amp; doneScrolling) { ... } else { ... if (mGapWorker != null) { mGapWorker.postFromTraversal(RecyclerView.this, consumedX, consumedY); } } } ... } 看下GapWorker的run方法如何实现的预加载：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Override public void run() { try { TraceCompat.beginSection(RecyclerView.TRACE_PREFETCH_TAG); if (mRecyclerViews.isEmpty()) { // abort - no work to do return; } // Query most recent vsync so we can predict next one. Note that drawing time not yet // valid in animation/input callbacks, so query it here to be safe. final int size = mRecyclerViews.size(); long latestFrameVsyncMs = 0; for (int i = 0; i \u0026lt; size; i++) { RecyclerView view = mRecyclerViews.get(i); if (view.getWindowVisibility() == View.VISIBLE) { latestFrameVsyncMs = Math.max(view.getDrawingTime(), latestFrameVsyncMs); } } if (latestFrameVsyncMs == 0) { // abort - either no views visible, or couldn\u0026#39;t get last vsync for estimating next return; } long nextFrameNs = TimeUnit.MILLISECONDS.toNanos(latestFrameVsyncMs) + mFrameIntervalNs; prefetch(nextFrameNs); // TODO: consider rescheduling self, if there\u0026#39;s more work to do } finally { mPostTimeNs = 0; TraceCompat.endSection(); } } 在调用prefetch前传入nextFrameNs，该值表示预估的下一个vsync来临的时间，首先获取上一针的绘制起始时间，也就是latestFrameVsyncMs，而mFrameIntervalNs是通过刷新率算出来的一针需要的时间，比如60hz的手机，一秒是60帧，那么mFrameIntervalNs的值是一针需要16ms，mFrameIntervalNs的单位是纳秒，这个时间在开篇的onAttachedToWindow方法中计算的，所以可以看出来，nextFrameNs时间就是预加载最后的期限时间，超过这个时间就会放弃该预加载，上面提到的上一针时间是用过recyclerview的getDrawingTime获取的，它是获取的attachInfo的mDrawingTime时间，而mDrawingTime是在viewRootImpl中draw方法给赋值的：\n1 2 3 4 5 6 private boolean draw(boolean fullRedrawNeeded, boolean forceDraw) { //省略代码 mAttachInfo.mDrawingTime = mChoreographer.getFrameTimeNanos() / TimeUtils.NANOS_PER_MS; //省略代码 } 可以看出来，它是通过Choreographer的getFrameTimeNanos方法来获取的：\n1 2 3 4 5 @UnsupportedAppUsage public long getFrameTimeNanos() { //省略代码 return USE_FRAME_TIME ? mLastFrameTimeNanos : System.nanoTime(); } mLastFrameTimeNanos是在doFrame中将参数frameTimeNanos给赋值的，而frameTimeNanos参数表示的就是当前vsnyc信号来临的时间。所以最终结论就是通过遍历recyclerview的drawingtime，来获取最近一次的vsync时间，并加上当前设备一针所需要的时间，从而得到下一个vsync信号来临的时间，也就是预加载要完成的最晚时间。继续跟进GapWorker的prefetch方法：\n1 2 3 4 void prefetch(long deadlineNs) { buildTaskList(); flushTasksWithDeadline(deadlineNs); } buildTaskList，它是用来构建预加载的task列表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private void buildTaskList() { // Update PrefetchRegistry in each view final int viewCount = mRecyclerViews.size(); int totalTaskCount = 0; for (int i = 0; i \u0026lt; viewCount; i++) { RecyclerView view = mRecyclerViews.get(i); if (view.getWindowVisibility() == View.VISIBLE) { //收集要预加载的view的position view.mPrefetchRegistry.collectPrefetchPositionsFromView(view, false); totalTaskCount += view.mPrefetchRegistry.mCount; } } //省略代码 } 首先是调用了view.mPrefetchRegistry.collectPrefetchPositionsFromView(view, false)来收集预加载的view：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void collectPrefetchPositionsFromView(RecyclerView view, boolean nested) { mCount = 0; if (mPrefetchArray != null) { Arrays.fill(mPrefetchArray, -1); } final RecyclerView.LayoutManager layout = view.mLayout; if (view.mAdapter != null \u0026amp;\u0026amp; layout != null \u0026amp;\u0026amp; layout.isItemPrefetchEnabled()) { //省略代码 if (!view.hasPendingAdapterUpdates()) { layout.collectAdjacentPrefetchPositions(mPrefetchDx, mPrefetchDy, view.mState, this); } //省略代码 } } 可以看出来调用了layoutmanager的collectAdjacentPrefetchPositions的方法，把需要预加载的水平和竖直方向的偏移量传入其中，看下LinearLayoutManager的该方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Override public void collectAdjacentPrefetchPositions(int dx, int dy, RecyclerView.State state, LayoutPrefetchRegistry layoutPrefetchRegistry) { int delta = (mOrientation == HORIZONTAL) ? dx : dy; if (getChildCount() == 0 || delta == 0) { // can\u0026#39;t support this scroll, so don\u0026#39;t bother prefetching return; } ensureLayoutState(); final int layoutDirection = delta \u0026gt; 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START; final int absDelta = Math.abs(delta); updateLayoutState(layoutDirection, absDelta, true, state); collectPrefetchPositionsForLayoutState(state, mLayoutState, layoutPrefetchRegistry); } 通过方法来判断偏移量，然后把方向标识传入到updateLayoutState中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private void updateLayoutState(int layoutDirection, int requiredSpace, boolean canUseExistingSpace, RecyclerView.State state) { //省略代码 if (layoutToEnd) { //获取可见的最后一个表项 final View child = getChildClosestToEnd(); //判断是否是reverse的 mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD : LayoutState.ITEM_DIRECTION_TAIL; //获取预加载的position mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection; mLayoutState.mOffset = mOrientationHelper.getDecoratedEnd(child); //获取要预加载的表项与recyclerview底部的距离 scrollingOffset = mOrientationHelper.getDecoratedEnd(child) - mOrientationHelper.getEndAfterPadding(); } else { //省略代码 } //省略代码 mLayoutState.mScrollingOffset = scrollingOffset; } 此处只保留从上到下的滑动，先是获取页面滚动的最后一个表项，然后判断是不是reverseLayout，如果不是则取LayoutState.ITEM_DIRECTION_TAIL(该值等于1)，预加载的position等于最后一个表项的position+1，接着算出预加载的表项离recyclerview底部的距离。它是通过mOrientationHelper.getDecoratedEnd(child)- mOrientationHelper.getEndAfterPadding()得到的。 mOrientationHelper.getDecoratedEnd(child)它是在OrientationHelper中定义的createVerticalHelper方法中实现的：\n1 2 3 4 5 6 @Override public int getDecoratedEnd(View view) { final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) view.getLayoutParams(); return mLayoutManager.getDecoratedBottom(view) + params.bottomMargin; } 1 2 3 public int getDecoratedBottom(@NonNull View child) { return child.getBottom() + getBottomDecorationHeight(child); } getDecoratedBottom是获取child的bottom+child的底部间距高度，所以getDecoratedEnd是获取child的bottom+child的底部间距高度+下间距。 mOrientationHelper.getEndAfterPadding()也是在OrientationHelper中定义的createVerticalHelper方法中实现的：\n1 2 3 4 @Override public int getEndAfterPadding() { return mLayoutManager.getHeight() - mLayoutManager.getPaddingBottom(); } getEndAfterPadding是recyclerview的高度-recyclerview的下内边距。所以scrollingOffset是即将要预加载的表项离recyclerview底部的间距。接着看下collectPrefetchPositionsForLayoutState方法：\n1 2 3 4 5 6 7 void collectPrefetchPositionsForLayoutState(RecyclerView.State state, LayoutState layoutState, LayoutPrefetchRegistry layoutPrefetchRegistry) { final int pos = layoutState.mCurrentPosition; if (pos \u0026gt;= 0 \u0026amp;\u0026amp; pos \u0026lt; state.getItemCount()) { layoutPrefetchRegistry.addPosition(pos, Math.max(0, layoutState.mScrollingOffset)); } } 将刚才算的预加载的postion和偏移量传入到addPosition中，该方法是在GapWorker中实现的：\n1 2 3 4 5 6 7 8 @Override public void addPosition(int layoutPosition, int pixelDistance) { //省略代码 final int storagePosition = mCount * 2; mPrefetchArray[storagePosition] = layoutPosition; mPrefetchArray[storagePosition + 1] = pixelDistance; mCount++; } 将position和偏移量成对保存在mPrefetchArray数组中。构建完数组中，接着就是将数组的数据存到task中。这块逻辑在buildTaskList中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private void buildTaskList() { for (int i = 0; i \u0026lt; viewCount; i++) { RecyclerView view = mRecyclerViews.get(i); if (view.getWindowVisibility() != View.VISIBLE) { // Invisible view, don\u0026#39;t bother prefetching continue; } LayoutPrefetchRegistryImpl prefetchRegistry = view.mPrefetchRegistry; final int viewVelocity = Math.abs(prefetchRegistry.mPrefetchDx) + Math.abs(prefetchRegistry.mPrefetchDy); for (int j = 0; j \u0026lt; prefetchRegistry.mCount * 2; j += 2) { final Task task; if (totalTaskIndex \u0026gt;= mTasks.size()) { task = new Task(); mTasks.add(task); } else { task = mTasks.get(totalTaskIndex); } final int distanceToItem = prefetchRegistry.mPrefetchArray[j + 1]; task.immediate = distanceToItem \u0026lt;= viewVelocity; task.viewVelocity = viewVelocity; task.distanceToItem = distanceToItem; task.view = view; task.position = prefetchRegistry.mPrefetchArray[j]; totalTaskIndex++; } } } task信息由由以下组成： immediate：表示是否立即执行，判断依据预加载的表项离recyclerview底部距离是否小于滑动的速度 viewVelocity：滑动的速度 distanceToItem：预加载的表项离recyclerview底部距离 view：recyclerview position：预加载表项的位置 从上面可以看出来从mPrefetchArray数组中取值是每两个值取出的，和上面build过程对应。所有的完事后，在buildTaskList中就是对task进行排序：\n1 2 3 4 5 private void buildTaskList() { ... // 3.对任务列表进行优先级排序 Collections.sort(mTasks, sTaskComparator); } 上面就是整个buildTaskList的逻辑，接着就是根据构建的task来创建viewholder，该逻辑是在flushTasksWithDeadline方法中：\n1 2 3 4 5 6 7 8 9 10 private void flushTasksWithDeadline(long deadlineNs) { for (int i = 0; i \u0026lt; mTasks.size(); i++) { final Task task = mTasks.get(i); if (task.view == null) { break; // done with populated tasks } flushTaskWithDeadline(task, deadlineNs); task.clear(); } } flushTaskWithDeadline:\n1 2 3 4 5 6 private void flushTaskWithDeadline(Task task, long deadlineNs) { long taskDeadlineNs = task.immediate ? RecyclerView.FOREVER_NS : deadlineNs; RecyclerView.ViewHolder holder = prefetchPositionWithDeadline(task.view, task.position, taskDeadlineNs); //省略代码 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private RecyclerView.ViewHolder prefetchPositionWithDeadline(RecyclerView view, int position, long deadlineNs) { RecyclerView.Recycler recycler = view.mRecycler; RecyclerView.ViewHolder holder; holder = recycler.tryGetViewHolderForPositionByDeadline( position, false, deadlineNs); if (holder != null) { if (holder.isBound() \u0026amp;\u0026amp; !holder.isInvalid()) { //如果holder已经绑定过并且是可用的，加入到cacheview缓存中 recycler.recycleView(holder.itemView); } else { //否则加入到RecycledViewPool中 recycler.addViewHolderToRecycledViewPool(holder, false); } } return holder; } 上面通过tryGetViewHolderForPositionByDeadline获取viewholder，和正常获取viewholder的区别是传入了deadlineNs，直接看该方法是如何放弃超时的viewholder：\n1 2 3 4 5 6 7 8 9 10 ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) { if (holder == null) { long start = getNanoTime(); if (deadlineNs != FOREVER_NS \u0026amp;\u0026amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) { return null; } } } 如果deadlineNs不是FOREVER_NS，普通调用该方法传入的deadlineNs是FOREVER_NS，所以是通过该值区分是不是预加载调用的，接着通过willCreateInTime返回值判断要不要放弃：\n1 2 3 4 boolean willCreateInTime(int viewType, long approxCurrentNs, long deadlineNs) { long expectedDurationNs = getScrapDataForType(viewType).mCreateRunningAverageNs; return expectedDurationNs == 0 || (approxCurrentNs + expectedDurationNs \u0026lt; deadlineNs); } expectedDurationNs取的是对应viewholder的平均创建时间，其实也不叫平均时间：\n1 2 3 4 5 6 7 8 9 10 11 void factorInCreateTime(int viewType, long createTimeNs) { ScrapData scrapData = getScrapDataForType(viewType); scrapData.mCreateRunningAverageNs = runningAverage( scrapData.mCreateRunningAverageNs, createTimeNs); } long runningAverage(long oldAverage, long newValue) { if (oldAverage == 0) { return newValue; } return (oldAverage / 4 * 3) + (newValue / 4); } 每次将之前的创建viewholder时间占3分之4，当前创建的时间占1分之4。所以willCreateInTime的返回值是如果当前时间+平均创建viewholder时间小于最晚约定时间则不会放弃，否则直接放弃。如果不放弃接着会判断bind过程有没有超过约定时间：\n1 2 3 4 5 6 7 8 9 10 11 12 13 private boolean tryBindViewHolderByDeadline(@NonNull ViewHolder holder, int offsetPosition, int position, long deadlineNs) { final int viewType = holder.getItemViewType(); long startBindNs = getNanoTime(); if (deadlineNs != FOREVER_NS \u0026amp;\u0026amp; !mRecyclerPool.willBindInTime(viewType, startBindNs, deadlineNs)) { return false; } mAdapter.bindViewHolder(holder, offsetPosition); long endBindNs = getNanoTime(); mRecyclerPool.factorInBindTime(holder.getItemViewType(), endBindNs - startBindNs); return true; } bind过程是通过willBindInTime方法来判断有没有超过约定时间的，整个逻辑很清晰。\n前面分析过如果holder是bind过的，则会加入到cacheview缓存中，否则加入到RecycledViewPool中，正常滑动的时候离屏的viewholder也是添加到cacheview缓存中的，那两者在缓存中又是怎么区分的呢？直接看recycler的recycleViewHolderInternal方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void recycleViewHolderInternal(ViewHolder holder) { //省略代码 //默认插入cacheview缓存的索引是末尾 int targetCacheIndex = cachedViewSize; if (ALLOW_THREAD_GAP_WORK \u0026amp;\u0026amp; cachedViewSize \u0026gt; 0 \u0026amp;\u0026amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) {//如果是正常离屏的viewholder //默认指向最后一个元素 int cacheIndex = cachedViewSize - 1; while (cacheIndex \u0026gt;= 0) { int cachedPos = mCachedViews.get(cacheIndex).mPosition; //如果当前表项不是预拉取的表项则退出 if (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) { break; } cacheIndex--; } targetCacheIndex = cacheIndex + 1; } mCachedViews.add(targetCacheIndex, holder); //省略代码 } 默认插入cacheview缓存的索引是在末尾，在插入正常离屏的viewholder时候如果遇到预拉取的viewholder，则往前找直到最后一个离屏的viewholder，然后插入到它后面。所以不难看出，预拉取的会在后面，离屏的会在前面。这样的好处是预加载的viewholder由于在后面使用的机会会很大，放在集合的后面删除的概率要小。\n参考：掌握这17张图，没人比你更懂RecyclerView的预加载\n","date":"2025-01-17T00:00:00Z","permalink":"http://xiangcman.xyz/p/recyclerview%E7%9A%84%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/","title":"RecyclerView的预加载实现"},{"content":" 关于RecyclerView的优化，其实无非两点，尽可能的最大化使用viewholder的缓存，如果不能使用缓存，将构建和绑定viewholder的过程耗时降低到最低。\n缓存 这里再总结下RecyclerView的缓存知识：\n分类 scrap缓存：用于缓存页面暂时分离的viewholder，分为changeScrap和attachScrap，changeScrap用于缓存要update的viewholder，attachscrap缓存非update的viewholder。 不作用于页面滑动，开发干预不了该缓存。它缓存的个数是一屏的viewholder。 cacheview缓存：是一个arraylist的结构，在滑动的时候，滑出屏幕的viewholder会保存到该缓存中，默认保存的数量是2个，当超过2个的时候，会先移除集合中第一个viewholder，并把该viewholder进行重置。 然后加入到recyclerpool缓存中，最后把新的viewholder加入到cacheview缓存尾部，整个过程，cacheview缓存相当于是一个队列，先进先出的规则。它是根据position来取的，不需要重新bind ViewCacheExtension：mViewCacheExtension又称拓展缓存，为开发者预留的缓存池，开发者可以自己拓展回收池，一般不会用到。 最后就是recyclerpool缓存，它是在cacheview满了的时候，加入到该缓存中的，它是根据viewtype缓存的。在它里面的viewholder都被重置过了的，所以从它里面取出来的viewholder都需要重新bind。 缓存回收 在不滚动情况下： 会把页面上可见的viewholder缓存到scrap中，如果viewholder中有flag_update标记的时候，则把它添加到changeScrap中，否则加入到attachScrap中。 在滚动情况下： 会把滑出recyclerview的viewholder先添加到cacheView缓存中，如果cacheView缓存满了话，会把集合开始的位置viewholder给放到RecycledViewPool中，RecycledViewPool会按照每种viewtype的viewholder为5的容量进行回收，如果超过5个的时候，就不会往里面存了。\n缓存复用 如果是在pre-layout阶段，会去changeScrap缓存中通过position查找viewholder，如果通过position找不到，则通过id去查找，从changeScrap缓存中取出的。 在pre-layout和post-layout阶段会先从attachScrap缓存中通过position查找viweholder，如果没找到则会从cacheview缓存中通过position查找viewholder，如果没找到再通过id从attchScrap和cacheview中找viewholder，如果还没找到，则从ViewCacheExtension中找，如果还没找到则从RecycledViewPool中找，如果都没找到，则创建viewholder，由于changeScrap不参与post-layout阶段，所以在post-layout阶段会走创建表项和绑定表项，attachScrap由于是精准匹配，所以无需创建和绑定，cacheview缓存也是精准匹配，RecycledViewPool中的viewholder由于都重置了，所以需要走绑定。\n缓存说明 scrap缓存只会在非滑动场景下进行保存，并且它保存的数量是一屏的数据，该缓存开发无法干预，cacheview缓存的是可以直接用的viewholder，无需bind和create，但是默认容量很小，可以动态设置，RecycledViewPool里面的viewholder都是重置过的，需要重新bind，按viewtype进行存储，每种viewtype的容量默认是5，也是可以设置大小。而ViewCacheExtension缓存虽然是扩展缓存，但是很少去用，所以可优化的缓存只有cacheview和RecycledViewPool\n如何最大化使用缓存？ 多使用scrap缓存来局部刷新 前面分析过使用notifyDataSetChange的时候会使可见的viewholder和缓存中的viewholder都失效了，导致所有的viewhodler都会先从pool缓存中找一遍，如果有的话，就需要重新bind，如果找不到则先走创建，然后走bind过程，所以局部刷新使用notifyItemChange和notifyItemRemove，如果只是刷新viewholder中的某一个子view，则使用payload的形式。 使用diffutils来实现局部刷新，无需关心刷新的索引，只需要提供变化的数据源 合理使用pool缓存，如果一屏展示的viewholder比较多，则可以适当增加pool缓存的最大数量，减少频繁创建viewholder 合理设置cacheview的缓存，如果recyclerview需要经常来回滑动，则可以适当增加cacheview的缓存数量 重写adapter的getItemId并且给recyclerview设置setHasStableIds为true来给每一个viewholder增加唯一索引，这样在缓存查找的时候能增大复用。 如果两个recyclerview的viewholder有部分相同或者基本相同的情况下，给这两个recyclerview设置同一个RecycledViewPool来增加viewholder的复用度，注意此时给recyclerview设置pool的时候，需要在设置adapter之前 如果同一个recyclerview需要切换视图的时候，并且视图的样式是不同的adapter的时候，此时可以考虑用swapadapter来切换adapter，swapadapter是把attachScrap给清空，并把cacheview中的缓存加入到RecycledViewPool中，而setAdapter是清空所有的缓存。由于swapadapter是复用了RecycledViewPool中的缓存，因此要求前后的viewholder是同一种类型，否则会出现异常。 构建过程如何降低到最低？ 所谓构建就是指viewholder的create过程，该阶段主要是通过解析xml，来创建view，该阶段涉及到文件读取的io操作，以及反射生成view。一般我们可以通过动态创建view的形式来消除io操作和反射生成view。或者将xml的层级降到最低，减少inflate的时间。 提前解析xml，然后存放到缓存池中，等到使用的时候直接从池子中取。 绑定过程如何降低到最低？ 给视图设置监听器的时候，不要通过直接创建listener的形式，通过外界传入进来，然后在外界处理逻辑 绑定视图的时候不要做计算逻辑，将计算逻辑前置化，绑定应该是一个纯展示的过程 其它 如果item的大小是固定的，则使用setHasFixedSize(true)，这样可以避免在更新、添加、删除表项的时候重新requestLayout，而该过程会等到下一个vsync信号来的时候，走绘制流程，然后才是测量，使用该方法后，会给Choreographer发送一条animtion的消息，在下一个vsync来的时候，直接进行recyclerview的dispatchLayout。 开启recyclerview的预加载，recyclerview的预加载默认是开启的，如果要关闭通过layout.setItemPrefetchEnabled(false)来关闭，如果是自定义layoutmanager，则通过重写collectAdjacentPrefetchPositions来实现预加载 recyclerview会加载屏内可见的viewholder，如果viewholder对应的itemview高度或宽度很大的时候，可能加载的屏外viewholder很少，此时重写layoutmanager的calculateExtraLayoutSpace来实现屏外的viewholder加载，关于这块可以看viewpager2如何实现的屏外viewholder的加载。 参考： RecyclerView 性能优化 | 把加载表项耗时减半 (一) 浅谈RecyclerView的性能优化 RecyclerView性能优化之异步预加载 RecyclerView的预加载 【动画图解】这个值取对了，ViewPager2才能纵享丝滑 ","date":"2025-01-13T00:00:00Z","permalink":"http://xiangcman.xyz/p/recyclerview%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","title":"RecyclerView性能优化"},{"content":"大家有没有想过，scrap缓存存在的意义是什么？为什么存了后，又把它里面的viewholder又给删了？\n在上一篇(RecyclerView源码走读)中我们分析过更新和删除表项的过程，下面来总结下scrap缓存的过程：\n更新表项:\n页面上有表项0到9，总共有10个表项，然后更新表项0，在dispatchLayout1阶段（pre-layout），先把页面上的表项0到9存到scrap缓存中，由于表项0是更新的所以会把表项0放到changeScrap缓存中，把表项1到9存到attachScrap缓存中。同时会把这10个表项从页面上分离（child的parent置空，并把viewgroup中对应的child给置空），接着从scrap缓存中取出viewholder，由于存在更新表项，所以会去创建表项10的viewholder到recyclerview上。此时recyclerview中有11个表项了，同时把他们从scrap缓存中移除。 在dispatchLayout2阶段（post-layout），会把这11个表项加入到scrap缓存中，表项0还是放到changeScrap中，表项1到10加入到attachScrap缓存中。接着把他们从页面上分离。然后在fill中，从scrap缓存中获取viewholder，由于changeScrap不会在dispatchLayout2阶段生效，所以会创建了表项0，其余的表项正常从attachScrap缓存中获取。接着把所有的表项添加到recyclerview中，并把scrap中的viewholder缓存移除掉。但是表项10不会添加到recyclerview中，因为到表项9的时候，剩余空间就不够了，所以recyclerview中只有0到9的表项。注意：此时还有表项0和表项10分别存在于changeScrap和attachScrap中。\n上面更新表项经历了两次的布局，分别是dispatchLayout1和dispatchLayout2，在这两个步骤中，先加入到scrap缓存中，然后再从scrap缓存中移除。从现象来看，dispatchLayout1中会生成11个表项，分别是0到10，然后在dispatchLayout2先移除所有的表项，然后添加0到9的表项，而在dispatchLayout2中表项0是重新生成的，因为它要实现更新。而调用两次的布局是为了实现动画而这么做，先生成11个表项，来把他们的位置都记录下来，然后第二次布局的时候把10个表项的位置也记录下来，然后最后根据存储的位置信息做动画。下面来分析下动画如何实现的：\n在dispatchLayoutStep1将页面上可见的表项加入到ViewInfoStore中： 1 2 3 4 5 6 7 8 9 void addToPreLayout(RecyclerView.ViewHolder holder, RecyclerView.ItemAnimator.ItemHolderInfo info) { InfoRecord record = mLayoutHolderMap.get(holder); if (record == null) { record = InfoRecord.obtain(); mLayoutHolderMap.put(holder, record); } record.preInfo = info; record.flags |= FLAG_PRE; } 将viewholder和infoRecord绑定好关系，然后给该record添加上FLAG_PRE标记。注意：此处的InforRecord使用了对象池。 前面分析过在fill完之后，页面上会多出一个表项10，此时也会添加到ViewInfoStore中： 可以看到在onLayoutChildren之后会调用addToAppearedInPreLayoutHolders，此时只有表项10会调用addToAppearedInPreLayoutHolders：\n1 2 3 4 5 6 7 8 9 void addToAppearedInPreLayoutHolders(RecyclerView.ViewHolder holder, RecyclerView.ItemAnimator.ItemHolderInfo info) { InfoRecord record = mLayoutHolderMap.get(holder); if (record == null) { record = InfoRecord.obtain(); mLayoutHolderMap.put(holder, record); } record.flags |= FLAG_APPEAR; record.preInfo = info; } 所以只有表项10添加了FLAG_APPEAR标记。\n在dispatchLayoutStep2走完后，页面上可见的表项就只剩0到9了，在dispatchLayoutStep3中将变化的viewholder调用animateChange，而其他的viewholder调用了addToPostLayout，在该例子中表项0会调用animateChange，表项1到9会调用addToPostLayout：\nanimateChange：当有viewholder发生变化的时候，会触发该方法，该方法会触发mItemAnimator的animateChange方法：\n1 2 3 4 5 6 7 8 private void animateChange(@NonNull ViewHolder oldHolder, @NonNull ViewHolder newHolder, @NonNull ItemHolderInfo preInfo, @NonNull ItemHolderInfo postInfo, boolean oldHolderDisappearing, boolean newHolderDisappearing) { //省略代码 if (mItemAnimator.animateChange(oldHolder, newHolder, preInfo, postInfo)) { postAnimationRunner(); } } 调用了mItemAnimator的animateChange方法，并把改变之前的holder、itemholderinfo和改变之后的holder、itemholderinfo传进去了，默认的itemAnimator是DefaultItemAnimator，也是一个SimpleItemAnimator:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Override public boolean animateChange(@NonNull RecyclerView.ViewHolder oldHolder, @NonNull RecyclerView.ViewHolder newHolder, @NonNull ItemHolderInfo preInfo, @NonNull ItemHolderInfo postInfo) { if (DEBUG) { Log.d(TAG, \u0026#34;CHANGED: \u0026#34; + oldHolder + \u0026#34; with view \u0026#34; + oldHolder.itemView); } final int fromLeft = preInfo.left; final int fromTop = preInfo.top; final int toLeft, toTop; if (newHolder.shouldIgnore()) { toLeft = preInfo.left; toTop = preInfo.top; } else { toLeft = postInfo.left; toTop = postInfo.top; } return animateChange(oldHolder, newHolder, fromLeft, fromTop, toLeft, toTop); } fromLeft、fromTop是老的holder的坐标，toLeft、toTop是新的holder的坐标，最后调用了另外一个animateChange：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Override public boolean animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, int fromX, int fromY, int toX, int toY) { if (oldHolder == newHolder) { // Don\u0026#39;t know how to run change animations when the same view holder is re-used. // run a move animation to handle position changes. return animateMove(oldHolder, fromX, fromY, toX, toY); } final float prevTranslationX = oldHolder.itemView.getTranslationX(); final float prevTranslationY = oldHolder.itemView.getTranslationY(); final float prevAlpha = oldHolder.itemView.getAlpha(); resetAnimation(oldHolder); int deltaX = (int) (toX - fromX - prevTranslationX); int deltaY = (int) (toY - fromY - prevTranslationY); // recover prev translation state after ending animation oldHolder.itemView.setTranslationX(prevTranslationX); oldHolder.itemView.setTranslationY(prevTranslationY); oldHolder.itemView.setAlpha(prevAlpha); if (newHolder != null) { // carry over translation values resetAnimation(newHolder); newHolder.itemView.setTranslationX(-deltaX); newHolder.itemView.setTranslationY(-deltaY); newHolder.itemView.setAlpha(0); } mPendingChanges.add(new ChangeInfo(oldHolder, newHolder, fromX, fromY, toX, toY)); return true; } 如果新老holder是同一个，则调用animateMove，前面分析过oldHolder和newHolder不是同一个，所以先把newHolder的translationX和translationX设置到目标位置，其实此时的deltaX和deltaY为0，因为目标的viewholder位置也在原来表项0的位置，接着把透明度设置为0，最后创建了ChangeInfo，放入到mPendingChanges中。当animateChange返回true后，会调用postAnimationRunner方法：\n1 2 3 4 5 6 void postAnimationRunner() { if (!mPostedAnimatorRunner \u0026amp;\u0026amp; mIsAttached) { ViewCompat.postOnAnimation(this, mItemAnimatorRunner); mPostedAnimatorRunner = true; } } ViewCompat.postOnAnimation(this, mItemAnimatorRunner)是给Choreographer中添加一条CALLBACK_ANIMATION类型的事件，等到下一个vsync信号来的时候，就会执行mItemAnimatorRunner：\n1 2 3 4 5 6 7 8 9 private Runnable mItemAnimatorRunner = new Runnable() { @Override public void run() { if (mItemAnimator != null) { mItemAnimator.runPendingAnimations(); } mPostedAnimatorRunner = false; } }; 最终会执行DefaultItemAnimator的runPendingAnimations方法，该方法会执行changesPending的逻辑，最终会执行animateChangeImpl：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 void animateChangeImpl(final ChangeInfo changeInfo) { final RecyclerView.ViewHolder holder = changeInfo.oldHolder; final View view = holder == null ? null : holder.itemView; final RecyclerView.ViewHolder newHolder = changeInfo.newHolder; final View newView = newHolder != null ? newHolder.itemView : null; if (view != null) {//改变之前的view final ViewPropertyAnimator oldViewAnim = view.animate().setDuration( getChangeDuration()); mChangeAnimations.add(changeInfo.oldHolder); oldViewAnim.translationX(changeInfo.toX - changeInfo.fromX); oldViewAnim.translationY(changeInfo.toY - changeInfo.fromY); oldViewAnim.alpha(0).setListener(new AnimatorListenerAdapter() { @Override public void onAnimationStart(Animator animator) { dispatchChangeStarting(changeInfo.oldHolder, true); } @Override public void onAnimationEnd(Animator animator) { oldViewAnim.setListener(null); view.setAlpha(1); view.setTranslationX(0); view.setTranslationY(0); dispatchChangeFinished(changeInfo.oldHolder, true); mChangeAnimations.remove(changeInfo.oldHolder); dispatchFinishedWhenDone(); } }).start(); } if (newView != null) {//改变之后的view final ViewPropertyAnimator newViewAnimation = newView.animate(); mChangeAnimations.add(changeInfo.newHolder); newViewAnimation.translationX(0).translationY(0).setDuration(getChangeDuration()) .alpha(1).setListener(new AnimatorListenerAdapter() { @Override public void onAnimationStart(Animator animator) { dispatchChangeStarting(changeInfo.newHolder, false); } @Override public void onAnimationEnd(Animator animator) { newViewAnimation.setListener(null); newView.setAlpha(1); newView.setTranslationX(0); newView.setTranslationY(0); dispatchChangeFinished(changeInfo.newHolder, false); mChangeAnimations.remove(changeInfo.newHolder); dispatchFinishedWhenDone(); } }).start(); } } 该方法里面通过view的animate方法给view做动画，改变之前的view位置不会发生变化，只会发生alpha的动画，而改变之后的view会做从0到1的透明度动画。所以最终页面上会出现闪的一下，这个是做更新操作。 上面分析的是表项0会调用animateChange，表项1到9会执行addToPostLayout：\n1 2 3 4 5 6 7 8 9 void addToPostLayout(RecyclerView.ViewHolder holder, RecyclerView.ItemAnimator.ItemHolderInfo info) { InfoRecord record = mLayoutHolderMap.get(holder); if (record == null) { record = InfoRecord.obtain(); mLayoutHolderMap.put(holder, record); } record.postInfo = info; record.flags |= FLAG_POST; } 在dispatchLayout1的时候，表项1到9会添加上FLAG_PRE标记，接着在此处又添加上FLAG_POST标记，表项10添加了FLAG_APPEAR标记。所有的标记添加完后，最终会执行ViewInfoStore的process：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void process(ProcessCallback callback) { for (int index = mLayoutHolderMap.size() - 1; index \u0026gt;= 0; index--) { final RecyclerView.ViewHolder viewHolder = mLayoutHolderMap.keyAt(index); final InfoRecord record = mLayoutHolderMap.removeAt(index); if ((record.flags \u0026amp; FLAG_PRE_AND_POST) == FLAG_PRE_AND_POST) { // Persistent in both passes. Animate persistence callback.processPersistent(viewHolder, record.preInfo, record.postInfo); } else if ((record.flags \u0026amp; FLAG_APPEAR) != 0) { // Scrap view. RecyclerView will handle removing/recycling this. } InfoRecord.recycle(record); } } 这里省略了无关紧要的代码，表项1到9会调用callback.processPersistent回调，表项10不做相关更新：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Override public void processPersistent(ViewHolder viewHolder, @NonNull ItemHolderInfo preInfo, @NonNull ItemHolderInfo postInfo) { viewHolder.setIsRecyclable(false); if (mDataSetHasChangedAfterLayout) { // since it was rebound, use change instead as we\u0026#39;ll be mapping them from // stable ids. If stable ids were false, we would not be running any // animations if (mItemAnimator.animateChange(viewHolder, viewHolder, preInfo, postInfo)) { postAnimationRunner(); } } else if (mItemAnimator.animatePersistence(viewHolder, preInfo, postInfo)) { postAnimationRunner(); } } 由于mDataSetHasChangedAfterLayout是在setAdapter中设置的，所以会走mItemAnimator.animateChange逻辑，在上面分析过，如果两个viewholder是同一个，则调用animateMove方法，而位置信息又不发生变化，所以animateChange返回false，因此也不会触发postAnimationRunner。\nrecyclerview中只要被添加到页面上的viewholder，并且是scrap缓存中的，最终都会从scrap缓存中移除。而在上面的例子中，分析dispatchLayout2的时候总共有11个表项，分别是原来的表项0（存在于changeScrap缓存中），dispatchLayout1创建的表项10（存在于attachScrap中）。在dispatchLayout3做完动画后，会清空掉scrap缓存，也就是调用了mLayout.removeAndRecycleScrapInt方法：\n1 2 3 4 5 void removeAndRecycleScrapInt(Recycler recycler) { //省略代码 recycler.clearScrap(); //省略代码 } 最终会调用clearScrap来清空scrap缓存。\n关于删除表项的动画处理，可以看这里:RecyclerView 动画原理 | 如何存储并应用动画属性值？\n","date":"2025-01-09T00:00:00Z","permalink":"http://xiangcman.xyz/p/recyclerview%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86/","title":"RecyclerView动画原理"},{"content":"初始化过程 当我们app收到choregrapher的vsync信号的时候，choregrapher中会给主线程的messageQueue发送一条消息， 告诉app需要绘制了，而此时发送是通过给主线程的messageQueue设置一个callback（runnable），所以会触发handler的dispatchMessage-\u0026gt;handleCallback，接着就是触发FrameDisplayEventReceiver（runnable）的doFrame方法，该方法会计算丢帧数，以及执行callbackQueue数组中的callbackQueue，也就执行到了我们的performTraversal方法，该方法里面会执行到measure，最后执行到recyclerview的onMeasure，recyclerview的onMeasure中会判断自己的测量模式，如果是精确的模式，则不测量子item。\ntrace图如下： 接着走到recyclerview的onlayout，在onlayout里面触发dispatchlayout，该方法里面会判断state的step，默认是STEP_START，因此会触发dispatchLayoutStep1和dispatchLayoutStep2，在dispatchLayoutStep1中如果有动画要处理，则会触发layoutManager的onlayoutChildren\n有动画的条件是： 有表项新增或移除、有更改的时候。默认是没有动画要处理，紧接着来到了dispatchLayout2，该方法主要是触发了layoutManager.onLayoutChildren。 调用链如下： linearlayoutmanager.fill-\u0026gt;layoutmanager.layoutChunk-\u0026gt;layoutstate.next-\u0026gt;recycler.getviewforposition-\u0026gt;recycler.tryGetViewHolderForPostionByDeadline-\u0026gt;adapter.createViewHolder-\u0026gt;adapter.bindViewHolder到这里一个holder的创建和bind过程就结束了，紧接着在layoutchunk中触发layoutmanager.addView和layoutmanager.measureChildWithMargin，到这里表项才会被加入到recyclerview中，但是此时不会刷新recyclerview。 上面说到的layoutchunk会在一个while循环中多次执行，直到recyclerview的空间没有了才不会执行，而layoutchunk又会走recycler.next去从缓存中拿viewholder，而此时缓存中没有viewholder，因此会走createviewholder和bindviewholder，所以一开始create和bind次数是一屏能展示多少个表项的次数。 接着在dispatchlayout中会调用dispatchlayoutstep3，该方法里面主要是执行scrap缓存的释放，以及动画的执行\n到这里，测量和layout已经梳理完了，最后就剩draw了： draw里面基本没干什么，还是沿用了viewgroup的drawchild方法，绿色表示非系统方法，因此可以看出来recyclerview是重写了该方法： 总结： 初始化分为onmeasure阶段：如果recyclerview设置了固定宽高，则直接跳过测量，调用到mLayout中，如果不是固定宽高，则会走dispatchLayoutStep1，dispatchLayoutStep2。其中dispatchLayoutStep1是预布局处理，如果有动画要处理才会在该阶段调用到layout的onLayoutChildren。在dispatchLayoutStep2中处理表项的测量。 在onlayout阶段：会判断step还是不是start状态，如果是的话，则再次执行dispatchLayoutStep1和dispatchLayoutStep2。最后调用dispatchLayoutStep3用来做动画执行并释放相关资源。 在draw阶段基本什么都没做，dispatchDraw本身会调用到drawChild，recyclerview只是重写了该方法。\n滑动过程 滑动过程中会调用到scrollByInternal-\u0026gt;layoutmanager.scrollBy-\u0026gt;fill-\u0026gt;layoutchunck。 layoutchunck里面会从缓存中取数据，如果有则命中，没有则走create和bind，接着划出屏幕的表项会先加入到cache缓存中，如果cache缓存满了，则重置该表项，加入到recyclerpool中，下次所以取的时候从recyclerpool根据viewtype取需要重新bind，不需要create，所以在滑动过程中create的次数是cache的大小次数，等到recyclerpool中有缓存的时候就不需要create了。\n在fill过程中，会找到划出屏幕的表项，然后先调用recycleByLayoutState，接着调用到了Linearlayoutmanager.recycleChildren，接着会触发recyclerview.removeAndRecycleViewAt方法，接着就触发了adapter.onViewDetachedFromWindow(viewHolder)，接着就把viewholder缓存到cache和recyclerpool中，对应的方法是recycler.recycleView-\u0026gt;recycleViewHolderInternal,其中cache缓存中默认是2个，如果大于2的话，会把最前面的那个给放到recyclerpool中，接着再把新的viewholder放进来。\n在fiil过程中，会通过LayoutState.next从缓存中获取viewholder，获取的时候会先判断是不是preLayout状态，如果是则从changeScrap缓存中获取，从changeScrap中获取缓存先通过position获取，如果用position获取不到，则再用id去获取（必须adapter设置setHasStableIds为true，并且adapter重写了getItemId）。如果没获取到则从attacheScrap和cache中获取，如果从attach和cache中找不到，则继续通过id从attachScrap中获取，如果还没获取到则从viewcacheExtension中去获取，如果还获取不到则再从recyclerpool中去获取，如果还获取不到则通过create来创建viewholder，接着走bind逻辑。\n所以整个缓存获取顺序： changeScrap(preLayout状态，先通过position获取，没获取到再通过id获取)-\u0026gt;attacheScrap-\u0026gt;cache-\u0026gt;attachScrap(id方式获取)-\u0026gt;viewcacheExtension-\u0026gt;recyclerpool-\u0026gt;createholder-\u0026gt;bindholder 这就是layoutstate.next获取viewholder整个逻辑，上面哪些会触发createholder和bindholder 如果从几个缓存中都拿不到viewholder，则会走createholder的逻辑。\n什么情况下会调用onBindViewHolder？ 不是bound状态 bound标志位：是在bindViewHolder的时候设置的，因此不是bound表示没有bind过。没有bind过有：1，createholder；2，从recyclerpool取的viewholder。 needsUpdate：该状态表示什么？什么时候才会是needUpdate()呢？ 在viewRangeUpdate设置的。猜测是在viewholder发生变化的时候设置的，验证猜想： recyclerview.processAdapterUpdatesAndSetAnimationFlags-\u0026gt;AdapterHelper.preProcess-\u0026gt;applyUpdate-\u0026gt;postponeAndUpdateViewHolders -\u0026gt;markViewHoldersUpdated-\u0026gt;viewRangeUpdate，所以在dispatchLayout1过程中给flag设置了update状态\nisInvalid：表示什么状态？什么时候赋值的？ markKnownViewsInvalid会对所有页面上可见的viewholder设置为FLAG_INVALID，并且把cache缓存中的viewholder设置为FLAG_INVALID，它是在notifydataSetChange时候调用 在holder缓存获取的时候，如果发现holder的viewtype和adapter中重写的viewtype不一致会重置，会给viewholder添加该标志位 从缓存（attachScrap、cacheview）中获取viewholder的时候，如果发现type和holder的type不一致，则会校验不通过。或者设置了stableids为true的时候，如果adapter中的id和holder的id一致，则也通过。 所以结论就是，需要bound的条件：没有bound过（createholder的holder还没有bound过或者是从recyclerpool中获取的holder）；needupdate的，holder发生更新了。invalid，从attachscrap、cache获取后， 如果type不一致也需要重新bound，或者是调用了notifydataSetChange后，所有的viewholder都会添加nvalid标志位，此时也需要bind。\n更新表项 notifyItemChange(0)：更新表项第0的位置\n首先是进入页面创建了10个表项，然后更新后日志如下： 首先给我创建了索引为10的表项，也就是屏幕上不可见的，接着又创建了表项0，通过traceview分析： 整体看经历了rv的layout过程，分别对应了dispatchLayoutStep1、dispatchLayoutStep2、dispatchLayoutStep3。\ndispatchLayoutStep1 detachAndScrapAttachedViews 共经历了10次scrapOrRecycleView： 它是反向遍历页面上的view，然后添加到srap缓存中： 从scrapOrRecycleView的调用栈来看，是走了else部分，也就是往scrap缓存中加入viewholder。由于viewHolder的isInvalid为false，所以会走else。 scrap缓存分两种，attachScrap和changeScrap。不是update的会放到attachScrap中，所以我们更新第0个的时候会放到changeScrap中，在detach的时候由于是反向加入到scrap缓存中的，因此我们看第10个的trace调用： 从这里看第0个表项在detach的时候会加入到changeScrap中。 结论：在dispatchLayout1中，先将页面上可见的viewholder从页面上分离，然后将update的viewholder放入到changeScrap中，把非update的viewholder放入到attachScrap中。\nfill fill阶段发生了layoutChunk11次，而我们刚开始列表是初始化了10个表项，那么说明dispatchLayout1阶段添加了一个新的viewholder，关于这块我们可以给出结论，如果viewhodler被设置了remove或者update标记的时候，则会给列表添加一个新的viewholder。关于这块可以看：https://juejin.cn/post/6890288761783975950 在fill的while循环中会判断remainingSpace时候大于0，而每次layoutChunk过程中会将remainingSpace减小，而layoutChunkResult.mIgnoreConsumed就是判断是否要减小，意思是如果不忽略才会减小，那什么时候会忽略呢？ layoutChunk中判断viewholder如果是remove或者是change时候，才会忽略减小。所以我们会有11次的layoutChunk，而最后一次的layoutChunk会走createViewHolder，也就对应了上面的日志先添加了position=10的viewholder。从trace上看下： 结论： dispatchLayout1过程中，将第0个放入到changeScrap中，1-9放入到了attacheScrap中，并且创建了索引为10的viewhodler。\n注意： 在dispatchLayout1过程中，如果viewholder经过了addView之后，则会把它从changescrap或者是attachscrap缓存中移除，所以在dispatchlayout2过程中change和attach的缓存为空的。 其实在dispatchLayout2过程中添加viewholder的view时候也是要从scrap缓存中移除。\ndispatchLayoutStep2 detachAndScrapAttachedViews 由于在dispatchLayout1过程中创建了position=10的viewholder，因此会有11次，这11个里面第0个还是添加到了changeScrap中，1-10是添加到attachScrap中。\nfill 为什么此过程只有10次layoutChunck呢？这块其实还是回到remainingSpace的计算说起： 所以在dispatchLayout2过程中当添加到索引等于9的时候remainingSpace就为0了，所以索引等于10的时候添加不上，因此只会有10次layoutChunck。\nlayoutChunck 我们可以看到第0个走了createViewholder和bindViewholder： 是由于第0个viewholder被添加到了changeScrap缓存中，而1-9的viewholder添加到了attachScrap中，而changeScrap只会在pre-layout过程中才会生效： 所以可以看到上面日志中会走了position=0的createViewHolder和bindViewHolder。\n总结: 更新表项的时候，会经历dispatchLayout1，dispatchLayout2，其中在dispatchLayout1（pre-layout阶段）会先把可见的表项给回收到scrap缓存中，回收后，会把可见的表项从recyclerview中分离，其中需要变化的表项会加入到 changeScrap中（第1个表项），不变化的加入到attachScrap中（第2个到第10个表项）。接着在fill阶段会从scrap缓存中取表项，由于有表项更新，所以此时会去创建不可见的表项（第11个表项），最后会添加到recyclerview上。 在dispatchLayout2（post-layout阶段）同样会把dispatchLayout1添加进来的表项给添加到changeScrap（第1个表项）和attachScrap（第2个到第11个表项）缓存中，注意此时的表项会是11个表项。在fill阶段会去创建表项0， 因为post-layout阶段不会去取changeScrap中的viewholder，所以表项0会经历创建。并且此时不会添加第11个表项，因为在fill完第10个表项的时候，其实rv的可用空间已经不够了。上面提到表项添加到rv后，会将viewholder从scrap缓存中移除掉，而由于原来的表项0和表项10没有被添加到rv上。所以还在scrap缓存中，这两个scrap缓存是在dispatchLayout3中被移除的。\n删除表项 notifyItemRemove(0)\ndispatchLayout1 detachAndScrapAttachedViews 调用了10次scrapOrRecycleView 第0个调用scrapView添加到attachScrap缓存中 1-9的表项也是添加到attachScrap缓存中，这个可以从trace中看到。 fill 和update过程一样，在dispatchlayout1有11次layoutChunk，delete和update的viewholder不作为消费remainingSpace。 接着调用layoutstate.next获取viewholder，此时只有索引等于10的时候会去创建viewholder。注意了：此时创建完viewholder后，bind过程传的position=9： 在bind过程中会传入postion=10，而此时的mPostponedList中有一个op是remove类型的，所以postion会减一，因此它的postion是9： dispatchLayout2 detachAndScrapAttachedViews 此处scrapOrRecyclerview发生了11次，因为在dispatchLayout1创建了一个新的viewholder，11个viewholder都加入到了attachScrap缓存中。 fill layoutChunk调用了10次： 在第一个viewholder获取的时候获取到原来的第二个表项了，原来的第一个表项的position被置为-1了，所以我们0-9的表项都不会重新创建viewholder。也就对应上面的日志。 疑问： 此处的position赋值貌似都重新赋值了，因此我们看下是哪里重新赋值了： 当调用notifyItemRemove(0)的时候，在dispatchlayout1过程中会触发offsetPositionRecordsForRemove方法，该方法会通过remove的itemCount数重新给每一个页面上的viewhodler重新给赋上position的值，所以会看到上面的attachScrap缓存中最后一个viewholder的postion=-1了。 scrap缓存 在fill之前会把页面上的viewholder先detach掉，最终会调用到viewgroup的detachViewFromParent方法，removeView也会调用该方法，只不过viewholder的detach不会立马requestLayout。接着就是调用scrapView。 scrap缓存分两种，一种是attach、另外一种是change，如果viewholder是发生了变化（notifyItemChange），则会加入到change中，否则加入到attach中。接着在layoutChunk过程中，会从scrap缓存中找viewholder。 在dispatchLayout3过程中，会调用layout.removeAndRecycleScrapInt方法： 里面会调用recycler.clearScrap： 会清空scrap缓存。 总结：scrap缓存在每次layoutChild之前会先把页面的viewholder先放到scrap缓存中，在dispatchLayout3的时候，会把该缓存清空掉。\nAdapter.onViewAttachedToWindow 刚进入屏幕会触发onViewAttachedToWindow，从0-9都打印了。 从trace来看，初次每个viewholder都会经历onViewAttachedToWindow方法。\n下面看看什么时候不会调用onViewAttachedToWindow方法？ 每次在layoutChunk的时候，从缓存中去拿viewholder，如果从scrap缓存中拿到了，则不触发childHelper的addView，也就不会触发adapter.onViewAttachedToWindow；如果当前view的parent是当前recyclerview的时候，也不触发childhelper的addview。如果都不满足则触发adapter.onViewAttachedToWindow。\n滑动的时候是否触发？ 滑动过程中表项从不可见到可见会触发onViewAttachedToWindow，因为它不是从scrap缓存中获取到的，它是从cache缓存或者是recyclerpool中获取的。onViewAttachedToWindow触发不一定会触发oncreateViewHolder，也不一定会触发onBindViewholder。如果cache缓存和pool缓存中都没有该viewholder，则会触发oncreateViewHolder和onBindViewholder。如cache中有，则只触发onViewAttachedToWindow。如果从pool中拿到缓存，则会触发onBindViewholder和onViewAttachedToWindow。\n更新列表是否会触发？ 拿上面更新表项0来看，由于在dispatchLayout1(pre-layout)过程中会创建表项10，所以会经历表项10的oncreate和onbind，并且把它添加到rv中，所以会有一次的表项10的onViewAttachedToWindow，接着会在dispatchLayout2过程中会创建表项0（因为表项0存在了changeScrap缓存中），所以会走表项0的onViewAttachedToWindow。\nAdapter.onViewDetachedFromWindow 滑动过程中，划出屏幕的表项会调用onViewDetachedFromWindow。\nfindViewHolderForAdapterPosition和findViewHolderForLayoutPosition区别： 结论：正常情况下adapterPostion和layoutPosition是相等的，当有add、remove、move的时候两者是不一样的。adapterPostion会算上要改变的表项，比如上面我要删除第一个表项，那么拿到的表项就是第二个。而layoutPostion是页面最终呈现的表项，上面例子中等到post完后，才会真正的删除掉。所以post（绘制后）后layoutposition获取到的是原来的第二个表项。\nnotifydatasetChange问题 先是把页面上所有的都detach掉，然后又走了所有的viewholder的onbind过程，从索引为5的viewholder走了oncreateviewholder。下面看下trace： layout过程只走了dispatchLayout2，在里面走到了linearlayoutManager.onLayoutChildren，里面会触发fill。在fill之前会走detach逻辑，里面会反向遍历可见的子view，并调用scrapOrRecylerview： 每一个子view回收都走了removeViewAt: 此处由于所有的viewholder都是invalid状态了，因为在notifyDatasetChange在调用requestLayout之前把页面上的子view都设置成invalid状态了： 所以在fill之前都会调用removeViewAt，而该方法会触发onViewDetachedFromWindow，因此可以看到前面日志中先反向打印了9-\u0026gt;0的onViewDetachedFromWindow。接着会调用recycler.recycleViewHolderInternal，该方法是把viewholder加入到cache或者是recyclerpool中： 如果存在invalid状态，则会把viewholder加入到pool缓存中，trace验证下： 而pool缓存是5个，因此先把9-\u0026gt;5存到poo中时，发现pool满了，则把9给移除掉，因此最后只剩下5个viewholder在pool中。接着在layoutChunk阶段，会从缓存中拿viewholder的时候，只有pool中5个viewhold的缓存，取完一个remove掉一个，当索引为5的时候，pool中已经拿完了，因此5-9会去创建viewholder。\n参考：\nRecyclerView 缓存机制 | 如何复用表项？ RecyclerView 缓存机制 | 回收些什么？ RecyclerView 缓存机制 | 回收到哪去？ RecyclerView缓存机制 | scrap view 的生命周期 ","date":"2025-01-02T00:00:00Z","permalink":"http://xiangcman.xyz/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/","title":"RecyclerView源码走读"},{"content":"suspendCoroutine 在android中无处不在获取view的宽高，而获取宽高是需要在view绘制完后才能获取，所以这是一个时机问题，通常通过view.post来获取，那么用协程如何形如同步获取宽高呢？下面来试试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 GlobalScope.launch { val wh = getViewWh(view) Log.d(TAG, \u0026#34;width:${wh.first}\u0026#34;) Log.d(TAG, \u0026#34;height:${wh.second}\u0026#34;) } Log.d(TAG, \u0026#34;outer coroutine\u0026#34;) private suspend fun getViewWh(view: View) = suspendCoroutine\u0026lt;Pair\u0026lt;Int, Int\u0026gt;\u0026gt; { continuation -\u0026gt; view.post { val width = view.width val height = view.height continuation.resume(Pair(width, height)) } } 日志如下：\n1 2 3 11:00:57.708 D outer coroutine 11:00:57.810 D width:1080 11:00:57.810 D height:2206 使用了suspendCoroutine方法，方法的返回值，是suspendCoroutine指定的泛型。 可以看到日志正常获取，下面来看看字节码是如何实现的： launch启动的时候，内部的协程代码块编译结果是SuspendCoroutineActivity$onCreate$1： 调用了SuspendCoroutineActivity的静态方法access$getViewWh：\n静态方法是直接调用了成员方法getViewWh，它是本次的重要实现：\n传进来的Continuation对应了SuspendCoroutineActivity$onCreate$1，它是传给了SafeContinuation，此处注意到调用了continuation的intercepted方法，它是continuation的扩展方法，它是在continuationImpl中实现了，它实际是看context中是否有dispatcher，这块在协程切换线程中讲过，它实际是生成了一个CoroutineDispatcher。\n接着看又调用了SuspendCoroutineActivity$getViewWh$2$1这个Runnable对象，并把SafeContinuation传进去了： 此处的Runnable就对应了post中的代码块，最终在run方法中调用了continuation的resumeWith方法，并把宽高回调出去了。此处的continuation是SafeContinuation，看下它的resumeWith方法： 此处的result默认值是UNDECIDED： 由于默认值是UNDECIDED，在上面getViewWh中先调用了safeContinuation的getOrThrow方法： 所以会给result设置上了COROUTINE_SUSPENDED标记，所以在上面的suspendLambda的invokeSuspend方法中能被挂起，等到执行safeContinuation的resumeWith的时候，上面的suspendLambda就恢复了。最终获取到结果，整个流程就结束。\nsuspendCoroutine的回调中还有一个resumeWithException方法，用于返回失败的结果，如果返回失败的时候，需要捕捉异常。\nsuspendCancellableCoroutine 它和suspendCoroutine区别是回调中是一个CancellableContinuationImpl，它提供了cancel方法，当cancel的时候，程序不会崩溃。它会把cancel的结果分发到delegate中，此处的delegate其实就是对应了GlobalScope.launch启动时的suspendLambda，最后它会分发到父job中。看下CancellableContinuationImpl的cancel方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public override fun cancel(cause: Throwable?): Boolean { _state.loop { state -\u0026gt; if (state !is NotCompleted) return false // false if already complete or cancelling // Active -- update to final state val update = CancelledContinuation(this, cause, handled = state is CancelHandler || state is Segment\u0026lt;*\u0026gt;) if (!_state.compareAndSet(state, update)) return@loop // retry on cas failure // Invoke cancel handler if it was present when (state) { is CancelHandler -\u0026gt; callCancelHandler(state, cause) is Segment\u0026lt;*\u0026gt; -\u0026gt; callSegmentOnCancellation(state, cause) } // Complete state update detachChildIfNonResuable() dispatchResume(resumeMode) // no need for additional cancellation checks return true } } 此处会构造出CancelledContinuation，它是CompletedExceptionally对象，这个其实就是协程异常的扩展类，最终把该对象设置到CancellableContinuationImpl的state上。 一路跟到DispatchedTask的dispatch方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 internal fun \u0026lt;T\u0026gt; DispatchedTask\u0026lt;T\u0026gt;.dispatch(mode: Int) { assert { mode != MODE_UNINITIALIZED } // invalid mode value for this method val delegate = this.delegate val undispatched = mode == MODE_UNDISPATCHED if (!undispatched \u0026amp;\u0026amp; delegate is DispatchedContinuation\u0026lt;*\u0026gt; \u0026amp;\u0026amp; mode.isCancellableMode == resumeMode.isCancellableMode) { // dispatch directly using this instance\u0026#39;s Runnable implementation val dispatcher = delegate.dispatcher val context = delegate.context if (dispatcher.isDispatchNeeded(context)) { dispatcher.dispatch(context, this) } else { resumeUnconfined() } } else { // delegate is coming from 3rd-party interceptor implementation (and does not support cancellation) // or undispatched mode was requested resume(delegate, undispatched) } } 此处会走dispatcher.dispatch逻辑，因为上面的GlobalScope.launch其实创建的dispatcher是一个Dispatcher.Default类型的。DispatchedTask是一个runnable接口，看下它的run方法： 最终也是通过continuation的resumeWithException方法回调出去，然后交给了父job去处理，此时的exception是一个CancellationException，其实上面的suspendCoroutine也可以通过resumeWithException回调一个CancellationException，程序也不会崩溃。\n参考：https://juejin.cn/post/7121517604644061192\n","date":"2024-12-30T00:00:00Z","permalink":"http://xiangcman.xyz/p/%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/","title":"协程如何优雅的处理异步回调"},{"content":"本文通过案例来熟悉子协程到父协程之间的异常是如何处理的。\n案例一：子协程异常，父协程handler捕捉 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private fun demo1() { val handler = CoroutineExceptionHandler { coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;onCreate: CoroutineExceptionHandler:${throwable.message}\u0026#34;) } GlobalScope.launch(handler) { Log.d(TAG, \u0026#34;onCreate: parentJob start\u0026#34;) withContext(Dispatchers.IO) { throw RuntimeException(\u0026#34;runtime exception\u0026#34;) delay(1000) Log.d(TAG, \u0026#34;onCreate: withContext end\u0026#34;) } Log.d(TAG, \u0026#34;onCreate: parentJob end\u0026#34;) } } 先上日志：\n1 2 com.example.coroutinescopedemo D onCreate: parentJob start com.example.coroutinescopedemo D onCreate: CoroutineExceptionHandler:withContext runtime exception 结论：异常能被launch指定的handler所捕捉。\n分析： launch启动的协程用到的coroutineScope是一个StandaloneCoroutine，withContext启动的协程对应的coroutineScope是一个DispatchedCoroutine（因为父context和子context的dispatcher不一样，所以创建的是DispatchedCoroutine）。 在withContext中发生异常的时候，首先会回调到DispatchedCoroutine的resumeWith，最终会走到finalizeFinishingState方法，该方法里面会判断是否存在异常，如果有异常会调用cancelParent方法：\n可以看到如果isScopedCoroutine为true的时候，cancelParent直接返回true，如果返回true，那么就不触发自己的上面的handleJobException，也就是把异常继续往上抛了。例子中也就是launch对应的StandaloneCoroutine。而在StandaloneCoroutine中不会去cancelParent，因为它的parent是null，所以会把异常交给了handleJobException了，所以上面的launch中传入的CoroutineExceptionHandler能捕获到该异常。\n总结：如果子job中在处理异常的时候，cancelParent中如果isScopedCoroutine为true的时候，则不触发自己的handleJobException，也就是把异常交给了父job，如果父job不处理该异常，则会程序崩溃。\n案例二：子协程异常，子协程try-catch捕捉 上面代码如果把withContext中的异常通过try-catch住，父job就收不到该异常了： 子协程把异常catch住后，父协程的handler捕捉不到异常，并且父协程的invokeOnCompletion收不到异常，父协程之后的代码也能正常执行。因为在子协程对应的SuspendLambda中的invokeSuspend方法给try-catch住，不会把异常往上抛。\n案例三：子协程的handler无法捕捉 子协程给context传递coroutineExceptionHandler： 子协程抛了异常，然后子协程也传了CoroutineExceptionHandler，但是子协程的CoroutineExceptionHandler不起作用，还是把异常传给了父协程。并且父协程的invokeOnCompletion收到了异常回调，而且发现父协程的invokeSuspend方法也没走完，所以onCreate: parentJob end没有输出。\n分析：前面已经分析过withContext开启的协程对应的coroutineScope是一个DispatchedCoroutine重写了isScopedCoroutine=true，如果它为true，cancelParent方法则返回true，那么它自己的handleJobException就不会触发，所以就不会走到自己的CoroutineExceptionHandler回调了。\n案例四：子协程抛CancellationException，父协程无法捕捉 当子协程抛的是CancellationException，父协程捕捉不到该异常： 此处handler没有捕捉到异常，并且程序也没崩溃，这是因为在子协程把异常回调给父协程后，父协程对应的scope，也就是StandaloneCoroutine在cancelParent中判断是CancelationException，它直接返回true，所以不会调用handleJobException方法，而向外抛异常的正是该方法。所以当子协程抛出CancellationException时候不会使父协程崩溃。\n案例五：子协程抛异常，父协程分发到其它子协程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 private fun demo2() { val handler = CoroutineExceptionHandler { coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;handler:${throwable.message}\u0026#34;) } val job = Job() val coroutineScope = CoroutineScope(job + handler) val job1 = coroutineScope.launch { delay(100) Log.d(TAG, \u0026#34;job1 end\u0026#34;) throw RuntimeException(\u0026#34;runtime exception\u0026#34;) } job1.invokeOnCompletion { Log.d(TAG, \u0026#34;job1 invokeOnCompletion:${it?.message}\u0026#34;) } val job2 = coroutineScope.launch { delay(200) Log.d(TAG, \u0026#34;job2 end\u0026#34;) } job2.invokeOnCompletion { Log.d(TAG, \u0026#34;job2 invokeOnCompletion:${it?.message}\u0026#34;) } val job3 = coroutineScope.launch { delay(300) Log.d(TAG, \u0026#34;job3 end\u0026#34;) } job3.invokeOnCompletion { Log.d(TAG, \u0026#34;job3 invokeOnCompletion:${it?.javaClass?.simpleName}\u0026#34;) Log.d(TAG, \u0026#34;job3 invokeOnCompletion:${it?.message}\u0026#34;) } } 日志如下：\n1 2 3 4 5 6 com.example.coroutinescopedemo D job1 end com.example.coroutinescopedemo D job2 invokeOnCompletion:Parent job is Cancelling com.example.coroutinescopedemo D job3 invokeOnCompletion:JobCancellationException com.example.coroutinescopedemo D job3 invokeOnCompletion:Parent job is Cancelling com.example.coroutinescopedemo D handler:runtime exception com.example.coroutinescopedemo D job1 invokeOnCompletion:runtime exception 数据结构:父协程的job启动了三个子协程，在job1中抛出异常，job2和job3收到了JobCancellationException。其中父job是一个JobImpl对象，在每个子协程启动过程中都会创建一个ChildHandleNode对象，其中job指向了父Job，也就是JobImpl，childJob指向了当前子job，也就是StandaloneCoroutine，最后在子Job中通过parentHandle指向了父job（通过ChildHandleNode的parent指向了父job），state指向了InvokeOnCompletion对象(是通过invokeOnCompletion添加的)。父job中通过state指向了一个NodeList，每一个next节点指向了三个子job（分别都是ChildHandleNode对象）。在三个子job中通过delay实现挂起，在delay的时候，会创建CancellableContinuationImpl，它是用来监听job取消的task，它会通过ChildContinuation进行持有，最后ChildContinuation添加到当前子job的state上，所以目前每一个子job的state上有两个对象，一个是InvokeOnCompletion对象，一个是ChildContinuation，组合成一个NodeList对象。\n异常处理:当第一个job发生异常后，先将自己的state设置上Finishing状态，并且给Finish添加异常信息，接着会调用到job1的cancelParent逻辑，该方法中会调用到parentHandle的childCancelled逻辑，它是一个ChildHandleNode对象，在它的childCancelled方法中，会触发父job的childCancelled方法，最终会来到父job的cancelImpl方法。在cancelImpl中会触发cancelMakeCompleting-\u0026gt;tryMakeCompleting-\u0026gt;tryMakeCompletingSlowPath，在tryMakeCompletingSlowPath里面也会给父job设置上Finishing状态，同时会触发每一个ChildHandleNode对象的invoke，在invoke里面又会触发childJob的parentCancelled方法。此时又会来到每个子job的cancelImpl方法，在里面会触发makeCancelling方法。由于第一个job的state是Finishing状态，所以会给state添加一个JobCancellationException异常，但是不会覆盖原始异常。在job2和job3触发到cancelImpl方法时候，在makeCancelling里面，由于job2和job3的state是一个Incomplete对象，所以会创建JobCancellationException异常，接着调用了tryMakeCancelling方法，在该方法里面会给job2和job3的state设置上Finishing状态，并且会触发前面创建的ChildContinuation的invoke方法，在ChildContinuation的invoke中会触发CancellableContinuationImpl的parentCancelled方法，在里面最终会触发到SuspnedLambda的resumeWith，最后会触发job2和job3的resume方法，最终会把JobCancellationException异常分发到当前state的InvokeOnCompletion上。分发完子Job的cancelImpl后，继续回到父Job的tryMakeCompletingSlowPath流程中，给当前出现异常的job的state添加一个ChildCompletion对象并结束了tryMakeCompletingSlowPath流程。当job1的cancelParent逻辑都处理完后，也就是在finalizeFinishingState方法中。此时的cancelParent返回false，是因为调用父job的childCancelled时候handlesException变量为false，所以cancelParent方法返回false，那么此时会回调handleJobException方法，回调到CoroutineExceptionHandler，最后给state设置上CompletedExceptionally。接着会触发自己state的NodeList上的JobNode，一个是InvokeOnCompletion，一个是ChildCompletion，在ChildCompletion中会触发父job的continueCompleting方法，在该方法中会触发finalizeFinishingState逻辑，在该方法里面会将异常给到CoroutineExceptionHandler处理，但是此时的父job（JobImpl）没有重写handleJobException方法，所以不会分发到CoroutineExceptionHandler。最后将state设置为CompletedExceptionally，到此整个流程结束。\n所以上面的日志先是job2和job3的InvokeOnCompletion收到JobCancellationException异常，接着是context中的CoroutineExceptionHandler收到原始异常，最后是job1的InvokeOnCompletion收到原始异常。\n上面涉及到几个关键的类，把关键类的结构梳理下： 案例六：父Job使用SupervisorJob，异常不分发到其它子协程，异常协程自己处理异常 把案例五中的Job()换成SupervisorJob()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 private fun demo3() { val handler = CoroutineExceptionHandler { coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;handler:${throwable.message}\u0026#34;) } val coroutineScope = CoroutineScope(SupervisorJob() + handler) val job1 = coroutineScope.launch { delay(100) Log.d(TAG, \u0026#34;job1 end\u0026#34;) throw RuntimeException(\u0026#34;runtime exception\u0026#34;) } job1.invokeOnCompletion { Log.d(TAG, \u0026#34;job1 invokeOnCompletion:${it?.message}\u0026#34;) } val job2 = coroutineScope.launch { delay(200) Log.d(TAG, \u0026#34;job2 end\u0026#34;) } job2.invokeOnCompletion { Log.d(TAG, \u0026#34;job2 invokeOnCompletion:${it?.message}\u0026#34;) } val job3 = coroutineScope.launch { delay(300) Log.d(TAG, \u0026#34;job3 end\u0026#34;) } job3.invokeOnCompletion { Log.d(TAG, \u0026#34;job3 invokeOnCompletion:${it?.javaClass?.simpleName}\u0026#34;) Log.d(TAG, \u0026#34;job3 invokeOnCompletion:${it?.message}\u0026#34;) } } 只是换了个job，job1还是一样收到了原始异常，job2和job3正常执行，并能执行完。按照上面分析，当job1发生异常的时候，会调用到cancelParent，它会分发到父job的childCancelled方法，而SupervisorJob重写了该方法直接返回false。所以异常不会分发到子协程中，当job1的cancelParent返回false的时候，会执行到handleJobException，而job1使用的context中的CoroutineExceptionHandler是使用的父job中指定的CoroutineExceptionHandler。因为context是plus叠加的方式。所以最后handler中收到了异常。\n以下的案例来自于https://juejin.cn/post/7049537608262615070\n案例七：try-catch在非异常协程位置，无法捕捉 结果：try-catch竟然捕获不住，程序直接抛异常了\n如果想要调试的话，可以给协程拼接CoroutineName，这样在调试的时候知道job对应的context中CoroutineName。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 private fun demo7() { val scope = CoroutineScope(Dispatchers.Main + Job()) scope.launch(CoroutineName(\u0026#34;job1\u0026#34;)) { Log.d(TAG, \u0026#34;scope1:$this\u0026#34;) try { thirdApi(this) } catch (e: Exception) { Log.d(TAG, \u0026#34;demo7: e:${e.message}\u0026#34;) } } } private fun thirdApi(coroutineScope: CoroutineScope) { coroutineScope.launch(CoroutineName(\u0026#34;job2\u0026#34;)) { Log.d(TAG, \u0026#34;thirdApi: start\u0026#34;) delay(100) Log.d(TAG, \u0026#34;thirdApi: end\u0026#34;) throw NullPointerException(\u0026#34;null pointer exception\u0026#34;) } } 此处try-catch的位置不在子协程的SuspendInvoke位置，它是在主协程的launch位置，其实它是在invokeSuspend中调用内部launch的时候加了try-catch，对应的class代码如下：\n从字节码来看，只是启动子协程的时候给try-catch。\n第一阶段：job1给job2的state添加ChildCompletion监听\njob1的SuspendLambda在正常执行invokeSuspend，执行到job1的时候，来到了tryMakeCompletingSlowPath方法，在该方法中会给job2的state添加ChildCompletion回调\n第二阶段：job2触发job1的childCancelled\n从原理上分析，当子job2发生异常后，在cancelParent中会调用job1的childCancelled方法，接着调用到cancelImpl，由于job1是一个StandaloneCoroutine，所以接着调用makeCancelling，此时job1的state是一个Finishing，isCancelling还是false。所以会把异常加入到state中。接着触发了notifyCancelling方法，在里面调用了notifyHandlers。\n第三阶段：job1触发job2的parentCancelled\n在里面调用到ChildHandleNode的invoke，继而触发了job2的parentCancelled方法，来到了job2的cancelImpl，由于job2也是一个StandaloneCoroutine。所以会触发job2的makeCancelling，此时job2中的state是一个Finishing，并且isCancelling为true，所以job2的makeCancelling结束。\n第四阶段：job1触发父job的childCancelled\n继续回到job1的notifyCancelling方法，接着调用了cancelParent方法，又来到了父job（JobImpl），也就是父job的cancelImpl，由于父job是一个jobImpl，所以会调用cancelMakeCompleting，一路来到了tryMakeCompletingSlowPath方法。\n第五阶段：父job触发job1的parentCancelled 在该方法中接着触发了父job的ChildHandleNode的invoke，也就来到了job1的parentCancelled。又来到了job1的cancelImpl，此时job1的state是Finished，并且isCancelling = true，所以结束了makeCancelling。\n第六阶段：父job继续执行tryMakeCompletingSlowPath 父job1触发完parentCancelled后，在tryMakeCompletingSlowPath里面通过自己的ChildHandleNode的childJob（也就是job1）的state添加一个ChildCompletion对象。\n第七阶段：job2继续执行cancelParent之后的逻辑\njob2在finalizeFinishingState方法中执行完cancelParent之后，会执行completeStateFinalization逻辑，在里面会回调到第一阶段添加的ChildCompletion逻辑中，在里面会调用job1的continueCompleting方法，在该逻辑中会调用cancelParent，而cancelParent会回调false，所以会触发handleJobException，而job1对应的是StandaloneCoroutine，它里面会拿context中的CoroutineExceptionHandler，如果没拿到直接抛异常。\n案例八：异常job的父job处增加CoroutineExceptionHandler捕捉异常 结果：此处不会发生异常，异常被exceptionHandler捕捉。\n分析：结合案例七的分析，在第七阶段，job1处理异常的时候，会交给handleJobException方法，并让CoroutineExceptionHandler捕捉异常，因此不会崩溃。\n案例九：handler给到异常协程，handler捕获不到异常 分析：结合案例七的分析，最终是在job1中处理异常，而此处设置的handler是设置到job2处了，所以程序崩溃了。\n案例十：增加coroutineScope，异常协程的父协程增加try-catch捕捉异常 结果：程序不会崩溃，异常被try catch捕获住，而不是被exceptionHandler捕获住。\n前面分析过当子协程发生异常后，会把异常分发给到父job，在父job中需要等子job都处理完异常了，才会往下走，该处逻辑主要体现在子job中添加了一个ChildCompletion节点到state中，在invoke中会执行到parent.continueCompletion方法： 此处的parent实际是coroutineScope作用域的job，它是ScopeCoroutine，看下它的continueCompleting实现： 最终会把结果回调给到了传递进来的continuation，也就是最外层launch启动的时候的SuspendLambda，最终会调用它的invokeSuspend方法： 所以最终被try-catch捕捉到异常。\n案例十一：增加supervisorScope作为异常协程的作用域，异常能被异常协程的handler所捕获 结果：程序被内层launch指定的exceptionHandler捕捉了 supervisorScope用到的job是SupervisorCoroutine，它重写了childCancel方法，并返回false，所以当子job发生异常的时候，不会抛给父job，并执行自己的handleJobException方法，所以被自己的handler捕获到。\n案例十二 集合案例七分析，在第七阶段，job1在处理异常时，会找到自己的handler，最终异常被外层的handler所捕获。\n案例十三：增加supervisorScope作为异常协程的作用域，异常被内部的handler所捕获 此时被内层launch的handler所捕捉，原因是supervisorScope启动的协程不会往上抛，交给了子协程自己处理。\n总结 父子协程关系：父子协程之间通过job建立起关系，在子协程的job初始化的时候，会通过childHandleNode绑定到父子关系，其中子job指向childHandleNode的childJob，父job指向childHandleNode的job上，最后子job通过parentHandle持有该childHandleNode。父协程中如何包含了多个子协程，此时父job的state会是一个NodeList，也就是链表结构的对象，然后NodeList的next节点持有了第一个子协程的childHandleNode，第一个子协程的childHandleNode的next节点持有了第二个子协程的childHandleNode，依次类推。\n异常处理：当某个子协程发生异常后，会将自己的state给置为Finishing状态，并且给Finishing状态添加异常信息，接着将异常给到父协程，如果此时父协程不处理异常，则交给自己的context中的CoroutineExceptionHandler处理，如果context中找不到CoroutineExceptionHandler，则将异常抛给系统，直到app崩溃。如果父协程处理异常，则会先取消掉自己下面的其他子协程的job，然后将异常继续抛给自己的父协程，依次这样去处理异常。\n","date":"2024-12-17T00:00:00Z","image":"http://xiangcman.xyz/p/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AD%90%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/cover_hu_7c81ba7442e02e1a.jpg","permalink":"http://xiangcman.xyz/p/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AD%90%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"协程中子协程异常处理"},{"content":"invokeOnCompletion监听协程状态 在了解协程的异常处理之前，先来熟悉下协程之间job是如何绑定关系，还是通过一个例子来熟悉他们之间的关系：\n1 2 3 4 5 6 7 8 private fun demo(){ val job = GlobalScope.launch { Log.d(TAG, \u0026#34;demo: launch代码\u0026#34;) } job.invokeOnCompletion { Log.d(TAG, \u0026#34;demo: invokeOnCompletion\u0026#34;) } } 执行结果：\n1 2 CoroutineJobActivity com.example.coroutinescopedemo D demo: launch代码 CoroutineJobActivity com.example.coroutinescopedemo D demo: invokeOnCompletion 可以看出来invokeOnCompletion是job执行完毕的回调。\n通过launch创建协程内部会构造一个StandaloneCoroutine，它就是一个job，并且launch返回的就是该job： StandaloneCoroutine继承自AbstractCoroutine： 因此parentHandle为NonDisposableHandle，然后方法结束。 此时执行完launch后，继续执行了job的invokeOnCompletion方法，它是一个抽象方法，实现方法在jobSupport类： 我们看下makeNode方法实现： 从调用链上看onCancelling传进来的是false，并且此时的handler还不是一个JobNode节点，所以会创建了一个InvokeOnCompletion对象，并把外面传进来的ComppletionHandler传到InvokeOnCompletion中，看下InvokeOnCompletion对象：\n1 2 3 4 5 private class InvokeOnCompletion( private val handler: CompletionHandler ) : JobNode() { override fun invoke(cause: Throwable?) = handler.invoke(cause) } InvokeOnCompletion是一个JobNode节点：\n1 2 3 4 5 6 7 8 9 10 internal abstract class JobNode : CompletionHandlerBase(), DisposableHandle, Incomplete { /** * Initialized by [JobSupport.makeNode]. */ lateinit var job: JobSupport override val isActive: Boolean get() = true override val list: NodeList? get() = null override fun dispose() = job.removeNode(this) override fun toString() = \u0026#34;$classSimpleName@$hexAddress[job@${job.hexAddress}]\u0026#34; } JobNode实现了CompletionHandlerBase抽象类：\n1 2 3 internal actual abstract class CompletionHandlerBase actual constructor() : LockFreeLinkedListNode(), CompletionHandler { actual abstract override fun invoke(cause: Throwable?) } 它也是实现了CompletionHandler接口，CompletionHandler是一个闭包，从上面继承以及JobNode实现来看，在它的invoke实现里面，会触发传进来的CompletionHandler的invoke实现，从实现来看其实这就是个静态代理的模式。\n结论： makeNode内部会返回一个InvokeOnCompletion对象，它是一个JobNode节点。\n回到上面的invokeOnComletion的实现，创建了InvokeOnCompletion后，会走到loopOnState的函数，它是遍历state，它的初始状态是一个Empty状态，并且state.isActive=true。所以最终把刚才创建的InvokeOnCompletion设置到了state上，并且返回了该InvokeOnCompletion。\n结论： 当调用了job的invokeOnCompletion方法后，会把外界创建好的CompletionHandler传给了InvokeCompletion，InvokeCompletion是一个JobNode，在它的invoke实现中，会回调到外界的CompletionHandler中。并且把创建的InvokeCompletion设置到当前job的state上了。\n协程体执行完job的执行： 在之前分析协程体其实是一个SuspendLambda，在它的invokeSuspend调用完后，会执行它的continuation的resumeWith方法，在上面例子中其实是StandaloneCoroutine，它是一个job，所以看下它的resumeWith实现：\n1 2 3 4 5 public final override fun resumeWith(result: Result\u0026lt;T\u0026gt;) { val state = makeCompletingOnce(result.toState()) if (state === COMPLETING_WAITING_CHILDREN) return afterResume(state) } 将协程体的结果传到了makeCompletingOnce方法中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 internal fun makeCompletingOnce(proposedUpdate: Any?): Any? { loopOnState { state -\u0026gt; val finalState = tryMakeCompleting(state, proposedUpdate) when { finalState === COMPLETING_ALREADY -\u0026gt; throw IllegalStateException( \u0026#34;Job $this is already complete or completing, \u0026#34; + \u0026#34;but is being completed with $proposedUpdate\u0026#34;, proposedUpdate.exceptionOrNull ) finalState === COMPLETING_RETRY -\u0026gt; return@loopOnState else -\u0026gt; return finalState // COMPLETING_WAITING_CHILDREN or final state } } } 轮训获取state，并调用了tryMakeCompleting方法： 从上面的分析知道state它是一个JobNode，它是一个InvokeCompletion，它不是一个ChildHandleNode，并且proposedUpdate不是CompletedExceptionally，所以会执行tryFinalizeSimpleState： 内部调用了completeStateFinalization方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private fun completeStateFinalization(state: Incomplete, update: Any?) { /* * Now the job in THE FINAL state. We need to properly handle the resulting state. * Order of various invocations here is important. * * 1) Unregister from parent job. */ parentHandle?.let { it.dispose() // volatile read parentHandle _after_ state was updated parentHandle = NonDisposableHandle // release it just in case, to aid GC } val cause = (update as? CompletedExceptionally)?.cause /* * 2) Invoke completion handlers: .join(), callbacks etc. * It\u0026#39;s important to invoke them only AFTER exception handling and everything else, see #208 */ if (state is JobNode) { // SINGLE/SINGLE+ state -- one completion handler (common case) try { state.invoke(cause) } catch (ex: Throwable) { handleOnCompletionException(CompletionHandlerException(\u0026#34;Exception in completion handler $state for $this\u0026#34;, ex)) } } else { state.list?.notifyCompletion(cause) } } 该方法中判断state是否是JobNode，如果是的话，会调用invoke方法。在上面分析过state是一个InvokeOnCompletion对象，在它的invoke里面会回调到传进来的CompletionHandler的invoke中，所以在上面例子中打印了job执行完成的日志。\ninvokeOnCompletion监听job的异常 还是通过一个例子来分析下：\n1 2 3 4 5 6 7 8 9 10 11 12 private fun demo3(){ val exceptionHandler =CoroutineExceptionHandler{ coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;demo3: CoroutineExceptionHandler--异常信息：${throwable?.message}\u0026#34;) } val job = GlobalScope.launch(exceptionHandler) { Log.d(TAG, \u0026#34;demo3: launch代码\u0026#34;) throw RuntimeException(\u0026#34;协程体里面发生异常了\u0026#34;) } job.invokeOnCompletion { Log.d(TAG, \u0026#34;demo3: invokeOnCompletion--异常信息：${it?.message}\u0026#34;) } } 此处用了一个CoroutineExceptionHandler方法，来创建CoroutineExceptionHandler对象来拦截异常的，这块先不用管，我们看下日志：\n1 2 3 com.example.coroutinescopedemo D demo3: launch代码 com.example.coroutinescopedemo D demo3: CoroutineExceptionHandler--异常信息：协程体里面发生异常了 com.example.coroutinescopedemo D demo3: invokeOnCompletion--异常信息：协程体里面发生异常了 可以看出来，invokeOnCompletion中也能收到异常的消息。 但是异常和正常收数据可能不太一样，主要区别是在resumeWith之后的处理不太一样： 如果是非异常的话，会走tryFinalizeSimpleState；如果是异常的时候会走tryMakeCompletingSlowPath，在该方法里面会触发finalizeFinishingState方法，该方法有个很重要逻辑： 由于cancelParent返回false，所以会触发handleJobException，StandaloneCoroutine重写了该方法： handleCoroutineException： 如果context中CoroutineExceptionHandler不为空，则异常不会往上抛了，所以此例中定义了context的CoroutineExceptionHandler程序不会崩溃。 回到上面再来看invokeOnCompletion的CompletionHandler触发时机，它是在finalizeFinishingState中触发，接着会调用到completeStateFinalization，最终在里面触发了invokeOnCompletion传进来的CompletionHandler。\n协程异常try住：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private fun demo4() { val exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;demo4: CoroutineExceptionHandler--异常信息：${throwable?.message}\u0026#34;) } val job = GlobalScope.launch(exceptionHandler) { try { Log.d(TAG, \u0026#34;demo4: launch代码\u0026#34;) throw RuntimeException(\u0026#34;协程体里面发生异常了\u0026#34;) } catch (e: Exception) { Log.d(TAG, \u0026#34;demo4: catch中代码\u0026#34;) } } job.invokeOnCompletion { Log.d(TAG, \u0026#34;demo4: invokeOnCompletion--异常信息：${it?.message}\u0026#34;) } } 日志如下：\n1 2 3 com.example.coroutinescopedemo D demo4: launch代码 com.example.coroutinescopedemo D demo4: catch中代码 com.example.coroutinescopedemo D demo4: invokeOnCompletion--异常信息：null 从日志中看，此处的CoroutineExceptionHandler不回调，并且invokeOnCompletion收不到异常信息。 我们通过字节码可以看到原因： 此处的异常catch住后，给到JobSupport就不是异常了，所以按照成功的处理方式一样。\n总结： job初始化阶段：通过引入invokeOnCompletion方法，来熟悉job如何分发异常，在上面事例中，通过launch启动的协程，它对应的job是StandaloneCoroutine，它的父类是AbstractCoroutine，在它的构造方法里面会调用initParentJob方法，该方法就是构建父job和当前job的关系，由于上面launch启动的协程的父job是空的，因此parentHandle指向了NonDisposableHandle对象。接着当调用了invokeOnCompletion方法的时候，会构造InvokeOnCompletion对象，并把业务方构造的CompletionHandler传到了InvokeOnCompletion对象中，当InvokeOnCompletion对象的invoke被调用的时候，会调用到外界传入的CompletionHandler的invoke方法。InvokeOnCompletion是一个JobNode对象，最终会被添加到job的state上。 job执行阶段：前面我们分析过SuspendLambda执行完invokeSuspend逻辑后，会接着调用上级continuation的resume方法，通过resumeWith-\u0026gt;makeCompletingOnce-\u0026gt;tryMakeCompleting。 异常处理：接着会判断是不是异常类型，如果是异常类型，则会触发tryMakeCompletingSlowPath-\u0026gt;finalizeFinishingState-\u0026gt;completeStateFinalization，其中在finalizeFinishingState是job处理异常的关键逻辑，如果cancelParent为false，则表示父job不处理异常，则会调用自己的handleJobException方法，在该方法中看context中是否有CoroutineExceptionHandler，如果有则捕获到异常，将异常分发给CoroutineExceptionHandler。如果没有则将异常往上抛，直到程序崩溃。如果不崩溃会在completeStateFinalization中拿到job的state中的InvokeOnCompletion对象，然后触发外界传入的CompletionHandler。 非异常处理：如果是非异常在tryMakeCompleting中会走tryFinalizeSimpleState-\u0026gt;completeStateFinalization，最终也会触发到InvokeOnCompletion对象。\nInvokeOnCompletion类图 异常处理时序图 ","date":"2024-12-16T00:00:00Z","permalink":"http://xiangcman.xyz/p/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"协程的异常处理"},{"content":"首先看一个例子： 日志如下： 和withContext的区别是launch后面的代码无需等到async执行完才执行。 字节码如下： launch部分启动的协程的invokeSuspend逻辑里面，只有label0的逻辑，和withContext不同的是会有挂起部分的判断，所以是同步执行的。\nasync的异步执行： 日志如下： 可以看到async2是先执行的，因为它没有进行delay，等到两个async执行完了后，才会执行launch里面的代码。 字节码如下： 编译后的代码： label=0的时候，通过async启动了两个协程，我们这里叫async1和async2，并且在里面通过await挂起了launch启动的协程。 分析：async1调用await后，由于状态是COROUTINE_SUSPENDED，所以第一次invokeSuspend方法结束，此时label=1。等到await逻辑执行完后，又会第二次执行invokeSuspend方法，此时由于lable=1，会执行async2的await方法，此时返回COROUTINE_SUSPENDED，所以invokeSuspend第二次结束，此时label=2。等到async2的await执行完后，第三次执行invokeSuspend方法，由于此时label=2，所以此时切回到自己的线程，执行launch部分的代码逻辑。\n总结： async的同步执行是因为没有挂起SuspendLambda的invokeSuspend方法，所以父协程不会挂起，而await方法是挂起函数，默认是返回COROUTINE_SUSPENDED，所以父协程挂起，当子协程逻辑执行完后，会回调父协程的invokeSuspend，当再次执行invokeSuspend的时候，label值发生了变化，因此会执行launch部分的逻辑。\n","date":"2024-11-28T00:00:00Z","permalink":"http://xiangcman.xyz/p/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/","title":"协程的同步执行原理"},{"content":"先来一个例子： 日志如下： 可以看到上面先是执行了withContext中的代码，然后执行了launch中的代码，注意到launch中也是在单独线程中执行的，其中launch中使用的Dispatcher是Dispatchers.Default类型的。前面分析过launch调度情况，最后会执行到continuation的resumeWith，然后调用它的invokeSuspend方法： 可以看到先执行withContext，因为withContext启动的时候，默认的状态是COROUTINE_SUSPENDED，所以退出了invokeSuspend方法，返回了var2，此时的label=1了。当执行完withContext的时候，会通知传给withContext的continuation，也就是上面的CoroutineDispatchersActivity$demo2$1这个SuspendLambda。所以会再次执行它的invokeSuspend方法，此时lable=1，所以最后返回了Unit.INSTANCE，整个invokeSuspend结束，这就是挂起的原因。 至于为什么在CoroutineDispatchersActivity$demo2$1中遇到了返回值为COROUTINE_SUSPENDED时候，不会继续执行了呢？看下BaseContinuationImpl中的resumeWith逻辑： 在BaseContinuationImpl的resumeWith中，如果invokeSuspend返回值是COROUTINE_SUSPENDED，则直接return了，不往上层的continuation调用了。\n至于再次执行CoroutineDispatchersActivity$demo2$1的invokeSuspend方法是在什么时候，可以追溯到withContext中： 执行了block的startCoroutineCancellable： 此处很熟悉啊，这不又启动了一个协程吗？协程套协程啊。好吧，我们直接看completion的回调，在协程挂起函数执行完后，会执行complete的resumeWith方法，此处是DispatchedCoroutine对象，继承自ScopeCoroutine： 它是先取continuation中context的ContinuationInterceptor，也就是上面launch启动的dispatchers，对应的是Dispatchers.Default，最终执行Dispatchers的resumeCancellableWith方法，在该方法里面最终会在协程指定的线程中执行协程代码块。所以在上面日志中能看到withContext执行完后，launch之后的代码能回到指定的线程中执行。\nwithcontext执行完了后会执行外面协程的resumeWith，所以launch的invokeSuspend再次执行。再次执行的时候会回到自己的线程。真相大白了！\n总结： 首先每一个协程代码块都会被编译成SuspendLambda对象，它也是一个Continuation对象，每次在执行到SuspendLambda的resume时候，都会去执行invokeSuspend方法，而该方法里面会去执行子协程，如果子协程返回COROUTINE_SUSPENDED状态的时候，父协程的resume方法会直接return了。当子协程执行完后，会通知父协程，此时父协程的的invokeSuspend方法再次被执行，而此时的状态机会发生变化，如果此时状态恢复后，会执行父协程中的Continuation，也就是父父协程的执行。\n","date":"2024-11-15T00:00:00Z","permalink":"http://xiangcman.xyz/p/%E5%8D%8F%E7%A8%8B%E6%8C%82%E8%B5%B7%E5%8E%9F%E7%90%86/","title":"协程挂起原理"},{"content":"在上一节介绍过Dispatchers.IO，它是一个CoroutineDispatcher对象，CoroutineDispatcher的执行是在DispatchedContinuation中的resumeCancellableWith方法，如果CoroutineDispatcher的isDispatchNeeded返回true，则会执行CoroutineDispatcher的dispatch方法。否则直接执行该runnable。\nDispatchers.Main 在安卓平台下，它其实是一个HandlerContext对象： 看下它的isDispatchNeeded和dispatch方法： 此时invokeImmediately默认是false，因此isDispatchNeeded返回true。所以会执行它的dispatch方法。在dispatch方法中将runnable给到了主线程的消息队列中，然后等主线程从消息队列中取该runnable。所以在上一节例子中它是晚于onCreate方法执行的。\nDispatchers.Main.immediate 它是HandlerContext中的immediate变量: 可以看到它是新创建了一个HandlerContext，并且invokeImmediately是true。在上一节的例子中，它的isDispatchNeeded返回false。所以它是直接执行SuspendLambda的resumeWith方法，因此上一节例子中它是要早于Dispatchs.Main执行的。\nDispatchers.IO 看下它的CoroutineDispatcher，对应的子类是DefaultIoScheduler，CoroutineDispatcher的isDispatchNeeded方法默认返回true，所以会执行它的dispatch方法： 在dispatch方法中调用了default的dispatch方法，default实际是一个LimitedDispatcher对象，看下它的dispatch方法： 在上面2处，判断当前runningWokers的数量，如果大于parallelism的时候，则不创建Worker，此处的parallelism的大小是64。从此处也能看出来Dispatchers.IO的线程数量不会超过64个。 最终该方法里面会通过DefaultScheduler.dispatchWithContext来创建CoroutineScheduler，来看下创建线程池的几个参数： 核心线程数： 最小2个，最大是cpu的核数。 最大线程数： 最大线程数取值(1 shl BLOCKING_SHIFT) - 2：最终得到的值是2^21-2 = 2097150。 非核心线程空闲时间是60s。\n结论：Dispatchers.IO指定的线程池最少线程数是cpu的核数，最大线程数是64个。\nDispatchers.Default 它是由DefaultScheduler构建的线程池，它所创建的最大的线程个数为:Math.max(2,cpu核数)。 上面两者在源码中主要体现在通过CoroutineScheduler的corePoolSize来控制最大线程数，而上面的Dispatchers.IO的最大64个线程其实在LimitedDispatcher中通过runningWorkers的原子类来控制着最大的任务数，当超过64个任务的时候，就不允许往里面添加了。它是通过把任务添加到queue中，如果当前正在执行的任务数小于64个的时候，才会从queue取走最前面的task，如果当前大于正在执行大于64个，则不会从queue中取最前面的task。\nDispatchers.IO和Dispatchers.Default都是由DefaultScheduler构建的，而DefaultScheduler其实是一个单例，因此不难看出它两是共用一个线程池的，只不过当Dispatchers.IO时候，最大线程个数控制在Math.min(64,cpu核数)，最多不会超过64个，Dispatchers.Default控制在cpu核数个数上。Dispatchers.Default常用作cpu密集型的任务，比如图片模糊处理、繁杂的计算型可以用这种类型的线程池。Dispatchers.IO由于它的线程数量多，并且它不能消耗cpu资源，因此常用作io处理，文件读写等操作上。 关于这点，可以看这篇文章：dispatcher拆解\n","date":"2024-11-13T00:00:00Z","image":"http://xiangcman.xyz/p/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/cover_hu_7c81ba7442e02e1a.jpg","permalink":"http://xiangcman.xyz/p/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/","title":"协程中的线程"},{"content":"在讲解如何切换线程之前，有必要先了解下CoroutineScope。协程作用域，它里面持有CoroutineContext，用来管理它的作用域范围内的所有协程。\nCoroutineScope(协程作用域) CoroutineScope组成 可见它只是一个接口，里面定义了一个coroutineContext。前面介绍过coroutineContext是协程的上下文，它里面是由Element拼接而成的，而Element主要分为如下几种：\nCoroutineDispatcher：它是线程分发器。其中Dispatcher.IO和Dispatcher.Main、Dispatchers.Main.immediate都是继承自于它 Job：它是用来取消协程、父协程与子协程取得联系的桥梁。常见的有SupervisorJob CoroutineName：用来给协程起名字的作用 CoroutineExceptionHandler：它是用来捕捉协程异常的回调器 所以完整的CoroutineContext组成部分如下： job+dispatchers+CoroutineName+CoroutineExceptionHandler\nCoroutineScope分类 目前kotlin已经内置了各种CoroutineScope，下面来说下他们的区别\nGlobalScope 上面用到的GlobalScope就是一个协程作用域： 可以看出来它是一个单例的scope，生命周期和app保持一致，并且它的context是一个EmptyCoroutineContext。平时开发时候不会去用它\nrunBlocking 是一个阻塞式的协程作用域，会阻塞协程外面的线程，内部是通过java的LockSupport.park阻塞住线程来实现的。 MainScope 它是一个指定协程分发在主线程中，并且使用到的Job是SupervisorJob，它的作用是当子协程出错的时候，不影响到父协程中的其他子协程 它是一个ContextScope，继承自CoroutineScope，并且它的context是由SupervisorJob()和Dispatchers.Main组成的一个context。我们一般自定义CoroutineScope的时候也是定义一个ContextScope，他的构造方法需要传入一个CoroutineContext。 CoroutineScope顶级方法 它也是一个ContextScope，它的上下文先看传进来的context中的job是否为空，如果为空，则初始化一个job。如果不为空，则使用传进来的context。\ncoroutineScope顶级方法 它是一个suspend方法，它是通过闭包的形式返回一个CoroutineScope，对应的字节码如下： 会将ScopeCoroutine给到block，也就是闭包中的CoroutineScope，接着会调用UndispatchedKt.startUndispatchedOrReturn: 最终调用了block.invoke方法，写个demo看下效果： 日志如下： 从日志可以看出来，它是先等到coroutineScope里面delay执行完了，才执行外面的逻辑。在字节码层面，它会把coroutineScope外面的代码编译成SuspendLambda，它也是个Continuation，等到执行完了coroutineScope内部的代码，才会回调到coroutineScope外面的SuspendLambda中来： 上面分析过UndispatchedKt.startUndispatchedOrReturn中调用了block的invoke方法，此处的block正对应了CoroutineDispatchersActivity$demo7$1这个SuspendLambda对象： 在demo7中将CoroutineDispatchersActivity$demo7$1这个continuation传递到coroutineScope中，而它的invoke方法如下： 创建了CoroutineDispatchersActivity$demo7$1后，继而调用了invokeSuspend方法，而invokeSuspend里面是要等到coroutineScope闭包中的delay挂起结束后，才会再次回到invokeSuspend方法，最后才会输出「demo7: coroutineScope outside」的日志，这也是协程挂起的调用顺序。\nsupervisorScope顶级方法 它和上面的coroutineScope顶级方法差不多，也是先调用完闭包中的逻辑，然后才执行supervisorScope外面的代码。看下它的实现就知道区别了： 他所使用的CoroutineScope是一个SupervisorCoroutine，它和上面用到的ScopeCoroutine区别是重写了childCancelled方法，并返回false，此方法是子协程发生异常后，该不该取消其它的子协程，下面来验证下： 在supervisorScope闭包中launch1发生异常了，由于supervisorScope不会去处理异常，将异常交给了launch1处理，所以launch2中的代码能继续执行。而在coroutineScope中，当launch1发生异常的时候，会将异常交给了coroutineScope，最终导致launch2的协程无法继续执行。\nJob Job实现了CoroutineContext.Element，可以用来取消、启动一个协程，并且和父协程绑定了关系： 它下面有几个关键的子类： 从图上可以看出来前面分析的coroutineScope和supervisorScope两个顶级方法所使用的作用域ScopeCoroutine最终也是一个Job。\n线程例子 先看一个例子： 分别指定了四种线程的用法，日志如下： 第一次： 第二次： Dispatchers.Main.immediate：指定的主线程会最先执行 Dispatchers.Main：指定的主线程会晚于协程外面的主线程 Dispatchers.IO和Dispatchers.Default：指定的线程没有先后之分\nCoroutineScope.lanuch lanuch方法是协程作用域的扩展方法，比如上面例子中的GlobalScope它就是继承自CoroutineScope:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public fun CoroutineScope.launch( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -\u0026gt; Unit ): Job { //① val newContext = newCoroutineContext(context) //② val coroutine = if (start.isLazy) LazyStandaloneCoroutine(newContext, block) else StandaloneCoroutine(newContext, active = true) //③ coroutine.start(start, coroutine, block) //④ return coroutine } 参数： context：launc传进来的context，比如上面例子中传进来的Dispatchers.Main、Dispatchers.IO这些都是CoroutineContext。如果没传就用EmptyCoroutineContext。 start：CoroutineStart的枚举类，表示启动模式，默认是DEFAULT block：协程代码块，是一个CoroutineScope的扩展挂起函数 将外界传进来的context和当前CoroutineScope的context进行合并处理 默认是DEFAULT模式，所以会初始化一个StandaloneCoroutine，会把newContext作为自己的parentContext，它既是一个Continuation，也是一个CoroutineScope 调用StandaloneCoroutine的start方法，并把启动模式，StandaloneCoroutine，协程挂起函数传进去了 StandaloneCoroutine作为lauch的返回值 StandaloneCoroutine它是一个Job类型，也是继承自AbstractCoroutine，看下它的start方法： 这里调用了start变量的invoke方法，因为CoroutineStart重写了invoke方法，所以能直接这么调，相当于是一个闭包的调用方式，这里调用了三参的invoke： 第一个参数：挂起函数闭包，也就是协程要执行的代码块 第二个参数：start方法传进来的StandaloneCoroutine 第三个参数：start方法传进来的this，也是StandaloneCoroutine CoroutineStart是DEFAULT类型，所以会调用挂起函数的startCoroutineCancellable方法： 在上面分析createCoroutine时候也是通过createCoroutineUnintercepted(receiver, completion).intercepted()，创建了delegate，最终是一个Continuation，也是一个suspendLambda。我们直接看ContinuationImpl的intercepted方法： intercepted方法里面取context变量中的key为ContinuationInterceptor的context，而context最终是completion的context，completion是前面start方法传进来的StandaloneCoroutine，它是继承自AbstractCoroutine： parentContext是launch方法传进来的context+CoroutineScope自己的context拼接的一个context this：AbstractCoroutine实现了job接口，job也是一个CoroutineContext 在上面例子中lauch方法是通过GlobalScope启动的，它的context是一个EmptyCoroutineContext，所以传给AbstractCoroutine的parentContext其实就是launch方法传进去的context，也就是Dispatchers.io、Dispatchers.main等。 回到ContinuationImpl的intercepted方法，取context的ContinuationInterceptor,然后调用interceptContinuation方法，看下Dispatchers.io，它最终继承自CoroutineDispatcher： 结论： 如果lauch传的是Dispatchers.io，则lauch先创建DispatchedContinuation，然后调用resumeCancellableWith方法： 如果dispatcher.isDispatchNeeded（默认是true），才会进入到dispatch逻辑，看下dispatchers.io： 调用了default.dispatch方法，diefault是由UnlimitedIoScheduler.limitedParallelism创建的LimitedDispatcher，最终会执行到UnlimitedIoScheduler.dispatch方法： DefaultScheduler的dispatchWithContext方法如下： coroutineScheduler创建如下： 最终会执行到CoroutineScheduler的dispatch方法，里面的代码就不细看了，是线程池部分执行block，关于这部分后面可以深究下，而block是在DispatchedContinuation中resumeCancellableWith方法里面把this给到了dispatcher的dispatch方法，说明DispatchedContinuation实现了Runnable接口，直接看它的run方法，该方法定义在它的父类DispatchedTask中： 此处执行了delegate的resume方法，resume方法执行了resumeWith，注意此处的delegate是DispatchedContinuation中传进来的continuation，它是createCoroutineUnintercepted(receiver, completion).intercepted()创建的delegate，是一个continuation对象，也是suspendlambda，在上面创建协程分析过baseContinuationImpl的resumeWith方法，里面会执行协程的invokeSuspend方法，也就是我们的协程执行代码。执行完了后会执行complete的resumeWith，而通过lauch创建的协程，此处的complete是launch方法构造的StandaloneCoroutine对象，它的resumeWith方法定义在AbstractCoroutine中： AbstractCoroutine的afterCompletion： 此处没有逻辑执行。 我们注意到在讲解协程启动的时候，创建delegate的continuation时候调用createCoroutineUnintercepted只传了complete，没有传receiver。而在launch启动协程时候，将StandaloneCoroutine作为receiver传给了createCoroutineUnintercepted方法： 默认的挂起函数的create方法是抛异常的，需要SuspendLambda的子类自己去实现： 编译后的SuspendLambda的子类create实现： 此处将receiver传到create中没有用到，所以其实跟单参没有什么区别啊。\n总结 结论：协程在启动过程中会取CoroutineContext中的ContinuationInterceptor，然后执行interceptContinuation。而此时如果是一个Dispatchers.IO，它又是继承自CoroutineDispatcher，所以会执行到了CoroutineDispatcher的interceptContinuation。此时得到的是一个DispatchedContinuation对象，并把当前的CoroutineDispatcher和协程启动过程中创建的StandaloneCoroutine传给了DispatchedContinuation。接着会执行DispatchedContinuation的resumeCancellableWith方法，在该方法里面会判断CoroutineDispatcher.isDispatchNeeded，如果是的话，会调用CoroutineDispatcher的dispatch方法，最终会通过线程池会执行到DispatchedContinuation的run方法，因为它是一个Runnable对象。在run方法里面，会执行continuation的resume方法，而此处的continuation是编译器给我们创建的SuspendLambda的子类，最终会执行它的invokeSuspend方法。执行完后会执行协程启动过程中的StandaloneCoroutine的resumeWith方法。\n时序图: ","date":"2024-11-05T00:00:00Z","permalink":"http://xiangcman.xyz/p/%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E7%BA%BF%E7%A8%8B/","title":"协程如何切换线程"},{"content":" 在讲协程的如何切换线程之前，有必要先了解下协程的上下文是什么？它的结构是什么样的？以及我们如何使用它？今天带着该问题来认识它。\nCoroutineContext 协程上下文都是继承自CoroutineContext，它是一个接口，内部方法以及内部类如下：\n它的实现子类有如下：\n比如我们常见的EmptyCoroutineContext，它的内部实现如下：\n可以看到它的get、fold、plus、minusKey几个方法都是默认实现，你可以理解它就是个空壳子的context。\nElement 在讲CoroutineContext内部结构之前，先来认识下Element，它也实现了CoroutineContext接口：\nElement中有一个key的属性，这里可以理解key就是当前Element的唯一标识。实现一个context的时候需要指明它的key是啥，此处就是用该key来标识 get：如果传进来的key和自己的key相等，则返回自己，否则返回null fold：将初始值和当前element返回给lambda，让lambda自己去处理 minusKey：如果传进来的key和自己相同，则返回EmptyCoroutineContext，否则返回自己，其实是删除对应key的context.\n写了3个context，然后用\u0026quot;+\u0026ldquo;拼接：\n自定义context的时候，需要继承自AbstractCoroutineContextElement，它是继承自Element，因为它强制要求需要一个key作为context的标识，一般key的element标识是当前context，看上面的One这个context，它的key拥有的element是One。\n输出日志如下：\nOne()+Two()+Three()得到的是一个CombinedContext，get方法通过One这个key取到了One这个取对应的Context\n日志如下： 可以看到我给One的context拼接了一个EmptyCoroutineContext时候，得到的是它自己，\u0026quot;+\u0026ldquo;是重载了context的plus方法，看下plus方法的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public operator fun plus(context: CoroutineContext): CoroutineContext = //① if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation //② context.fold(this) { acc, element -\u0026gt; //③ val removed = acc.minusKey(element.key) //③.1 if (removed === EmptyCoroutineContext) element else { // make sure interceptor is always last in the context (and thus is fast to get when present) //④ val interceptor = removed[ContinuationInterceptor] //⑤ if (interceptor == null) CombinedContext(removed, element) else { //⑥ val left = removed.minusKey(ContinuationInterceptor) //⑦ if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else //⑧ CombinedContext(CombinedContext(left, element), interceptor) } } } 1.如果传进来的context是EmptyCoroutineContext，则返回自己，所以上面的One()+EmptyCoroutineContext，得到的是One这个context 2.context.fold，会把初始值和context传给闭包，所以acc是当前context，element是传进来的context 3.acc.minuskey(element.key)，如果传进来的context的key和当前context的key相等，则返回传进来的context，所以新的context会把旧的context给覆盖掉了 4.如果传进来的context的key和当前context的key不相等，removed则是当前context，查看当前context中是否有ContinuationInterceptor类型的context，我们的dispatcher都是属于该类型，需要单独处理 5.如果context中没有ContinuationInterceptor类型的context，则初始化出一个CombinedContext的context，所以上面的One()+Two()+Three()是一个CombinedContext的context 6.如果当前context中存在ContinuationInterceptor类型的context，则继续判断当前context是不是ContinuationInterceptor类型的context 7.如果是ContinuationInterceptor类型的context，则把传进来的context和当前的context组合成CombinedContext的context 8.如果当前的context不是一个ContinuationInterceptor类型的context，则把当前当前的context和传进来的context新组合成一个CombinedContext的context，再和前面的ContinuationInterceptor组合成一个新的CombinedContext的context\nCombinedContext 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 internal class CombinedContext( private val left: CoroutineContext, private val element: Element ) : CoroutineContext, Serializable { override fun \u0026lt;E : Element\u0026gt; get(key: Key\u0026lt;E\u0026gt;): E? { var cur = this while (true) { cur.element[key]?.let { return it } val next = cur.left if (next is CombinedContext) { cur = next } else { return next[key] } } } public override fun \u0026lt;R\u0026gt; fold(initial: R, operation: (R, Element) -\u0026gt; R): R = operation(left.fold(initial, operation), element) public override fun minusKey(key: Key\u0026lt;*\u0026gt;): CoroutineContext { //① element[key]?.let { return left } //② val newLeft = left.minusKey(key) return when { //③ newLeft === left -\u0026gt; this //④ newLeft === EmptyCoroutineContext -\u0026gt; element //⑤ else -\u0026gt; CombinedContext(newLeft, element) } } override fun toString(): String = \u0026#34;[\u0026#34; + fold(\u0026#34;\u0026#34;) { acc, element -\u0026gt; if (acc.isEmpty()) element.toString() else \u0026#34;$acc, $element\u0026#34; } + \u0026#34;]\u0026#34; } 它是直接继承自CoroutineContext，有两个比较重要的属性：\nleft：CoroutineContext，它是左边的节点\nelement：Element，当前节点\n其实和链表的结构有点类似，left相当于next节点。\nget：递归节点，直到left节点不是CombinedContext类型的\nfold：先把left和初始值组成一个初始值，然后再把这个初始值和当前节点传给闭包\nminusKey：\n1.如果当前节点中找到了该key，则返回left节点\n2.如果找不到，则继续在left节点中找\n3.如果找不到返回this\n4.如果找到了则返回当前节点\n5.否则继续往左边再找\n整个分析来看，协程中的context如果是多个context拼接的时候如果传进来的是EmptyCoroutineContext，则只保存自己。如果传进来的context的key和当前context的key一样，则会覆盖掉原来的context。如果都不满足，则采用链表的形式插入到原来的context头节点上，如果传进来的是ContinuationInterceptor类型的，则会把该类型放到头节点。\n总结 CoroutineContext是协程重要的对象，它通过重载了plus方法，轻松的将每一个CoroutineContext拼接成一个新的CoroutineContext，一般的CoroutineContext会分为EmptyCoroutineContext，它是直接实现了CoroutineContext接口，可以理解它是没有任何信息的CoroutineContext。而Element是带有key的CoroutineContext，所以如果往CoroutineContext添加一个Element会通过它的key来找到对应的Element，Element下面常见的子类有ContinuationInterceptor，它是我们协程切换线程的CoroutineContext，还有常见的CoroutineExceptionHandler，它是我们协程捕捉异常的CoroutineContext，还有常见的Job，它是我们协程构建结构化的CoroutineContext，还有不常用的CoroutineName，它是用来给协程起名字的CoroutineContext。在通过+(plus)拼接CoroutineContext的时候，如果发现传进来的是EmptyCoroutineContext，则还是返回自己，如果不是EmptyCoroutineContext则会拼接成一个CombinedContext，它是一个链表结构的CoroutineContext，如果在+过程中发现要添加的CoroutineContext已经存在于原有的CoroutineContext中，则会用新的覆盖掉原有的CoroutineContext。但是在CombinedContext中会将ContinuationInterceptor类型的CoroutineContext放到链表的最前面。\n再来一张本次讲解的context类图：\n","date":"2024-11-04T00:00:00Z","permalink":"http://xiangcman.xyz/p/%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87/","title":"协程上下文"},{"content":"kotlin中inline，noinline，crossinline区别？ 默认函数中如果没加inline，那就是非内联函数，此时lambda会生成一个新的类，该类是继承自Lambda抽象类，并实现了Function接口，其中invoke方法就是Function接口的方法，invoke中的方法就是lambda代码块的代码。 内联函数(加inline关键字)的lambda如果没加noinline或crossinline，默认会把lambda的代码块给平铺到调用处，所以此时如果在lambda中加return的话，会直接不执行外层函数后续代码。如果是非内联函数的话，由于它是生成一个单独的类，不存在平铺代码，所以return是编译不过去的。 noinline和inline是对立关系，它是将lambda不内联处理，如果你需要对该lambda作为对象来使用的时候，此时需要用到noinline，如果一个内联函数都是noinline的lambda表达式，那么此时as会提示你此处可以去掉inline关键字了，当做普通的高阶函数来处理就行。 默认内联函数是能添加return来作为局部返回，由于存在平铺代码的特性，所以它能阻止调用lambda的外层函数的执行，那如果lambda作为间接调用的时候，此时添加return语句会编译失败，因为间接调用（比如匿名内部类或回调）不能阻止外层函数的调用，是为了避免多线程或回调中意外终止外层函数，所以kotlin编译器此时需要你添加crossinline，举个例子就清楚了： 此处的run闭包，它的调用是在runnable接口中的，此时编译器提示 it may contain non-local returns ，意思是此时存在间接调用，在间接调用lambda的时候，不允许在lambda中添加return来阻止外层的外层函数的执行。所以此处通过添加crossinline来阻止lambda中添加return\n疑惑：crossinline添加后，内联效果还在吗？还是以上面的例子来说明： 假如上面的hello方法我就作为普通的方法，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 object TestInline1 { @JvmStatic fun main(args: Array\u0026lt;String\u0026gt;) { hello { println(\u0026#34;hello的闭包\u0026#34;) } } fun hello(run: () -\u0026gt; Unit) { val runnable = Runnable { println(\u0026#34;runnable run\u0026#34;) run() } runnable.run() } } 对应的字节码如下：\n如果我把它作为内联函数来处理，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 object TestInline1 { @JvmStatic fun main(args: Array\u0026lt;String\u0026gt;) { hello { println(\u0026#34;hello的闭包\u0026#34;) } } inline fun hello(crossinline run: () -\u0026gt; Unit) { val runnable = Runnable { println(\u0026#34;runnable run\u0026#34;) run() } runnable.run() } } 对应的字节码如下：\n可以看出来crossinline还是有内联效果，闭包直接在runnable中平铺开来了。 相关文档：https://juejin.cn/post/6869954460634841101\njava lambda和kotlin lambda区别 在java中如果使用匿名内部类的形式，在编译时它是会单独生成一个类，其中类名是「外部类名$index.class」这种形式。如果使用lambda的形式，它不会在编译时单独生成一个类，它是执行了invokedynamic指令，在运行时动态生成lambda的类，其中类名是「外部类名$Lambda$index.class」这种形式。 参考:https://juejin.cn/post/7004642395060961310 kotlin lambda它是在编译时看是否需要生成单独的类，如果是内联的时候就直接平铺代码，如果是非内联的时候才生成单独的类。 协程是怎么挂起的？怎么恢复的？ 首先每一个协程代码块都会被编译成SuspendLambda对象，它也是一个Continuation对象，每次在执行到SuspendLambda的resume时候，都会去执行invokeSuspend方法，而该方法里面会去执行子协程，如果子协程返回COROUTINE_SUSPENDED状态的时候，父协程的resume方法会直接return了。当子协程执行完后，会通知父协程，此时父协程的的invokeSuspend方法再次被执行，而此时的状态机会发生变化，如果此时状态恢复后，会执行父协程中的Continuation，也就是父父协程的执行。 协程中的dispather是怎么指定在哪个线程上执行的？ 首先dispather它是CoroutineContext（上下文）的一部分，在协程启动过程中，会取CoroutineContext中的CoroutineDispathcer部分。此时会构造一个DispathedContinuation对象，并把前面取到的Dispather传到DispathedContinuation中，此时会将DispathedContinuation扔到线程池中，最终会执行DispathedContinuation的run方法，在run里面会执行到SuspendLambda，也就是协程的代码块，最终会执行它的invokeSuspend方法。所以协程代码块中代码要执行在哪个线程是协程上下文的dispather部分指定的线程。 相关文档：https://www.xiangcman.fun/p/%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E7%BA%BF%E7%A8%8B/\nLinkedList特性 LinkedList继承自Deque，它是一个双端队列，允许在队列的两端插入和删除元素。可以作为栈（LIFO）或队列（FIFO）使用。基于链表（双向链表）实现，可以高效地插入和删除元素。 offer：给链表尾部插入元素，返回值表示是否插入成功 peek：取出头部节点，如果没有则返回null poll：取出头部节点，如果没有则返回null，取完后并把头部节点从队列中移除 remove：移除头部节点，如果没有头部节点则抛异常，有的话，则返回 push：给链表头部插入元素，没有返回值 pop：和remove一样的，都是移除头部节点，如果没有头部节点则抛异常，有的话，则返回\n如果想实现队列的话，则使用offer和poll这一对方法；如果想实现栈的话，可以通过offerLast和pollLast来实现，或者通过offerFirst和pollFirst来实现。\nArrayDeque特性 它也是继承自Deque，和LinkedList的特性一样的，只不过ArrayDeque是通过数组实现的双端队列，内部用一个数组来放所有的节点，并且有两个int值用来存放头结点和尾结点的索引。并且ArrayDeque内部的默认节点容量是16个，也可以初始化容量大小。\n区别：如果频繁要插入和删除操作，那么使用LinkedList，如果是查询情况比较多，可以优先使用ArrayDeque。\nPools. Pool 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 class Pools private constructor() { /** * Interface for managing a pool of objects. * * @param T The pooled type. */ interface Pool\u0026lt;T : Any\u0026gt; { /** * @return An instance from the pool if such, null otherwise. */ fun acquire(): T? /** * Release an instance to the pool. * * @param instance The instance to release. * @return Whether the instance was put in the pool. * * @throws IllegalStateException If the instance is already in the pool. */ fun release(instance: T): Boolean } /** * Simple (non-synchronized) pool of objects. * * @param maxPoolSize The maximum pool size * @param T The pooled type. */ open class SimplePool\u0026lt;T : Any\u0026gt;( /** * The max pool size */ @IntRange(from = 1) maxPoolSize: Int ) : Pool\u0026lt;T\u0026gt; { private val pool: Array\u0026lt;Any?\u0026gt; private var poolSize = 0 init { require(maxPoolSize \u0026gt; 0) { \u0026#34;The max pool size must be \u0026gt; 0\u0026#34; } pool = arrayOfNulls(maxPoolSize) } override fun acquire(): T? { if (poolSize \u0026gt; 0) { val lastPooledIndex = poolSize - 1 @Suppress(\u0026#34;UNCHECKED_CAST\u0026#34;) val instance = pool[lastPooledIndex] as T pool[lastPooledIndex] = null poolSize-- return instance } return null } override fun release(instance: T): Boolean { check(!isInPool(instance)) { \u0026#34;Already in the pool!\u0026#34; } if (poolSize \u0026lt; pool.size) { pool[poolSize] = instance poolSize++ return true } return false } private fun isInPool(instance: T): Boolean { for (i in 0 until poolSize) { if (pool[i] === instance) { return true } } return false } } /** * Synchronized pool of objects. * * @param maxPoolSize The maximum pool size * @param T The pooled type. */ open class SynchronizedPool\u0026lt;T : Any\u0026gt;(maxPoolSize: Int) : SimplePool\u0026lt;T\u0026gt;(maxPoolSize) { private val lock = Any() override fun acquire(): T? { synchronized(lock) { return super.acquire() } } override fun release(instance: T): Boolean { synchronized(lock) { return super.release(instance) } } } } 很明显这是一个对象池，SimplePool继承自Pool，并且可以指定对象池的大小。每次要回收的时候调用release，只有当前size小于对象池最大容量的时候才能回收，每次通过acquire来进行获取对象池中的元素。 其中在recyclerview动画篇章中，分析到InfoRecord对象中会使用Pools. SimplePool，InfoRecord存储的是ViewHolder在pre-layout阶段的坐标信息和post-layout阶段的坐标信息，以及ViewHolder的flag信息。因为ViewHolder的这些信息在动画处理过程中会频繁使用，所以此处使用了对象池来管理。\njava中类加载机制 首先通过class的name查看有没有加载过，如果没有加载过，看自己的父类加载器是否存在，如果存在，则通过父类加载的loadClass去加载，如果不存在则说明当前类加载器是BootstrapClassLoader加载器，则通过BootstrapClassLoader去加载，如果还没有找到则通过自己的findClass去加载。整体过程理解为先让父类加载器去加载class，如果找不到则自己去加载。 类加载器分类： BootstrapClassLoader：最顶层的类加载器，它用来加载JAVA_HOME/jre/lib/rt.jar中的类 ExtClassLoader：扩展类加载器，它用来加载JAVA_HOME/jre/lib/ext目录下的所有jar中的类，它的父加载器是BootstrapClassLoader，继承自URLClassLoader AppClassLoader：应用类加载器，它用来加载应用的类，也就是ClassPath，它的父加载器是ExtClassLoader，继承自URLClassLoader 自定义ClassLoader：用户实现，任意路径（如网络、文件），可以通过继承自ClassLoader或者是URLClassLoader 类加载器采用双亲委托模式来加载class，主要是为了系统的class的安全，优先使用系统的class来加载。 双清委托模式的核心代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 protected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded Class\u0026lt;?\u0026gt; c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0) sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } ``` ### android中类加载机制 1. android类加载机制也是按照双亲委托模型，但是可以通过自定义类加载器绕过双亲委派，实现类的隔离或复用 2. 类加载器分类： 1. BootClassLoader：系统类加载器，加载框架层的核心类（如 android.*、java.* 等系统类） 2. PathClassLoader：应用类加载器，加载已安装 APK 中的类（即应用自身的类和 classes.dex），它的父类加载器是BootClassLoader，继承自BaseDexClassLoader，用于加载 /data/app/\u0026lt;package\u0026gt;/base.apk 中的代码，无法加载外部存储的dex、jar文件 3. DexClassLoader：动态加载器，动态加载外部存储的 DEX/JAR 文件或 APK（如插件化、热修复场景），父加载器通常是PathClassLoader，也是继承自BaseDexClassLoader 4. 上面提到android类加载也是通过双亲委托模式来加载类，但是安卓加载类是通过解析dex文件来加载的，所以对于PathClassLoader和DexClassLoader都是通过dex来加载class的，对于BootClassLoader，它仍然通过加载系统核心的DEX文件来实现类的加载，只不过这个过程是由虚拟机在底层直接处理的，不需要通过BaseDexClassLoader的DexPathList和DexFile机制。这种设计可能是为了优化系统启动速度和核心类的访问效率。 5. BaseDexClassLoader完成了整个dex转换成class的过程，首先理解几个概念， `DexPathList` ， `DexFile` ， `Element` : 1. DexPathList：被BaseDexClassLoader持有 2. Element：被DexPathList持有，内部持有一个Element的数组 3. DexFile：被Element持有 4. DexPathList通过传入的dexPath，然后通过`;`或`:`进行split，得到List\u0026lt;File\u0026gt;： ```java //DexPathList.splitPaths private static List\u0026lt;File\u0026gt; splitPaths(String searchPath, boolean directoriesOnly) { List\u0026lt;File\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (searchPath != null) { for (String path : searchPath.split(File.pathSeparator)) { //省略代码 result.add(new File(path)); } } return result; } //DexPathList.makeDexElements private static Element[] makeDexElements(List\u0026lt;File\u0026gt; files, File optimizedDirectory, List\u0026lt;IOException\u0026gt; suppressedExceptions, ClassLoader loader) { Element[] elements = new Element[files.size()]; int elementsPos = 0; for (File file : files) { if (file.isDirectory()) { elements[elementsPos++] = new Element(file); } else if (file.isFile()) { String name = file.getName(); if (name.endsWith(DEX_SUFFIX)) { DexFile dex = loadDexFile(file, optimizedDirectory, loader, elements); elements[elementsPos++] = new Element(dex, null); } else { DexFile dex = loadDexFile(file, optimizedDirectory, loader, elements); if (dex == null) { elements[elementsPos++] = new Element(file); } else { elements[elementsPos++] = new Element(dex, file); } } } else { System.logW(\u0026#34;ClassLoader referenced unknown path: \u0026#34; + file); } } if (elementsPos != elements.length) { elements = Arrays.copyOf(elements, elementsPos); } return elements; } //DexPathList.loadDexFile private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader,Element[] elements) throws IOException { if (optimizedDirectory == null) { return new DexFile(file, loader, elements); } else { String optimizedPath = optimizedPathFor(file, optimizedDirectory); return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements); } } ``` 从上面可以看出来，DexPathList里面会先split出dexPath，然后通过路径生成optimizedPath的路径，通过该路径生成DexFile对象，它就是表示一个dex文件。然后把DexFile塞入到Element数组中，最后该Element数组关联到BaseDexClassLoader中。 5. 接着看下如果通过dex加载到class，该处理是在BaseDexClassLoader中的findClass： ```java //BaseDexClassLoader.findClass protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException { List\u0026lt;Throwable\u0026gt; suppressedExceptions = new ArrayList\u0026lt;Throwable\u0026gt;(); Class c = pathList.findClass(name, suppressedExceptions); if (c == null) { ClassNotFoundException cnfe = new ClassNotFoundException( \u0026#34;Didn\u0026#39;t find class \\\u0026#34;\u0026#34; + name + \u0026#34;\\\u0026#34; on path: \u0026#34; + pathList); for (Throwable t : suppressedExceptions) { cnfe.addSuppressed(t); } throw cnfe; } return c; } //DexPathList.findClass public Class\u0026lt;?\u0026gt; findClass(String name, List\u0026lt;Throwable\u0026gt; suppressed) { for (Element element : dexElements) { Class\u0026lt;?\u0026gt; clazz = element.findClass(name, definingContext, suppressed); if (clazz != null) { return clazz; } } if (dexElementsSuppressedExceptions != null) { suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); } return null; } //Element.findClass public Class\u0026lt;?\u0026gt; findClass(String name, ClassLoader definingContext, List\u0026lt;Throwable\u0026gt; suppressed) { return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed) : null; } //DexFile.loadClassBinaryName public Class loadClassBinaryName(String name, ClassLoader loader, List\u0026lt;Throwable\u0026gt; suppressed) { return defineClass(name, loader, mCookie, this, suppressed); } //DexFile.defineClass private static Class defineClass(String name, ClassLoader loader, Object cookie, DexFile dexFile, List\u0026lt;Throwable\u0026gt; suppressed) { Class result = null; try { result = defineClassNative(name, loader, cookie, dexFile); } catch (NoClassDefFoundError e) { if (suppressed != null) { suppressed.add(e); } } catch (ClassNotFoundException e) { if (suppressed != null) { suppressed.add(e); } } return result; } //DexFile中的native方法 private static native Class defineClassNative(String name, ClassLoader loader, Object cookie,DexFile dexFile) throws ClassNotFoundException, NoClassDefFoundError; ``` 从上面可以看到BaseDexClassLoader最终是通过DexPathList-\u0026gt;Element-\u0026gt;DexFile-\u0026gt;native来加载到class ### android中Choreographer工作内容（android 29） * 当某个view发起绘制（requestLayout或invalidate）的时候，会调用到ViewRootImpl的scheduleTraversals，该方法里面会给主线程的looper中的消息队列插入了一条消息屏障，接着给Choreographer插入了一条CALLBACK_TRAVERSAL类型的callback： ```java void scheduleTraversals() { //如果没有发起绘制，才会往下走 if (!mTraversalScheduled) { mTraversalScheduled = true; //给主线程的looper中的消息队列插入了一条消息屏障 mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); //给Choreographer插入了一条CALLBACK_TRAVERSAL类型的callback mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) { scheduleConsumeBatchedInput(); } notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); } } 最终会走到Choreographer的scheduleFrameLocked，默认会走USE_VSYNC，并且默认该线程的looper是主线程的looper，走到如下逻辑，会走到scheduleVsyncLocked，最终会走到DisplayEventReceiver的native方法nativeScheduleVsync，表示监听底层的vsync信号，当vsync信号来的时候会回调onVsync方法，该方法会给主线程发送一条异步消息到消息队列中： 1 2 3 4 5 6 7 8 9 10 //timestampNanos：VSync脉冲的时间戳 //frame：帧号码，自增 @Override public void onVsync(long timestampNanos, long physicalDisplayId, int frame) { mTimestampNanos = timestampNanos; mFrame = frame; Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS); } 可以看到onVsync中将自己（FrameDisplayEventReceiver）发送到任务队列中，并且执行时间是timestampNanos，说明该任务是要等到vsync信号指定的时间才会执行，它是一个runnable对象，到了执行该任务的时候会执行它的run方法，run方法会执行doFrame，任务队列是执行完上一个任务才会执行下一个任务，所以如果前面的任务一直阻塞着，doFrame其实不会在timestampNanos时间到了的时候，会立马执行的，看下doFrame处理逻辑： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 void doFrame(long frameTimeNanos, int frame) { final long startNanos; synchronized (mLock) { //期望的时间 long intendedFrameTimeNanos = frameTimeNanos; startNanos = System.nanoTime(); //当前时间-期望时间=延迟时间 final long jitterNanos = startNanos - frameTimeNanos; //延迟时间如果大于一帧所需要的时间 if (jitterNanos \u0026gt;= mFrameIntervalNanos) { final long skippedFrames = jitterNanos / mFrameIntervalNanos; //如果延迟执行的时间大于30帧的时间则给出提示 if (skippedFrames \u0026gt;= SKIPPED_FRAME_WARNING_LIMIT) { Log.i(TAG, \u0026#34;Skipped \u0026#34; + skippedFrames + \u0026#34; frames! \u0026#34; + \u0026#34;The application may be doing too much work on its main thread.\u0026#34;); } final long lastFrameOffset = jitterNanos % mFrameIntervalNanos; //重新计算vsync信号来的时间 frameTimeNanos = startNanos - lastFrameOffset; } //如果期望的时间比上一帧的时间还小，则说明上一帧还没结束，所以当前帧不处理，直接监听下一个vsync信号 if (frameTimeNanos \u0026lt; mLastFrameTimeNanos) { scheduleVsyncLocked(); return; } mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos); mFrameScheduled = false; //给上一帧的时间附上标记 mLastFrameTimeNanos = frameTimeNanos; } try { Trace.traceBegin(Trace.TRACE_TAG_VIEW, \u0026#34;Choreographer#doFrame\u0026#34;); AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS); mFrameInfo.markInputHandlingStart(); //处理input类型的callback doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); mFrameInfo.markAnimationsStart(); //处理animation类型的callback doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos); mFrameInfo.markPerformTraversalsStart(); //处理traversal类型的callback doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); //处理commit类型的callback doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); } finally { AnimationUtils.unlockAnimationClock(); Trace.traceEnd(Trace.TRACE_TAG_VIEW); } } doFrame主要是先看当前时间和期望的时间进行比较，得到延迟时间，如果该时间大于一帧所需要的时间（60hz刷新率的设备，那么一帧的时间是1000/60=16ms），并且该时间大于30帧的时间时候给出提示，这个时间跟view绘制的anr时间差不多。如果期望的时间比上一帧的时间还小，则说明上一帧还没结束，所以当前帧不处理，直接监听下一个vsync信号。接着就是处理各种callback（input、animation、traversal、commit）。而开头view发起绘制的时候，会插入一条traversal类型的callback，所以会执行到view的绘制流程。\n当view发起绘制的时候，不会立马执行，而是先给Choreographer插入一条traversal类型的callback，同时让Choreographer监听下一个vsync信号的到来，当vsync信号来的时候，会给主线程的消息队列发送一条异步消息，当处理该消息的时候校验是否有掉帧处理，如果有掉30帧的时候，会给出提示，最后处理各种类型的callback。 vsync信号的作用 VSync（垂直同步）在安卓屏幕刷新中的作用主要是协调屏幕刷新与图像渲染，避免画面撕裂并提升显示流畅度。具体作用如下： 防止画面撕裂 当屏幕刷新与图像渲染不同步时，可能出现画面撕裂。VSync通过同步两者的频率，确保屏幕在完整刷新一帧后再显示下一帧，从而避免这一问题。 提升流畅度 VSync确保帧率与屏幕刷新率一致，减少帧率波动，使动画和滚动更加平滑。 优化性能 VSync通过控制渲染节奏，避免GPU过度渲染，减少资源浪费，提升系统效率。 双缓冲与三缓冲 VSync常与双缓冲或三缓冲结合使用。双缓冲通过交替使用前后缓冲区减少等待时间，而三缓冲进一步减少卡顿，提升性能。 减少延迟 虽然VSync可能增加少量延迟，但通过合理使用双缓冲或三缓冲，可以在保证流畅度的同时尽量降低延迟。 总结来说，VSync通过同步屏幕刷新与图像渲染，防止画面撕裂、提升流畅度、优化性能，并减少延迟。 消息队列中的消息屏障 消息屏障主要是不处理屏障后面的同步消息，优先处理异步消息，实现原理是消息屏障本身是一个没有持有handler的消息，在获取消息的时候，如果发现队列头部是一个消息屏障，则不获取后面的同步消息，只获取后面的异步消息，一般作用于优先级比较高的场景，比如view的绘制流程。当处理完异步消息后，需要移除掉该消息屏障。 android中异常处理 首先理解下java中线程异常机制，如果线程中发生异常了，没有进行try-catch默认会抛给 defaultUncaughtExceptionHandler 的uncaughtException，而android中启动进程后会在RuntimeInit的commonInit方法中给主线程设置上defaultUncaughtExceptionHandler，对应的是KillApplicationHandler，在它的uncaughtException方法中先收集日志，然后kill掉进程。如果有设置线程的uncaughtExceptionHandler，那么此时java异常机制是就不走defaultUncaughtExceptionHandler了，所以不会走KillApplicationHandler，如果没有设置uncaughtExceptionHandler，而通过Thread.uncaughtExceptionHandler.uncaughtException(Exception)的时候，其实是先获取到线程的ThreadGroup，而在ThreadGroup中的uncaughtException中先看parent有没有，如果没有则也是回调到defaultUncaughtExceptionHandler中。\n关于多张bitmap转成webp的原理 首先得理解webp是基于VP8/VP8L/VP9视频编码技术，支持有损压缩、无损压缩、透明度和动画。其内部格式基于RIFF（Resource Interchange File Format）文件结构，类似于WAV或AVI的容器格式。webp文件以RIFF头部开始，整体结构如下：\n1 RIFF {FileSize} WEBP {Chunks...} RIFF：固定 4 字节标识符。 FileSize：4 字节，表示文件总大小（包括 RIFF 头部和 WEBP 标签）。 WEBP：固定 4 字节标识符，表明文件类型。 其中RIFF、FileSize、WEBP这三个归为header部分，chunks归为块部分。其中块可以分为如下部分： VP8/VP8L/VP9 图像数据块： VP8：用于有损压缩图像（类似 JPEG），块标识符为 VP8 （注意末尾空格）。 VP8L：用于无损压缩图像（类似 PNG），块标识符为 VP8L。 VP9：用于更高效的压缩（较少见），块标识符为 VP9 。 VP8X（扩展元数据块）： 标识符为 VP8X，用于存储扩展信息（如宽度、高度、动画标志、Alpha 通道等）。 必须出现在其他块之前（除 RIFF 和 WEBP 外）。 包含以下标志位： 动画（Animation） Alpha 通道（Alpha） EXIF 元数据 XMP 元数据 ICC 颜色配置文件 ANIM（动画控制块）： 标识符为 ANIM，仅用于动画 WebP。 包含背景颜色和循环次数。 ANMF（动画帧块）： 标识符为 ANMF，每个动画帧对应一个 ANMF 块。 包含帧的位置、时间延迟、宽度、高度等。 了解文件结构后，下面来介绍如何将多个bitmap生成webp： 首先将bitmap压缩成webp格式的图片，按照50的压缩比，放到字节输入流中 读取webp的header部分 读取RIFF部分 读取文件大小 读取WEBP部分 读取第一个带有playload的chunk块 由于前面指定了bitmap转webp的时候是有损，因此读取chunk的时候直接去读WP8块，接着读取它的payload信息，playload大小就是chunk大小，4字节。 读取完后，接着就是写入到输出流中，判断如果是第一个bitmap，则创建header部分，其中header也是按照RIFF、FileSize、WEBP三个区域写回，接着写入VP8X数据块，标明宽高、动画、通道、元数据等信息。接着创建ANIM动画控制块，标明背景颜色和循环次数。最后创建每一个bitmap对应的ANMF动画帧块，将指定每一帧的的尺寸、时长playload数据。 kotlin中 == 和 === 区别 kotlin中的==：如果是对象类型，比较的是equals方法；如果是基本类型，比较的是值。 kotlin中的===：如果是对象类型，比较的是内存地址，指向的是不是同一个对象；如果是基本类型。比较的还是值。\nkotlin中lazy的原理 Lazy本身是一个接口，会提供一个value属性和isInitialized的方法，注意了在kotlin接口中提供属性，其实对应java中的get**方法，平时写的by lazy{}，去定义一个属性的时候，其实它是一种属性委托的写法，但是lazy它是只读的委托模式，所以在定义属性的时候必须用val来修饰变量。当我们去读取lazy的变量的时候，实际是调用了前面定义的value属性，对应java代码其实是getValue方法，当首次去获取属性的时候，发现_value为空，所以会通过闭包去获取，获取到后会将返回值给到_value，下次再调用getValue的时候，直接返回该_value。\n1 public actual fun \u0026lt;T\u0026gt; lazy(lock: Any?, initializer: () -\u0026gt; T): Lazy\u0026lt;T\u0026gt; = SynchronizedLazyImpl(initializer, lock) 第一个参数lock是可以传入对象锁 第二个参数是传进来的闭包，是非空 返回值：实际是一个SynchronizedLazyImpl对象： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private class SynchronizedLazyImpl\u0026lt;out T\u0026gt;(initializer: () -\u0026gt; T, lock: Any? = null) : Lazy\u0026lt;T\u0026gt;, Serializable { private var initializer: (() -\u0026gt; T)? = initializer //使用Volatile关键字修饰_value变量，在多线程下能达到可见性的效果 @Volatile private var _value: Any? = UNINITIALIZED_VALUE // final field is required to enable safe publication of constructed instance private val lock = lock ?: this//如果传进来的对象锁为空，则当前对象作为锁 override val value: T get() { val _v1 = _value if (_v1 !== UNINITIALIZED_VALUE) { @Suppress(\u0026#34;UNCHECKED_CAST\u0026#34;) return _v1 as T } //通过synchronized来保证创建对象是原子操作 return synchronized(lock) { val _v2 = _value if (_v2 !== UNINITIALIZED_VALUE) { @Suppress(\u0026#34;UNCHECKED_CAST\u0026#34;) (_v2 as T) } else { val typedValue = initializer!!() _value = typedValue initializer = null typedValue } } } } 综上来看，lazy默认是线程安全的，默认使用的对象锁是当前lazy对象，也可以自己传入锁对象。使用Volatile来保证对象的可见性，通过synchronized保证创建对象是原子操作。\nkotlin委托模式 属性委托：允许你把属性的getter、setter逻辑委托给一个独立的对象来管理 通过「var 属性 by 委托类」的形式定义一个属性委托的过程，当使用var的时候，说明该属性能可读和可写，在属性写的时候实际编译器会去调委托类的setValue方法，当属性读的时候实际编译器会去调委托类的getValue方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class Delegate { operator fun getValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;): String { return \u0026#34;属性 ${property.name} 被代理了\u0026#34; } operator fun setValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;, value: String) { println(\u0026#34;属性 ${property.name} 赋值为 $value\u0026#34;) } } class Example { var message: String by Delegate() } fun main() { val e = Example() println(e.message) // 访问时调用 getValue() e.message = \u0026#34;Hello\u0026#34; // 赋值时调用 setValue() } ``` 实际对应的字节码： ```java class Example { private val message$delegate = Delegate() // 委托对象变为一个私有属性 var message: String get() = message$delegate.getValue(this, ::message) set(value) = message$delegate.setValue(this, ::message, value) } ``` - by Delegate() 其实是 Kotlin 编译器生成的 get() 和 set() 方法。 - getValue() 和 setValue() 由 Delegate 这个委托对象实现。 + 类委托：允许一个类 将实现某个接口的功能委托给另一个对象，减少代码重复。 - by 关键字 可以让 Kotlin 自动生成委托方法，避免手写重复代码 ```java interface Printer { fun printMessage() } class RealPrinter : Printer { override fun printMessage() { println(\u0026#34;RealPrinter: 打印内容\u0026#34;) } } class ProxyPrinter(printer: Printer) : Printer by printer fun main() { val realPrinter = RealPrinter() val proxy = ProxyPrinter(realPrinter) proxy.printMessage() // 调用的是 realPrinter 的方法 } ``` 上面的ProxyPrinter被编译器编译为如下： ```java class ProxyPrinter(printer: Printer) : Printer { private val printerDelegate: Printer = printer override fun printMessage() { printerDelegate.printMessage() } } ``` - by printer 让 ProxyPrinter 自动实现 Printer 接口的方法，而不需要手动实现。 - 编译器在字节码层面会自动插入代理方法，提高代码简洁性。 ### 为什么reified必须和inline一起使用？ reified关键字是用来修饰泛型，而泛型在编译后会被擦除掉，所以如果要在运行时获取到泛型的类型，就得用reified关键字，而inline的作用是修饰方法内联，之前讲内联函数的特点是将函数体平铺到调用处。那它两有什么联系呢？先来看一个例子： ![alt text](获取泛型的class类型.png) 此处提示我，使用reified关键字来修饰泛型，因为泛型在编译后，会被擦除掉，所以是获取不到它的类型，只有添加reified才能保证它的类型存在。那添加完reified后提示为什么还要添加inline呢？\u0026lt;/br\u0026gt; 这是因为只有内联函数将函数体进行平铺，然后将泛型通过「真类型」代入到函数体中，看下编译后的代码： ![alt text](reified编译前和编译后对比.png) ### 关于viewModel的一些思考 * 创建：默认都是通过ViewModelProvider的get方法获取到viewModel，里面通过factory（工厂方法模式）的create来创建viewModel，创建完之后会把viewModel保存到ViewModelStore中。ViewModelStore实际是用一个hashMap来存储viewModel，key是viewModel的class name拼上前缀，value就是当前viewModel。android中默认的factory是ViewModelProvider. AndroidViewModelFactory，在它的create方法里面通过前面传进来的viewModel的class反射创建viewModel。 * 存储：像平时写的activity都是继承自`ComponentActivity`，它是实现了`ViewModelStoreOwner`接口，该接口需要持有一个ViewModelStore，ViewModelStore是在ensureViewModelStore方法中创建的： ```java void ensureViewModelStore() { if (mViewModelStore == null) { NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) { // Restore the ViewModelStore from NonConfigurationInstances mViewModelStore = nc.viewModelStore; } if (mViewModelStore == null) { mViewModelStore = new ViewModelStore(); } } } getLastNonConfigurationInstance()方法是获取Activity中的mLastNonConfigurationInstances属性的activity属性，结构如下：\n1 2 3 4 5 6 7 static final class NonConfigurationInstances { Object activity; HashMap\u0026lt;String, Object\u0026gt; children; FragmentManagerNonConfig fragments; ArrayMap\u0026lt;String, LoaderManager\u0026gt; loaders; VoiceInteractor voiceInteractor; } 第一次打开activity的时候mLastNonConfigurationInstances属性是空的，因此在ensureViewModelStore中是直接创建了ViewModelStore。那什么时候mLastNonConfigurationInstances不为空呢？我们注意到mLastNonConfigurationInstances是在activity的attach中赋值的，它的上级来源是ActivityClientRecord中的lastNonConfigurationInstances属性，那什么时候给ActivityClientRecord的lastNonConfigurationInstances属性赋值呢？这个可以在aosp中的 frameworks/base/core/java/android/app/Activity.java 类中的performDestroyActivity方法中找到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void performDestroyActivity(ActivityClientRecord r, boolean finishing, boolean getNonConfigInstance, String reason) { Class\u0026lt;? extends Activity\u0026gt; activityClass; if (getNonConfigInstance) { try { //通过调用activity的retainNonConfigurationInstances方法来给ActivityClientRecord的lastNonConfigurationInstances属性赋值 r.lastNonConfigurationInstances = r.activity.retainNonConfigurationInstances(); } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException(\u0026#34;Unable to retain activity \u0026#34; + r.intent.getComponent().toShortString() + \u0026#34;: \u0026#34; + e.toString(), e); } } } } 而activity的retainNonConfigurationInstances方法中会组装NonConfigurationInstances中的activity属性，是通过onRetainNonConfigurationInstance方法来收集的：\n1 2 3 4 5 6 NonConfigurationInstances retainNonConfigurationInstances() { Object activity = onRetainNonConfigurationInstance(); NonConfigurationInstances nci = new NonConfigurationInstances(); nci.activity = activity;//手机activity属性 return nci; } onRetainNonConfigurationInstance方法的调用是在 ComponentActivity 中实现了：\n1 2 3 4 5 6 7 8 9 @Override @Nullable @SuppressWarnings(\u0026#34;deprecation\u0026#34;) public final Object onRetainNonConfigurationInstance() { ViewModelStore viewModelStore = mViewModelStore; NonConfigurationInstances nci = new NonConfigurationInstances(); nci.viewModelStore = viewModelStore; return nci; } 可以看到最终viewModelStore通过ComponentActivity中的NonConfigurationInstances存储起来了，最终被ActivityClientRecord持有。当横竖屏切换的时候会触发ActivityThread的handleRelaunchActivity，在该方法里面会先将activity的lastNonConfigurationInstances保存到ActivityClientRecord，等到创建activity的时候会把lastNonConfigurationInstances给到activity，所以viewmodelStore此时拿到的还是之前的。\nfragment中的viewModel是怎么存储的？ fragment也是实现了viewModelOwner接口，所以它也有自己的viewModelStore，它的viewModelStore是通过FragmentManagerViewModel来管理的，FragmentManagerViewModel的创建是看当前fragment有没有parentFragment，如果有，则通过parentFragment的fragmentManager的getChildNonConfig方法来获取。如果parent为空，则通过activity的viewModelStore来创建。所以fragment的viewModelStore存储也是依赖于activity，因为最终该FragmentManagerViewModel是通过activity的viewModelStore来存储的。 LiveData的一些思考 liveData是基于监听lifecycle生命周期的数据驱动框架，在lifecycle为STARTED才会触发触发数据驱动，并且在lifecycle为DESTROYED的时候自动解绑observer。 比如我在lifecycle的CREATED状态给livedata灌数据，等到lifecycle状态为STARTED的时候就会给livedata的observer给发送数据。 当提前给livedata灌输数据的时候，但是此时还没添加observer，等到添加observer的时候，会自动把数据分发到observer中了。这个就是数据倒灌。主要是因为给livedata发送数据的时候，livedata中的版本号会+1，但是新添加的observer此时的版本号还是-1，所以在注册的时候，会把数据分发给observer。通常数据倒灌的解决方案是： 每次在添加observer的时候，反射将livedata中的版本号给置为0 重写livedata，然后添加一个已经注册的标记(AtomicBoolean)，第一次调用observe的时候才会给该标记置为非空。此时在发送数据的时候判断如果该标记不为空，才会置为true，在observe的地方通过包装一个observer，只有该标记置为true了，才会给到目标observer传递数据。（这种方案只适合添加单observer的场景，如果多observer就不适合了） 继承livedata，用一个map记录observer是否接收过消息，如果接收过了就不能再接收 livedata中的getVersion方法是包内可见的，因此我们可以新建和livedata同样的包名的类，这样就能访问getVersion方法，然后在observe方法中判断如果version\u0026gt;START_VERSION才会能消费事件 livedata中setValue是同步方法，是线程不安全的。postValue在一个线程的时候，如果发送数据比较频繁的时候，只会把最后一个数据发送给observer，因为postValue是通过给主线程的消息队列发送数据，然后发送给observer。在多线程情况下虽然设置数据是加了同步块，但是因为还是给主线程的消息队列发送消息来切换线程，导致前面的数据会被后面的数据给覆盖。 glide缓存 glide缓存分为内存和硬盘两类，其中内存缓存又分为活跃缓存和LRU缓存，硬盘缓存分为解码后按照view尺寸展示的bitmap缓存，另外一部分是原始图片的缓存。 活跃缓存：它的结构是一个hashmap，其中key是按照url、尺寸等信息拼成的，value是一个弱引用对象，其中弱引用中放的才是图片缓存对象。 LRU缓存：它底层是一个LRU策略的缓存，key也是和上面活跃缓存用的是同一个。value存的是解码后的图片缓存。 解码后的硬盘缓存：也是使用的LRU策略的缓存，其中key是按照指定尺寸来构建的，然后从DiskLruCache中获取缓存。 原始图片的硬盘缓存：也是使用的LRU策略的缓存，其中key不是通过指定尺寸来构建的，然后也是从DiskLruCache中获取缓存。 缓存获取步骤： LRU的内存缓存是在什么存储的？ 从上面流程图来看每次从非活跃缓存中获取到图片缓存后，都会放入到活跃缓存中，那什么时候会放到内存的LRU缓存中呢？当view触发onViewDetachedFromWindow的时候，也就是当前view销毁后，会查看当前view绑定的图片被正在使用标记的次数，如果次数为0了，则将当前图片加入到LRU的内存缓存中。 glide为什么要设计两层的内存缓存？ 内存缓存分为活跃的缓存，它是一个map数据结构，value存储的是弱引用包装了缓存数据，另外一层是LRU级别的缓存。活跃数据指的是当前正在使用的资源，比如正在显示的图片，这部分用弱引用来保存，这样当图片不再被使用时，垃圾回收器可以自动回收，避免内存泄漏。而LRU缓存则是最近最少使用的缓存，使用强引用，当内存不足时，会移除最久未使用的资源。 如果只有LRU缓存的时候，正在使用的图片可能是长时间没有被访问的图片，而此时如果只有LRU缓存的时候，可能会把正在使用的图片缓存给移除掉了，这样的话，当再使用该图片的时候，会从磁盘中去获取该图片，这样增大了获取图片的时间。如果只有弱引用缓存的时候，此时图片不被使用了，被GC给回收了，那此时也只能从磁盘中获取，增大了获取图片的时间。如果此时有LRU缓存，能在内存中保留一段时间，降低从磁盘中读取的可能。 kotlin中Sequence和普通集合的区别 Sequence原理是持有了原有集合的iterator，在等到调用toList的时候，才会拿到Sequence的iterator进行遍历，然后添加到新的集合中。中间的操作符都会生成一个新的sequence，然后每遍历一个元素都会去执行一次中间操作符的iterator的next方法，然后将结果给到下一个sequence，最后添加到新的集合中。 优点：相较于普通的集合，它是惰性执行中间操作符，并且中间的操作符只是通过iterator进行迭代每一个元素，而普通的集合是每一个操作符会新生成一个集合，导致内存会增高。Sequence的使用场景是中间操作符比较多的情况下进行使用，不会增加新的集合，并且是惰性遍历元素。 比如下面这个操作：\n1 2 3 4 5 6 7 8 9 10 11 listOf(1, 2, 3, 4, 5) .asSequence() .map { println(\u0026#34;sequence map:$it\u0026#34;) it * 2 } .filter { println(\u0026#34;sequence filter:$it\u0026#34;) it \u0026gt; 5 } .toList() 在调用toList时候，才会执行上面的map和filter方法，并且map和filter遍历元素的时候，是每个元素依次调用到map和filter，中间是通过sequence的iterator进行遍历，不会产生中间的集合。 日志如下：\n1 2 3 4 5 6 7 8 9 10 sequence map:1 sequence filter:2 sequence map:2 sequence filter:4 sequence map:3 sequence filter:6 sequence map:4 sequence filter:8 sequence map:5 sequence filter:10 再来看下普通集合的操作：\n1 2 3 4 5 6 7 listOf(1, 2, 3, 4, 5).map { println(\u0026#34;list map:$it\u0026#34;) it * 2 }.filter { println(\u0026#34;list filter:$it\u0026#34;) it \u0026gt; 5 } 上面的map和filter是分开执行的，不会等到最后才执行，所以没有惰性，map和filter都会产生新的集合，并且在遍历元素的时候，每一个操作符是先遍历完每一个元素，然后才执行下一个操作符的遍历。 日志如下：\n1 2 3 4 5 6 7 8 9 10 list map:1 list map:2 list map:3 list map:4 list map:5 list filter:2 list filter:4 list filter:6 list filter:8 list filter:10 kotlin中Sequence和集合的Stream区别 Stream是java1.8之后出的语法，和Sequence一样支持流式和惰性的特点，它在遍历元素的时候也是每个元素都会按顺序经过中间的操作符，不像普通的集合那样每个元素必须先执行完一个操作符，然后才进行下一个操作符。但是Stream只能一次性消费，消费完后，就不能再使用该stream。而Sequence可以多次使用。同时Stream的parallelStream方法支持并发处理，遍历元素的时候，不是按照元素会顺序执行每一个操作符，当数据量大的时候可以考虑使用parallelStream。\ncompanion object和object中定义变量 在companion object定义非const变量的时候，会在Companion内部类中提供get方法，在外部类中定义该常量：\n1 2 3 4 5 class Test { companion object{ val name=\u0026#34;张三\u0026#34; } } 生成的class代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public final class Test { @NotNull private static final String name = \u0026#34;张三\u0026#34;; @NotNull public static final Companion Companion = new Companion((DefaultConstructorMarker)null); public static final class Companion { @NotNull public final String getName() { return Test.name; } private Companion() { } // $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } } } 如果kotlin代码如下：\n1 2 3 4 5 class Test { companion object{ const val name=\u0026#34;张三\u0026#34; } } 对应class代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public final class Test { @NotNull public static final String name = \u0026#34;张三\u0026#34;; @NotNull public static final Companion Companion = new Companion((DefaultConstructorMarker)null); public static final class Companion { private Companion() { } // $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } } } 在有const的时候，不会在Companion内部类中提供get方法。只会在外部类提供公开类型的常量。 如果在object类中定义const变量，如下：\n1 2 3 object Test { const val name=\u0026#34;张三\u0026#34; } 会生成如下class：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public final class Test { @NotNull public static final String name = \u0026#34;张三\u0026#34;; @NotNull public static final Test INSTANCE; private Test() { } static { Test var0 = new Test(); INSTANCE = var0; } } 如果去掉const会生成如下class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public final class Test { @NotNull private static final String name; @NotNull public static final Test INSTANCE; @NotNull public final String getName() { return name; } private Test() { } static { Test var0 = new Test(); INSTANCE = var0; name = \u0026#34;张三\u0026#34;; } } 从上面伴生对象和object类发现伴生对象会生成内部类，并通过饿汉式生成单例。object是在内加载的时候生成单例。\n记录一次gradle编译问题 问题：在添加某个广告sdk后，发现工程中编译会报错，报错信息如下： Caused by: org.jetbrains.kotlin.gradle.tasks. CompilationErrorException: Compilation error. See log for more details \u0026lsquo;onNewIntent\u0026rsquo; overrides nothing 该问题说activity的子类（kotlin类）中出现了onNewIntent方法中的intent参数定义可为空了，就增加了一个广告的sdk后，怎么就提示intent要定义成不为空的呢。既然是广告sdk导致的，那么下面就按照依赖关系把问题找到，执行gradle的命令如下： 1 ./gradlew app:dependencies --configuration debugRuntimeClasspath \u0026gt; dependencies.txt 上面命令会找到app依赖的所有module的间接依赖，并输出到文件中，直接看新增的广告sdk的module信息：\n1 +--- androidx.activity:activity-ktx:1.7.1 -\u0026gt; 1.9.2 (*) 可以看到，在广告sdk中会把activity-ktx的版本从1.7.1升级到1.9.2，继续顺藤摸瓜，发现在1.9.2的版本中 ComponentActivity ，会给onNewIntent方法的intent参数加上了 @Suppress(\u0026quot;InvalidNullabilityOverride\u0026quot;) 注解，而在1.7.1版本中是加上 @SuppressLint({\u0026quot;UnknownNullness\u0026quot;, \u0026quot;MissingNullability\u0026quot;}) 注解。通过Gemini对比两者的区别，最终得出结论：\n@Suppress(\u0026ldquo;InvalidNullabilityOverride\u0026rdquo;) 如果一个 Java 方法的参数是 String param，Kotlin 编译器可能无法确定它是可空 (String?) 还是非空 (String)。如果你将其重写为 param: String?（可空），但 Kotlin 编译器内部推断它应该是 String（非空），或者反之，就会触发 InvalidNullabilityOverride 警告。 @SuppressLint({\u0026quot;UnknownNullness\u0026quot;, \u0026quot;MissingNullability\u0026quot;}) 它是lint中的注解，用于抑制 Lint 工具发出的特定警告或错误。UnknownNullness：当 Lint 工具无法确定某个变量、参数或返回类型的空安全性时（通常是因为它来自没有空安全注解的 Java 代码或第三方库），它会发出此警告，提醒你其空安全性是未知的。MissingNullability：当 Lint 认为某个地方应该有空安全注解（@NonNull 或 @Nullable），但却缺失了时，它会发出此警告。这通常发生在你在编写 Java 代码，但没有为参数或返回类型明确添加空安全注解时。 目的： 告诉 Lint 工具：“我已经意识到这里存在空安全注解缺失或未知空安全性的问题，但我有理由不添加注解或接受当前状态，请不要再警告我。” 从上面分析可知，而activity中的onNewIntent方法中确实没有任何非空和可空的注解，在1.7.1版本中通过lint注解来告诉lint，这里的intent参数是不可确定的空参数，不需要发出警告。而在1.9.2版本中强制要求子类中必须为非空的，因此当之前的子类是可空的时候，就会出现前面所说的编译问题 方案：直接在添加广告sdk的地方，排除掉activity-ktx的依赖： 1 exclude group: \u0026#34;androidx.activity\u0026#34;, module: \u0026#34;activity-ktx\u0026#34; kotlin协程中的withTimeoutOrNull作用 场景adb中命令 通过包名查看pid adb shell pidof 包名 返回进程的id，通过该id后面可以做很多事情 adb shell cat /proc/pid/stat 获取App cpu使用时间 3541 (进程名) S 906 906 0 0 -1 1077952832 801953 19794 170 1 195874 29787 16 55 10 -10 247 0 76295047 29784014848 99929 18446744073709551615 1 1 0 0 0 0 4612 1 1073775868 0 0 0 17 4 0 0 3 0 0 0 0 0 0 0 0 0 0 上面的14-17部分是我们关心的数据 195874：utime（进程的用户态时间） 29787：stime（进程的内核态时间） 16：cutime（子进程的用户态时间） 55：cstime（子进程的内核态时间） 把这几个加起来就可以得到当前App总CPU使用时间 快速查看某个应用的activity栈的情况 adb shell dumpsys activity activities | grep Hist | grep 包名 阿里云域名如何关联github page 首先来到 云解析DNS/公网权威解析模块 ，然后找到购买的域名，进入到解析设置的tab，选择 添加记录 ，添加两项信息：\n其中此处的 `185.199.108.153` 是github默认的ip地址 Class.isAssignableFrom() 判断当前class是不是参数中class的父类类型或当前类型，比如Drawable.class.isAssignableFrom(BitmapDrawable.class)返回为true。\nurl转uri 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private static Uri parseUri(String model) { Uri uri; if (TextUtils.isEmpty(model)) { return null; // See https://pmd.github.io/pmd-6.0.0/pmd_rules_java_performance.html#simplifystartswith } else if (model.charAt(0) == \u0026#39;/\u0026#39;) { uri = toFileUri(model); } else { uri = Uri.parse(model); String scheme = uri.getScheme(); if (scheme == null) { uri = toFileUri(model); } } return uri; } private static Uri toFileUri(String path) { return Uri.fromFile(new File(path)); } Math相关方法 Math.ceil: 向上取整，比如6.1向上取整得到7 Math.floor: 向下取整，比如6.7向下取整得到6 Math.round: 四舍五入计算取整 ","date":"2024-11-04T00:00:00Z","permalink":"http://xiangcman.xyz/p/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/","title":"笔记整理"},{"content":"协程创建 demo 1 2 3 4 5 6 7 8 9 10 11 12 suspend { Log.d(TAG, \u0026#34;suspend block:\u0026#34;) \u0026#34;123\u0026#34; }.createCoroutine(object : Continuation\u0026lt;String\u0026gt; { override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result\u0026lt;String\u0026gt;) { val value = result.getOrNull() Log.d(TAG, \u0026#34;resumeWith:$value\u0026#34;) } }).resume(Unit) Log.d(TAG, \u0026#34;onCreate\u0026#34;) 上面日志先打印suspend中的代码块，然后执行Continuation的resumeWith，最后执行主线程的代码。\ncreateCoroutine 是挂起函数的扩展方法，方法参数是Continuation类型，对应上面的匿名内部类。创建了一个SafeContinuation对象，它也是一个Continuation类型，并传递两个参数。\nresume resume方法会调用resumeWith，看下SafeContinuation的resumeWith方法： 此处提醒下，kotlin的源码需要到对应的** Jvm类下找，要不然方法只是一个申明。此处的result是构造SafeContinuation传递进来的COROUTINE_SUSPENDED，因此会执行delegate.resumeWith(result)，此处的delegate是createCoroutineUnintercepted(completion).intercepted()创建的。\ncreateCoroutineUnintercepted 它是挂起函数的扩展方法：\n判断当前挂起函数是不是BaseContinuationImpl类型，如果是则调用create方法。\n此时可以打开字节码，看下上面的(suspend () -\u0026gt; T)是什么对象？\n可以看到createCoroutine方法传入了两个参数，我们都知道扩展函数最终编译出来的方法第一个参数是被扩展对象，所以此处的CoroutineActivity$onCreate$1就是(suspend () -\u0026gt; T)，CoroutineActivity$onCreate$2对应的是例子中的Continuation匿名内部类。我们注意下，此时传入CoroutineActivity$onCreate$1中的Continuation参数是null。\n而SuspendLambda的继承关系如下：\n所以会调用挂起函数的create方法：\n父类中要求子类必须重写该方法，我们看CoroutineActivity$onCreate$1的create方法：\n此时重新new了一个CoroutineActivity$onCreate$1，并把completion传入其中，而此处的completion就是上面的CoroutineActivity$onCreate$2，它是一个Continuation。而开端在分析createCoroutine的时候，创建CoroutineActivity$onCreate$1传入的Continuation是null。\n不太明白，为什么不在createCoroutine时候直接直接把CoroutineActivity$onCreate$2传入到CoroutineActivity$onCreate$1中，而非要通过create方法再创建一个CoroutineActivity$onCreate$1。\n我们再来看intercepted方法。\nintercepted 是Continueation的扩展方法，当然了，刚刚create创建的CoroutineActivity$onCreate$1是一个suspendLambda对象，所以它也是ContinueationImpl，所以会走ContinueationImpl的intercepted方法：\n此处看context中有没有ContinuationInterceptor类型的Element，如果没有则返回自己，我们只要知道先返回自己。因为这个涉及到context的结构，后面再讲。\n小节： ①、createCoroutine创建了一个SafeContinuation，并把CoroutineActivity$onCreate$1和一个标志位COROUTINE_SUSPENDED传入其中。CoroutineActivity$onCreate$1继承自SuspendLambda，并且是一个Function接口的实例。SuspendLambda继承自ContinuationImpl，ContinuationImpl继承自BaseContinuationImpl，BaseContinuationImpl继承自Continuation，CoroutineActivity$onCreate$1继承自SuspendLambda，也就是上面的协成要执行的闭包。CoroutineActivity$onCreate$1持有了CoroutineActivity$onCreate$2，它实现了Continuation。CoroutineActivity$onCreate$1重写了create方法，返回了一个新的CoroutineActivity$onCreate$1对象。 ②、resume方法中会调用到SafeContinuation的resumeWith方法，最终会触发CoroutineActivity$onCreate$1的resumeWith方法。\n协程执行 CoroutineActivity$onCreate$1继承自SuspendLambda，最终会继承自BaseContinuationImpl，来看下它的resumeWith：\nresumeWith中首先调用invokeSuspend方法，如果invokeSuspend方法返回COROUTINE_SUSPENDED，则resumeWith直接不往下执行。否则看comppletion是不是BaseContinuationImpl，是的话，则继续轮训，直到comppletion不是BaseContinuationImpl，则执行它的resumeWith方法。此处的completion实际是CoroutineActivity$onCreate$2，所以会执行它的resumeWith方法。我们看下CoroutineActivity$onCreate$1的invokeSuspend方法：\n它的返回值不是COROUTINE_SUSPENDED，所有上面的invokeSuspend方法还会继续往下执行。所以最终会执行了CoroutineActivity$onCreate$2，也就是例子中的匿名内部类的resumeWith方法。\n此时我们再分析例子中日志的打印：\n可以看到执行SafeContinuation的resumeWith的时候是一个while(true)，传入的this.resume是一个COROUTINE_SUSPENDED标志位，所以会把CoroutineActivity$onCreate$1的resumeWith执行完后，才跳出while循环。因此日志最后输出协成外的代码。\n总结 过程 协程分为创建和执行，在创建过程中首先会创建一个SuspendLambda的子类，但是该子类它的completion(Continuation)是空的，然后在createCoroutineUnintercepted方法中会调用到该SuspendLambda的子类的create方法，在create方法里面会再次创建一个SuspendLambda的子类，此时SuspendLambda的子类中completion(Continuation)是非空的，指向了createCoroutine方法传入的Continuation内部类。接着来到了执行阶段，执行是调用了SuspendLambda的子类的resume方法，它会执行resumeWith方法。在resumeWith中会调用到invokeSuspend方法，而invokeSuspend中的代码实际是suspend代码块中的代码，所以suspend代码块中的代码最先执行。执行完invokeSuspend后会执行completion的resumeWith方法，所以createCoroutine方法传入的Continuation内部类的resumeWith被执行。而为什么主线程在最后才执行呢？这是因为在创建协程的时候实际包装了一个SafeContinuation对象，在它的resumeWith里面会启动while(true)循环，等到执行完deletate(也就是SuspendLambda的子类)的resumeWith后才会退出while(true)循环，所以最后才会执行主线程后面的代码。\n类图 最后输出此次的类图结构，以作回顾：\n","date":"2024-11-02T00:00:00Z","image":"http://xiangcman.xyz/p/android-%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%88%B0%E6%89%A7%E8%A1%8C/cover_hu_7c81ba7442e02e1a.jpg","permalink":"http://xiangcman.xyz/p/android-%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%88%B0%E6%89%A7%E8%A1%8C/","title":"Android 协程启动到执行"},{"content":"Bytecode-viewer 一款查看class文件的工具\n使用： 目录定位到该jar包下面，然后使用如下命令：\njava -jar Bytecode-Viewer-2.12.jar\nsh脚本执行文件： Bytecode-Viewer.sh\n脚本文件：\nBytecode-Viewer-2.12.jar\n来源:https://github.com/Konloch/bytecode-viewer\nRectangle窗口大小调整 Rectangle是一个在mac上动态调整应用窗口的工具，比如我想在屏幕上同时展示多个应用，这个工具使用上非常好用。 Rectangle下载 Alfred工具 Alfred是一款在mac上全局搜索的工具，能指定搜索文件、文件夹、应用的一款工具。 建议你在设置中将要搜索的文件类型给勾选住： 关于更多使用看官网，我的快捷键是双击command： 动画差值器 在线预览：https://inloop.github.io/interpolator/\nVsCode编辑器 插件列表 PlantUML：对于写md的文件，比较不错 Peacock：一款能动态修改工作区的颜色，这样就能知道当前是哪个项目 Paste Image：能快速在项目目录复制图片，并粘贴到文档中 One Dark Pro：一款不错的Color Theme的主题插件 Material Icon Theme：一款不错的File Icon Theme(文件样式)的主题插件 Material Product Icons：一款不错的左边栏的功能按钮的样式主题 markdownlint：markdown语法的检测插件 Markdown All in One：写markdown语法高亮、快捷设置、快速生成目录的插件 indent-rainbow：代码可视化缩进工具 CodeSnap：拖动文件中文字，能快速生成代码格式的图片 Markdown Preview Enhanced：markdown预览插件，支持自定义样式进行预览 mac上快速拷贝文件 按住option键，然后鼠标右键点击，会出现\u0026quot;将**拷贝为文件路径\u0026quot;，然后选中它就拷贝路径了。\n","date":"2024-11-02T00:00:00Z","permalink":"http://xiangcman.xyz/p/%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/","title":"工具整理"},{"content":" Context相关源码是在android33的版本上分析的。\n类图 Context创建 Activity继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，当activity创建的之前，会先创建ContextImpl，我们可以在ActivityThread.performLaunchActivity中找到ContextImpl的创建：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); appContext.setOuterContext(activity); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.activityConfigCallback, r.assistToken, r.shareableActivityToken); return activity; } 通过createBaseContextForActivity方法创建了ContextImpl：\n接着会调用contextImpl的setOuterContext，传入的是activity。\n结论：contextImpl中的outerContext指向了activity。\nContext传递 在activity中的attach调用了attachBaseContext，并把contextImpl传进去了：\n该方法是ContextWrapper中的方法，并指向了mBase变量。Activity中getBaseContext和getApplicationContext区别：\ngetBaseContext指向了刚刚attach方法传进来的contextImpl。\n指向了mBase.getApplicationContext：\nmPackageInfo是在创建contextImpl的时候传入的，它是loadedApk对象，它的getApplication方法是获取应用的Application对象：\n结论：getBaseContext获取的是contextImpl对象，getApplicationContext获取的是Application对象。\n主题设置 回到performLaunchActivity，给activity设置主题：\n将theme的resid传进来，最终会把resid这个theme追加到mTheme上。这里牵扯到资源加载，后面再说。\nLayoutInflater中的context LayoutInflater.from(context)： 此处的context一般是activity，看activity.getSystemService方法，activity是继承自ContextThemeWrapper，所以会调用ContextThemeWrapper的getSystemService：\n如果name是LAYOUT_INFLATER_SERVICE，则通过LayoutInflater.from(getBaseContext()).cloneInContext(this)来创建，上面分析过activity中的getBaseContext()是指向了contextImpl对象，所以兜兜转转，最终调用了contextImpl中的getSystemService来获取LayoutInflater对象。\n那如果from传进来的不是Activity，而是application会怎么样呢？application它是继承自ContextWrapper：\nbase是contextImpl，最终调用的是contextImpl的getSystemService，activity亦是如此：\n从SYSTEM_SERVICE_FETCHERS中获取：\n最终是在此处添加了一个PhoneLayoutInflater对象，并把contextImpl.getOuterContext传进去了，此处传进去的是Activity或者是application对象。 如果from中传入的是activity，在contextThemeWrapper的getSystemService方法中获取到PhoneLayoutInflater后，又调用了cloneInContext，将当前的context传入其中： 此处为什么要通过cloneInContext构造一个新的PhoneLayoutInflater呢？ 在上面分析PhoneLayoutInflater创建的时候，是通过SystemServiceRegistry的SYSTEM_SERVICE_FETCHERS中map获取的，而在传入PhoneLayoutInflater的context是通过ContextImpl的getOuterContext方法来获取的，上面分析过ContextImpl的outerContext可能是Activity，也可能是Application，比如在A这个Activity中创建了PhoneLayoutInflater，而在B这个Activity中获取PhoneLayoutInflater的时候，如果没有cloneInContext，那么获取还是A这个activity中的PhoneLayoutInflater，而layoutinflater解析xml是强依赖于context，所以为了确保当前activity创建的layoutinflater使用的是当前context，所以将当前的context传入其中构造一个新的layoutinflater。\nlayoutInflater.inflate: 此过程调用createViewFromTag来创建view：\n此处看view有没有theme属性，有的话，则构造一个contextThemeWrapper出来，举个例子：\n此处定义了一个theme属性，那么给该view的构造器传入的context就是一个contextThemeWrapper对象。所以view的context不一定是activity的context，如果设置了theme属性，那么就是一个contextThemeWrapper的context。\n再来看一个例子，创建创建layoutinflater的时候指定contextThemeWrapper对象： 在from方法里面，传入一个contextthemewrapper对象，并携带一个style。根据上面分析from方法时，contextthemewrapper是通过LayoutInflater.from(getBaseContext()).cloneInContext(this)。此处的getBaseContext()又是activity，又因为activity.getSystemService，调用base.getSystemService，所以最终又回到了contextimpl.getSystemService。而在创建PhoneLayoutInflater的时候，又通过contextimpl.getOuterContext传入到PhoneLayoutInflater构造器中，但是在contextthemewrapper中最后又调了PhoneLayoutInflater的cloneInContext：\n所以此种情况下，最终给view传的context也是一个contextthemewrapper的context。\nAttr部分 从主题中获取属性：\n最终这些属性是通过context的obtainStyledAttributes获取属性值。常见的方法是：\nAttributeSet表示所有的属性集，它是在inflate过程中解析到view的属性集。 attrs表示的是要从哪个属性集中取到属性。 例如：\nattrs文件中定义一个declare-styleable属性集，aapt工具会生成对应的R.class，但是此时是一个R.jar文件：\n该文件在app/build/intermediates/compile_and_runtime_not_namespaced_r_class_jar/debug/R.jar，反编译该jar文件：\n最终所有的资源类型都会生成一个R$**.class的类，而R.class其实是一个空壳：\n看刚才定义的declare-styleable生成如下：\n并且会在R$attr.class下面也会生成一个两个int值：\n生成了一个R$styleable.TestView的数组和两个int值，分别是R$styleable.TestView_attr1和R$styleable.TestView_attr2，它两分别代表TestView数组的索引，而对应的值是定义在resource.arsc文件中：\n所以最终得出结论是：通过context.obtainStyledAttributes传入attrbuteset和attrs数组，得到了typearray，然后通过typearray的索引得到所有的属性：\ndefStyleAttr、defStyleRes 新增一个不在declare-styleable数组中的attr11，见R文件：\n在R$styleable类中没有attr11的定义，它在R$attr类中定义了：\n在上面属性中attr7和attr11是引用类型的，他们可以指向另外一个引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public class TestView1 extends View { public TestView1(Context context) { this(context, null); } public TestView1(Context context, @Nullable AttributeSet attrs) { this(context, attrs, R.attr.attr11); } public TestView1(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { this(context, attrs, defStyleAttr, R.style.DefStyleRes); } public TestView1(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context, attrs, defStyleAttr, defStyleRes); TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.gui, defStyleAttr, defStyleRes); log(\u0026#34;TypedArray length：\u0026#34; + ta.length()); for (int i = 0; i \u0026lt; ta.length(); i++) { int attrIndex = ta.getIndex(i); switch (attrIndex) { case R.styleable.gui_attr1: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr2: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr3: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr4: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr5: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr6: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr7: log(ta.getString(attrIndex)); break; default: break; } } ta.recycle(); } private void log(String msg) { Log.v(getClass().getSimpleName(), \u0026#34;\u0026#34; + msg); } } TestView1中defStyleAttr传入R.attr.attr11，defStyleRes传入R.style.DefStyleRes。 布局文件如下：\n其中theme中引用了attr11的引用，而themestyle中引用了attr1-attr4，DefStyleRes中也引用了attr1-attr4。日志如下：\nR.styleable.gui总共长度是7，attr1用的xml中定义的，attr2是布局中定义的style中的属性，attr3和attr4取的是theme中attr11定义的attr3和attr4，由于attr5没有在attr11中的style中定义，所以取的是theme中的attr5属性。 优先级：布局中的attr\u0026gt;布局中的style中的attr\u0026gt;defStyleAttr中的attr\u0026gt;theme中的attr 此时无论怎么在DefStyleRes中定义属性，都不会在该style里面的attr取值，因为此时定义了defStyleAttr 此时如果去掉defStyleAttr，则会在DefStyleRes中取值：\n结果如下：\n总结：defStyleAttr定义了后，defStyleRes中的attr就不起作用了。\n参考：https://blog.csdn.net/GracefulGuigui/article/details/104069265\n","date":"2024-10-25T00:00:00Z","permalink":"http://xiangcman.xyz/p/android-context%E6%80%BB%E7%BB%93/","title":"Android context总结"}]