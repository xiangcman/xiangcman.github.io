[{"content":" 在讲协程的如何切换线程之前，有必要先了解下协程的上下文是什么？它的结构是什么样的？以及我们如何使用它？今天带着该问题来认识它。\nCoroutineContext 协程上下文都是继承自CoroutineContext，它是一个接口，内部方法以及内部类如下：\n它的实现子类有如下：\n比如我们常见的EmptyCoroutineContext，它的内部实现如下：\n可以看到它的get、fold、plus、minusKey几个方法都是默认实现，你可以理解它就是个空壳子的context。\nElement 在讲CoroutineContext内部结构之前，先来认识下Element，它也实现了CoroutineContext接口：\nElement中有一个key的属性，这里可以理解key就是当前Element的唯一标识。实现一个context的时候需要指明它的key是啥，此处就是用该key来标识 get：如果传进来的key和自己的key相等，则返回自己，否则返回null fold：将初始值和当前element返回给lambda，让lambda自己去处理 minusKey：如果传进来的key和自己相同，则返回EmptyCoroutineContext，否则返回自己，其实是删除对应key的context.\n写了3个context，然后用\u0026quot;+\u0026ldquo;拼接：\n自定义context的时候，需要继承自AbstractCoroutineContextElement，它是继承自Element，因为它强制要求需要一个key作为context的标识，一般key的element标识是当前context，看上面的One这个context，它的key拥有的element是One。\n输出日志如下：\nOne()+Two()+Three()得到的是一个CombinedContext，get方法通过One这个key取到了One这个取对应的Context\n日志如下： 可以看到我给One的context拼接了一个EmptyCoroutineContext时候，得到的是它自己，\u0026quot;+\u0026ldquo;是重载了context的plus方法，看下plus方法的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public operator fun plus(context: CoroutineContext): CoroutineContext = //① if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation //② context.fold(this) { acc, element -\u0026gt; //③ val removed = acc.minusKey(element.key) //③.1 if (removed === EmptyCoroutineContext) element else { // make sure interceptor is always last in the context (and thus is fast to get when present) //④ val interceptor = removed[ContinuationInterceptor] //⑤ if (interceptor == null) CombinedContext(removed, element) else { //⑥ val left = removed.minusKey(ContinuationInterceptor) //⑦ if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else //⑧ CombinedContext(CombinedContext(left, element), interceptor) } } } 1.如果传进来的context是EmptyCoroutineContext，则返回自己，所以上面的One()+EmptyCoroutineContext，得到的是One这个context 2.context.fold，会把初始值和context传给闭包，所以acc是当前context，element是传进来的context 3.acc.minuskey(element.key)，如果传进来的context的key和当前context的key相等，则返回传进来的context，所以新的context会把旧的context给覆盖掉了 4.如果传进来的context的key和当前context的key不相等，removed则是当前context，查看当前context中是否有ContinuationInterceptor类型的context，我们的dispatcher都是属于该类型，需要单独处理 5.如果context中没有ContinuationInterceptor类型的context，则初始化出一个CombinedContext的context，所以上面的One()+Two()+Three()是一个CombinedContext的context 6.如果当前context中存在ContinuationInterceptor类型的context，则继续判断当前context是不是ContinuationInterceptor类型的context 7.如果是ContinuationInterceptor类型的context，则把传进来的context和当前的context组合成CombinedContext的context 8.如果当前的context不是一个ContinuationInterceptor类型的context，则把当前当前的context和传进来的context新组合成一个CombinedContext的context，再和前面的ContinuationInterceptor组合成一个新的CombinedContext的context\nCombinedContext 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 internal class CombinedContext( private val left: CoroutineContext, private val element: Element ) : CoroutineContext, Serializable { override fun \u0026lt;E : Element\u0026gt; get(key: Key\u0026lt;E\u0026gt;): E? { var cur = this while (true) { cur.element[key]?.let { return it } val next = cur.left if (next is CombinedContext) { cur = next } else { return next[key] } } } public override fun \u0026lt;R\u0026gt; fold(initial: R, operation: (R, Element) -\u0026gt; R): R = operation(left.fold(initial, operation), element) public override fun minusKey(key: Key\u0026lt;*\u0026gt;): CoroutineContext { //① element[key]?.let { return left } //② val newLeft = left.minusKey(key) return when { //③ newLeft === left -\u0026gt; this //④ newLeft === EmptyCoroutineContext -\u0026gt; element //⑤ else -\u0026gt; CombinedContext(newLeft, element) } } override fun toString(): String = \u0026#34;[\u0026#34; + fold(\u0026#34;\u0026#34;) { acc, element -\u0026gt; if (acc.isEmpty()) element.toString() else \u0026#34;$acc, $element\u0026#34; } + \u0026#34;]\u0026#34; } 它是直接继承自CoroutineContext，有两个比较重要的属性：\nleft：CoroutineContext，它是左边的节点\nelement：Element，当前节点\n其实和链表的结构有点类似，left相当于next节点。\nget：递归节点，直到left节点不是CombinedContext类型的\nfold：先把left和初始值组成一个初始值，然后再把这个初始值和当前节点传给闭包\nminusKey：\n1.如果当前节点中找到了该key，则返回left节点\n2.如果找不到，则继续在left节点中找\n3.如果找不到返回this\n4.如果找到了则返回当前节点\n5.否则继续往左边再找\n整个分析来看，协程中的context如果是多个context拼接的时候如果传进来的是EmptyCoroutineContext，则只保存自己。如果传进来的context的key和当前context的key一样，则会覆盖掉原来的context。如果都不满足，则采用链表的形式插入到原来的context头节点上，如果传进来的是ContinuationInterceptor类型的，则会把该类型放到头节点。\n类图 再来一张本次讲解的context类图：\n","date":"2024-11-04T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87/","title":"协程上下文"},{"content":"协程创建 demo 1 2 3 4 5 6 7 8 9 10 11 12 suspend { Log.d(TAG, \u0026#34;suspend block:\u0026#34;) \u0026#34;123\u0026#34; }.createCoroutine(object : Continuation\u0026lt;String\u0026gt; { override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result\u0026lt;String\u0026gt;) { val value = result.getOrNull() Log.d(TAG, \u0026#34;resumeWith:$value\u0026#34;) } }).resume(Unit) Log.d(TAG, \u0026#34;onCreate\u0026#34;) 上面日志先打印suspend中的代码块，然后执行Continuation的resumeWith，最后执行主线程的代码。\ncreateCoroutine 是挂起函数的扩展方法，方法参数是Continuation类型，对应上面的匿名内部类。创建了一个SafeContinuation对象，它也是一个Continuation类型，并传递两个参数。\nresume resume方法会调用resumeWith，看下SafeContinuation的resumeWith方法： 此处提醒下，kotlin的源码需要到对应的** Jvm类下找，要不然方法只是一个申明。此处的result是构造SafeContinuation传递进来的COROUTINE_SUSPENDED，因此会执行delegate.resumeWith(result)，此处的delegate是createCoroutineUnintercepted(completion).intercepted()创建的。\ncreateCoroutineUnintercepted 它是挂起函数的扩展方法：\n判断当前挂起函数是不是BaseContinuationImpl类型，如果是则调用create方法。\n此时可以打开字节码，看下上面的(suspend () -\u0026gt; T)是什么对象？\n可以看到createCoroutine方法传入了两个参数，我们都知道扩展函数最终编译出来的方法第一个参数是被扩展对象，所以此处的CoroutineActivity$onCreate$1就是(suspend () -\u0026gt; T)，CoroutineActivity$onCreate$2对应的是例子中的Continuation匿名内部类。我们注意下，此时传入CoroutineActivity$onCreate$1中的Continuation参数是null。\n而SuspendLambda的继承关系如下：\n所以会调用挂起函数的create方法：\n父类中要求子类必须重写该方法，我们看CoroutineActivity$onCreate$1的create方法：\n此时重新new了一个CoroutineActivity$onCreate$1，并把completion传入其中，而此处的completion就是上面的CoroutineActivity$onCreate$2，它是一个Continuation。而开端在分析createCoroutine的时候，创建CoroutineActivity$onCreate$1传入的Continuation是null。\n不太明白，为什么不在createCoroutine时候直接直接把CoroutineActivity$onCreate$2传入到CoroutineActivity$onCreate$1中，而非要通过create方法再创建一个CoroutineActivity$onCreate$1。\n我们再来看intercepted方法。\nintercepted 是Continueation的扩展方法，当然了，刚刚create创建的CoroutineActivity$onCreate$1是一个suspendLambda对象，所以它也是ContinueationImpl，所以会走ContinueationImpl的intercepted方法：\n此处看context中有没有ContinuationInterceptor类型的Element，如果没有则返回自己，我们只要知道先返回自己。因为这个涉及到context的结构，后面再讲。\n小节： ①、createCoroutine创建了一个SafeContinuation，并把CoroutineActivity$onCreate$1和一个标志位COROUTINE_SUSPENDED传入其中。CoroutineActivity$onCreate$1继承自SuspendLambda，并且是一个Function接口的实例。SuspendLambda继承自ContinuationImpl，ContinuationImpl继承自BaseContinuationImpl，BaseContinuationImpl继承自Continuation，CoroutineActivity$onCreate$1继承自SuspendLambda，也就是上面的协成要执行的闭包。CoroutineActivity$onCreate$1持有了CoroutineActivity$onCreate$2，它实现了Continuation。CoroutineActivity$onCreate$1重写了create方法，返回了一个新的CoroutineActivity$onCreate$1对象。 ②、resume方法中会调用到SafeContinuation的resumeWith方法，最终会触发CoroutineActivity$onCreate$1的resumeWith方法。\n协程执行 CoroutineActivity$onCreate$1继承自SuspendLambda，最终会继承自BaseContinuationImpl，来看下它的resumeWith：\nresumeWith中首先调用invokeSuspend方法，如果invokeSuspend方法返回COROUTINE_SUSPENDED，则resumeWith直接不往下执行。否则看comppletion是不是BaseContinuationImpl，是的话，则继续轮训，直到comppletion不是BaseContinuationImpl，则执行它的resumeWith方法。此处的completion实际是CoroutineActivity$onCreate$2，所以会执行它的resumeWith方法。我们看下CoroutineActivity$onCreate$1的invokeSuspend方法：\n它的返回值不是COROUTINE_SUSPENDED，所有上面的invokeSuspend方法还会继续往下执行。所以最终会执行了CoroutineActivity$onCreate$2，也就是例子中的匿名内部类的resumeWith方法。\n此时我们再分析例子中日志的打印：\n可以看到执行SafeContinuation的resumeWith的时候是一个while(true)，传入的this.resume是一个COROUTINE_SUSPENDED标志位，所以会把CoroutineActivity$onCreate$1的resumeWith执行完后，才跳出while循环。因此日志最后输出协成外的代码。\n类图总结 最后输出此次的类图结构，以作回顾：\n","date":"2024-11-02T00:00:00Z","permalink":"https://example.com/p/android-%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%88%B0%E6%89%A7%E8%A1%8C/","title":"Android 协程启动到执行"},{"content":"Bytecode-viewer 一款查看class文件的工具\n使用： 目录定位到该jar包下面，然后使用如下命令：\njava -jar Bytecode-Viewer-2.12.jar\nsh脚本执行文件： Bytecode-Viewer.sh\n脚本文件：\nBytecode-Viewer-2.12.jar\n来源:https://github.com/Konloch/bytecode-viewer\n动画差值器 在线预览：https://inloop.github.io/interpolator/\n","date":"2024-11-02T00:00:00Z","permalink":"https://example.com/p/%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/","title":"工具整理"},{"content":"类图 Context创建 Activity继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，当activity创建的之前，会先创建contextimpl ActivityThread.performLaunchActivity\n接着会调用contextimpl的setOuterContext，传入的是activity。\n结论：contextImpl中的outerContext指向了activity。\nContext传递 attach调用了attachBaseContext，并把contextimpl传进去了：\n该方法是ContextWrapper中的方法，并指向了mBase变量。Activity中getBaseContext和getApplicationContext区别：\ngetBaseContext指向了刚刚attach方法传进来的contextimpl。\n指向了mBase.getApplicationContext：\nmPackageInfo是在创建contextimpl的时候传入的，它是loadedApk对象，它的getApplication方法是获取应用的Application对象：\n结论：getBaseContext获取的是contextimpl对象，getApplicationContext获取的是Application对象。\n主题设置 回到performLaunchActivity，给activity设置主题：\n将theme的resid传进来，最终会把resid这个theme追加到mTheme上。这里牵扯到资源加载，后面再说。\nLayoutInflater中的context LayoutInflater.from(context)： 此处的context一般是activity，看activity.getSystemService方法，如果传入的不是activity，比如是ContextThemeWrapper，Application会怎么样：\n通过base调用getSystemService，而base其实也是activity。Application是继承自ContextWrapper：\nbase是contextimpl，最终调用的是contextimpl的getSystemService，activity亦是如此：\n从SYSTEM_SERVICE_FETCHERS中获取：\n最终是在此处添加了一个PhoneLayoutInflater对象，并把contextimpl.getOuterContext传进去了，此处传进去的是Activity对象。\nlayoutinflater.inflate: 此过程调用createViewFromTag来创建view：\n此处看view有没有theme属性，有的话，则构造一个contextthemeWrapper出来，举个例子：\n此处定义了一个theme属性，那么给该view的构造器传入的context就是一个contextThemeWrapper对象。\n在from方法里面，传入一个contextthemewrapper对象，并携带一个style。根据上面分析from方法时，contextthemewrapper是通过base.getSystemService。此处的base又是activity，又因为activity.getSystemService，调用base.getSystemService，所以最终又回到了contextimpl.getSystemService。而在创建PhoneLayoutInflater的时候，又通过contextimpl.getOuterContext传入到PhoneLayoutInflater构造器中，但是在contextthemewrapper中最后又调了PhoneLayoutInflater的cloneInContext：\n所以此种情况下，最终给view传的context也是一个contextthemewrapper的context。\nAttr部分 从主题中获取属性：\n最终这些属性是通过context的obtainStyledAttributes获取属性值。常见的方法是：\nAttributeSet表示所有的属性集，它是在inflate过程中解析到view的属性集。 attrs表示的是要从哪个属性集中取到属性。 例如：\nattrs文件中定义一个declare-styleable属性集，aapt工具会生成对应的R.class，但是此时是一个R.jar文件：\n该文件在app/build/intermediates/compile_and_runtime_not_namespaced_r_class_jar/debug/R.jar，反编译该jar文件：\n最终所有的资源类型都会生成一个R$**.class的类，而R.class其实是一个空壳：\n看刚才定义的declare-styleable生成如下：\n并且会在R$attr.class下面也会生成一个两个int值：\n可以看出来生出来一个R.styleable.TestView的数组和两个int值，分别是R.styleable.TestView_attr1和R.styleable.TestView_attr2，它两分别代表TestView数组的索引，而对应的值是定义在resource.arsc文件中：\n所以最终得出结论是：通过context.obtainStyledAttributes传入attrbuteset和attrs数组，得到了typearray，然后通过typearray的索引得到所有的属性：\ndefStyleAttr、defStyleRes 新增一个不在declare-styleable数组中的attr11，见R文件：\n在R.styleable类中没有attr11的定义，它在R.attr类中定义了：\n在上面属性中attr7和attr11是引用类型的，他们可以指向另外一个引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public class TestView1 extends View { public TestView1(Context context) { this(context, null); } public TestView1(Context context, @Nullable AttributeSet attrs) { this(context, attrs, R.attr.attr11); } public TestView1(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { this(context, attrs, defStyleAttr, R.style.DefStyleRes); } public TestView1(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context, attrs, defStyleAttr, defStyleRes); TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.gui, defStyleAttr, defStyleRes); log(\u0026#34;TypedArray length：\u0026#34; + ta.length()); for (int i = 0; i \u0026lt; ta.length(); i++) { int attrIndex = ta.getIndex(i); switch (attrIndex) { case R.styleable.gui_attr1: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr2: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr3: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr4: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr5: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr6: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr7: log(ta.getString(attrIndex)); break; default: break; } } ta.recycle(); } private void log(String msg) { Log.v(getClass().getSimpleName(), \u0026#34;\u0026#34; + msg); } } TestView1中defStyleAttr传入R.attr.attr11，defStyleRes传入R.style.DefStyleRes。 布局文件如下：\n其中theme中引用了attr11的引用，而themestyle中引用了attr1-attr4，DefStyleRes中也引用了attr1-attr4。日志如下：\nR.styleable.gui总共长度是7，attr1用的xml中定义的，attr2是布局中定义的style中的属性，attr3和attr4取的是theme中attr11定义的attr3和attr4，由于attr5没有在attr11中的style中定义，所以取的是theme中的attr5属性。 优先级：布局中的attr\u0026gt;布局中的style中的attr\u0026gt;defStyleAttr中的attr\u0026gt;theme中的attr 此时无论怎么在DefStyleRes中定义属性，都不会在该style里面的attr取值，因为此时定义了defStyleAttr 此时如果去掉defStyleAttr，则会在DefStyleRes中取值：\n结果如下：\n总结：defStyleAttr定义了后，defStyleRes中的attr就不起作用了。\n参考：https://blog.csdn.net/GracefulGuigui/article/details/104069265\n","date":"2024-10-25T00:00:00Z","permalink":"https://example.com/p/android-context%E6%80%BB%E7%BB%93/","title":"Android context总结"}]