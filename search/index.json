[{"content":"之前在了解touch事件的时候，都是从activity-\u0026gt;phoneWindow-\u0026gt;decoreVoew-\u0026gt;content部分的view事件分发，而不知道底层是如何传递给view的，该篇文章就是介绍，底层是如何将事件传递给应用层的。下面先把traceView的截图列出来： 当屏幕收到触摸事件后，底层会给主线程的消息队列中插入一条消息，然后唤醒上层，上层的接收端是NativeInputEventReceriver的handleEvent： 接着调用了consumeEvents方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env, bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) { if (inputEventObj.get()) { if (kDebugDispatchCycle) { ALOGD(\u0026#34;channel \u0026#39;%s\u0026#39; ~ Dispatching input event.\u0026#34;, getInputChannelName().c_str()); } //调用到java层的android/view/InputEventReceiver的dispatchInputEvent方法 env-\u0026gt;CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj.get()); } } int register_android_view_InputEventReceiver(JNIEnv* env) { int res = RegisterMethodsOrDie(env, \u0026#34;android/view/InputEventReceiver\u0026#34;, gMethods, NELEM(gMethods)); //指向了java层的android/view/InputEventReceiver类 jclass clazz = FindClassOrDie(env, \u0026#34;android/view/InputEventReceiver\u0026#34;); gInputEventReceiverClassInfo.clazz = MakeGlobalRefOrDie(env, clazz); gInputEventReceiverClassInfo.dispatchInputEvent = GetMethodIDOrDie(env, gInputEventReceiverClassInfo.clazz, \u0026#34;dispatchInputEvent\u0026#34;, \u0026#34;(ILandroid/view/InputEvent;)V\u0026#34;); gInputEventReceiverClassInfo.onFocusEvent = GetMethodIDOrDie(env, gInputEventReceiverClassInfo.clazz, \u0026#34;onFocusEvent\u0026#34;, \u0026#34;(Z)V\u0026#34;); gInputEventReceiverClassInfo.onPointerCaptureEvent = GetMethodIDOrDie(env, gInputEventReceiverClassInfo.clazz, \u0026#34;onPointerCaptureEvent\u0026#34;, \u0026#34;(Z)V\u0026#34;); gInputEventReceiverClassInfo.onDragEvent = GetMethodIDOrDie(env, gInputEventReceiverClassInfo.clazz, \u0026#34;onDragEvent\u0026#34;, \u0026#34;(ZFF)V\u0026#34;); gInputEventReceiverClassInfo.onTouchModeChanged = GetMethodIDOrDie(env, gInputEventReceiverClassInfo.clazz, \u0026#34;onTouchModeChanged\u0026#34;, \u0026#34;(Z)V\u0026#34;); gInputEventReceiverClassInfo.onBatchedInputEventPending = GetMethodIDOrDie(env, gInputEventReceiverClassInfo.clazz, \u0026#34;onBatchedInputEventPending\u0026#34;, \u0026#34;(I)V\u0026#34;); return res; } 可以看到上面通过register_android_view_InputEventReceiver方法的注册，将gInputEventReceiverClassInfo指向了java层的android/view/InputEventReceiver。而在consumeEvents中通过env-\u0026gt;CallVoidMethod调用jni到了android/view/InputEventReceiver的dispatchInputEvent方法。接下来到了java层，直接看traceview\n1 InputEventReceiver.dispatchInputEvent-\u0026gt;ViewRootImpl$WindowInputEventReceiver.onInputEvent-\u0026gt;ViewRootImpl.enqueueInputEvent-\u0026gt;ViewRootImpl.doProcessInputEvents-\u0026gt;ViewRootImpl.deliverInputEvent-\u0026gt;ViewRootImpl$InputStage.deliver-\u0026gt;ViewRootImpl$InputStage.apply-\u0026gt;deliver-\u0026gt;ViewRootImpl$InputStage.forward-\u0026gt;ViewRootImpl$InputStage.onDeliverToNext....-\u0026gt;ViewPostImeInputStage.onProcess-\u0026gt;ViewPostImeInputStage.processPointerEvent-\u0026gt;View.dispatchPointerEvent-\u0026gt;DecorView.dispatchTouchEvent-\u0026gt;Activity.dispatchTouchEvent-\u0026gt;PhoneWindow.superDispatchTouchEvent-\u0026gt;DecorView.superDispatchTouchEvent-\u0026gt;ViewGroup.dispatchTouchEvent 单击view时候的trace文件\n其实这个只是单次的点击事件，如果是多次触发点击，在viewrootimpl中会通过给Choreographer插入一条CALLBACK_INPUT的事件，这个根源也是在NativeInputEventReceiver的consumeEvents中触发了WindowInputEventReceiver的onBatchedInputEventPending，关键代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env, bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) { if (kDebugDispatchCycle) { ALOGD(\u0026#34;channel \u0026#39;%s\u0026#39; ~ Consuming input events, consumeBatches=%s, frameTime=%\u0026#34; PRId64, getInputChannelName().c_str(), toString(consumeBatches), frameTime); } if (consumeBatches) { mBatchedInputEventPending = false; traceBoolVariable(\u0026#34;mBatchedInputEventPending\u0026#34;, mBatchedInputEventPending); } if (outConsumedBatch) { *outConsumedBatch = false; } ScopedLocalRef\u0026lt;jobject\u0026gt; receiverObj(env, nullptr); bool skipCallbacks = false; for (;;) { uint32_t seq; InputEvent* inputEvent; status_t status = mInputConsumer.consume(\u0026amp;mInputEventFactory, consumeBatches, frameTime, \u0026amp;seq, \u0026amp;inputEvent); if (status == WOULD_BLOCK) { if (!skipCallbacks \u0026amp;\u0026amp; !mBatchedInputEventPending \u0026amp;\u0026amp; mInputConsumer.hasPendingBatch()) { // There is a pending batch. Come back later. if (!receiverObj.get()) { receiverObj.reset(GetReferent(env, mReceiverWeakGlobal)); if (!receiverObj.get()) { ALOGW(\u0026#34;channel \u0026#39;%s\u0026#39; ~ Receiver object was finalized \u0026#34; \u0026#34;without being disposed.\u0026#34;, getInputChannelName().c_str()); return DEAD_OBJECT; } } mBatchedInputEventPending = true; traceBoolVariable(\u0026#34;mBatchedInputEventPending\u0026#34;, mBatchedInputEventPending); if (kDebugDispatchCycle) { ALOGD(\u0026#34;channel \u0026#39;%s\u0026#39; ~ Dispatching batched input event pending notification.\u0026#34;, getInputChannelName().c_str()); } //调用到gInputEventReceiverClassInfo的onBatchedInputEventPending方法 env-\u0026gt;CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.onBatchedInputEventPending, mInputConsumer.getPendingBatchSource()); if (env-\u0026gt;ExceptionCheck()) { ALOGE(\u0026#34;Exception dispatching batched input events.\u0026#34;); mBatchedInputEventPending = false; // try again later traceBoolVariable(\u0026#34;mBatchedInputEventPending\u0026#34;, mBatchedInputEventPending); } } return OK; } } } 最终触发到ConsumeBatchedInputRunnable，最后会执行doProcessInputEvents-\u0026gt;deliverInputEvent\u0026hellip;，也就上单次点击的方法调用。从这里也可以看出，如果触摸事件积累很多的时候，会通过给Choreographer插入一条CALLBACK_INPUT的事件，然后等到下次vsync信号来的时候，才会去处理touch事件，减轻主线程的压力。通过此机制，Android 在保证输入响应的同时，最大限度减少 UI 线程的负载，优化整体流畅性。 多次触摸屏幕的时候trace文件\n","date":"2025-03-24T00:00:00Z","permalink":"https://example.com/p/%E9%80%9A%E8%BF%87traceview%E5%88%86%E6%9E%90touch%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%BA%90%E5%A4%B4%E5%8A%A0%E6%B7%B1touch%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3/","title":"TraceView帮我解决了touch事件的源头"},{"content":"要着手binder分析，我们可以用一个简单的activity跳转逻辑来分析，最好的办法是让intent中携带的数据超过1M的数据，然后通过logcat中异常堆栈来分析：\n1 2 3 4 val intent = Intent(this, BitmapActivity::class.java) val data = ByteArray(1024*1024) intent.putExtra(\u0026#34;data\u0026#34;,data) startActivity(intent) 此处是直接携带1M的数据，然后系统给我来了个异常信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 2025-04-17 20:33:24.613 8782-8782 JavaBinder com.example.coroutinescopedemo E !!! FAILED BINDER TRANSACTION !!! (parcel size = 1049068) --------- beginning of crash 2025-04-17 20:33:24.627 8782-8782 AndroidRuntime com.example.coroutinescopedemo E FATAL EXCEPTION: main Process: com.example.coroutinescopedemo, PID: 8782 java.lang.RuntimeException: Failure from system at android.app.Instrumentation.execStartActivity(Instrumentation.java:1749) at android.app.Activity.startActivityForResult(Activity.java:5533) at androidx.activity.ComponentActivity.startActivityForResult(ComponentActivity.kt:704) at android.app.Activity.startActivityForResult(Activity.java:5486) at androidx.activity.ComponentActivity.startActivityForResult(ComponentActivity.kt:683) at android.app.Activity.startActivity(Activity.java:5892) at android.app.Activity.startActivity(Activity.java:5845) at com.example.coroutinescopedemo.BottomSheetActivity.onCreate$lambda$0(BottomSheetActivity.kt:27) at com.example.coroutinescopedemo.BottomSheetActivity.$r8$lambda$CWhZfDsJCDnJCQuDq0om0F9MZaU(Unknow at com.example.coroutinescopedemo.BottomSheetActivity$$ExternalSyntheticLambda0.onClick(D8$$Synthet at android.view.View.performClick(View.java:7753) at android.view.View.performClickInternal(View.java:7730) at android.view.View.access$3700(View.java:861) at android.view.View$PerformClick.run(View.java:29146) at android.os.Handler.handleCallback(Handler.java:938) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loopOnce(Looper.java:210) at android.os.Looper.loop(Looper.java:299) at android.app.ActivityThread.main(ActivityThread.java:8293) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:556) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1045) Caused by: android.os.TransactionTooLargeException: data parcel size 1049092 bytes at android.os.BinderProxy.transactNative(Native Method) at android.os.BinderProxy.transact(BinderProxy.java:624) at android.app.IActivityTaskManager$Stub$Proxy.startActivity(IActivityTaskManager.java:2664) at android.app.Instrumentation.execStartActivity(Instrumentation.java:1743) at android.app.Activity.startActivityForResult(Activity.java:5533) at androidx.activity.ComponentActivity.startActivityForResult(ComponentActivity.kt:704) at android.app.Activity.startActivityForResult(Activity.java:5486) at androidx.activity.ComponentActivity.startActivityForResult(ComponentActivity.kt:683) at android.app.Activity.startActivity(Activity.java:5892) at android.app.Activity.startActivity(Activity.java:5845) at com.example.coroutinescopedemo.BottomSheetActivity.onCreate$lambda$0(BottomSheetActivity.kt:27) at com.example.coroutinescopedemo.BottomSheetActivity.$r8$lambda$CWhZfDsJCDnJCQuDq0om0F9MZaU(Unknow at com.example.coroutinescopedemo.BottomSheetActivity$$ExternalSyntheticLambda0.onClick(D8$$Synthet at android.view.View.performClick(View.java:7753) at android.view.View.performClickInternal(View.java:7730) at android.view.View.access$3700(View.java:861) at android.view.View$PerformClick.run(View.java:29146) at android.os.Handler.handleCallback(Handler.java:938) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loopOnce(Looper.java:210) at android.os.Looper.loop(Looper.java:299) at android.app.ActivityThread.main(ActivityThread.java:8293) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:556) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1045) 可以看到异常分两块，一块是上面的java.lang.RuntimeException: Failure from system，它是Instrumentation中的execStartActivity抛的异常，最终是因为在android.os.BinderProxy.transactNative(Native Method)中抛了android.os.TransactionTooLargeException: data parcel size 1049092 bytes异常，异常堆栈越是往上面是异常所在点，越往下面是上层代码。当点击按钮的时候屏幕底层会给android应用层发送主线程的消息，然后在消息队列轮训该消息的时候，由于底层抛出异常，在looper轮训消息的时候继续往上层抛，最终该异常会抛给到ZygoteInit。java默认的异常处理机制是交给当前线程的defaultUncaughtExceptionHandler，而RuntimeInit中定义过主线程的defaultUncaughtExceptionHandler，最终该Handler是KillApplicationHandler，在该handler中先收集日志，然后kill掉进程。\n客户端到驱动层 在上面堆栈中，我们直接分析IActivityTaskManager$Stub$Proxy.startActivity方法，其中IActivityTaskManager$Stub$Proxy类是aidl工具帮我们生成的类，它是IActivityTaskManager接口中的一个内部类，它是客户端拿到服务端的binder起始类，它的获取如下：\n1 2 final IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE); return IActivityTaskManager.Stub.asInterface(b); 其中ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE)拿到的是binderProxy对象，它是c++层的BinderProxy对应java层的BinderProxy对象，在IActivityTaskManager.Stub.asInterface中判断如果调用进程和目标进程不是一个的话，会返回Proxy对象，然后调用到Proxy的startActivity方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @Override public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException { Parcel _data = Parcel.obtain(); Parcel _reply = Parcel.obtain(); int _result; try { _data.writeInterfaceToken(DESCRIPTOR); // 验证远程接口 _data.writeStrongBinder(caller != null ? caller.asBinder() : null); _data.writeString(callingPackage); if (intent != null) { _data.writeInt(1); intent.writeToParcel(_data, 0); } else { _data.writeInt(0); } _data.writeString(resolvedType); _data.writeStrongBinder(resultTo); _data.writeString(resultWho); _data.writeInt(requestCode); _data.writeInt(flags); if (profilerInfo != null) { _data.writeInt(1); profilerInfo.writeToParcel(_data, 0); } else { _data.writeInt(0); } if (options != null) { _data.writeInt(1); options.writeToParcel(_data, 0); } else { _data.writeInt(0); } mRemote.transact(Stub.TRANSACTION_startActivity, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); } finally { _reply.recycle(); _data.recycle(); } return _result; } 在该方法里面，会创建两个Parcel对象，一个是_data，一个是_reply。然后将参数都放到_data中，最终调用了mRemote的transact方法，并把_data个_reply传入其中。此处的_remote对象java层的BinderProxy对象，从堆栈上看然后调用了transactNative方法，该方法是一个native方法，对应的aosp中是android_util_Binder.cpp的android_os_BinderProxy_transact方法，可以看如下方法注册：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static const JNINativeMethod gBinderProxyMethods[] = { /* name, signature, funcPtr */ {\u0026#34;pingBinder\u0026#34;, \u0026#34;()Z\u0026#34;, (void*)android_os_BinderProxy_pingBinder}, {\u0026#34;isBinderAlive\u0026#34;, \u0026#34;()Z\u0026#34;, (void*)android_os_BinderProxy_isBinderAlive}, {\u0026#34;getInterfaceDescriptor\u0026#34;, \u0026#34;()Ljava/lang/String;\u0026#34;, (void*)android_os_BinderProxy_getInterfaceDescriptor}, {\u0026#34;transactNative\u0026#34;, \u0026#34;(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z\u0026#34;, (void*)android_os_BinderProxy_transact}, {\u0026#34;linkToDeathNative\u0026#34;, \u0026#34;(Landroid/os/IBinder$DeathRecipient;I)V\u0026#34;, (void*)android_os_BinderProxy_linkToDeath}, {\u0026#34;unlinkToDeathNative\u0026#34;, \u0026#34;(Landroid/os/IBinder$DeathRecipient;I)Z\u0026#34;, (void*)android_os_BinderProxy_unlinkToDeath}, {\u0026#34;addFrozenStateChangeCallbackNative\u0026#34;, \u0026#34;(Landroid/os/IBinder$FrozenStateChangeCallback;)V\u0026#34;, (void*)android_os_BinderProxy_addFrozenStateChangeCallback}, {\u0026#34;removeFrozenStateChangeCallbackNative\u0026#34;, \u0026#34;(Landroid/os/IBinder$FrozenStateChangeCallback;)Z\u0026#34;, (void*)android_os_BinderProxy_removeFrozenStateChangeCallback}, {\u0026#34;getNativeFinalizer\u0026#34;, \u0026#34;()J\u0026#34;, (void*)android_os_BinderProxy_getNativeFinalizer}, {\u0026#34;getExtension\u0026#34;, \u0026#34;()Landroid/os/IBinder;\u0026#34;, (void*)android_os_BinderProxy_getExtension}, }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException { //①、dataObj是java层传过来的发送数据的parcel if (dataObj == NULL) { jniThrowNullPointerException(env, NULL); return JNI_FALSE; } //②、将java层的parcel数据转成native层的parcel Parcel* data = parcelForJavaObject(env, dataObj); if (data == NULL) { return JNI_FALSE; } //③、将java层的reply的parcel数据转成native层的parcel Parcel* reply = parcelForJavaObject(env, replyObj); if (reply == NULL \u0026amp;\u0026amp; replyObj != NULL) { return JNI_FALSE; } //④、通过java层的BinderProxy获取到native层的BpBinder IBinder* target = getBPNativeData(env, obj)-\u0026gt;mObject.get(); if (target == NULL) { jniThrowException(env, \u0026#34;java/lang/IllegalStateException\u0026#34;, \u0026#34;Binder has been finalized!\u0026#34;); return JNI_FALSE; } ALOGV(\u0026#34;Java code calling transact on %p in Java object %p with code %\u0026#34; PRId32 \u0026#34;\\n\u0026#34;, target, obj, code); //⑤、调用native层的BpBinder的transact方法 status_t err = target-\u0026gt;transact(code, *data, reply, flags); if (err == NO_ERROR) { return JNI_TRUE; } //⑥、通过jni调用到java层的Binder的transactionCallback方法 env-\u0026gt;CallStaticVoidMethod(gBinderOffsets.mClass, gBinderOffsets.mTransactionCallback, getpid(), code, flags, err); if (err == UNKNOWN_TRANSACTION) { return JNI_FALSE; } //⑦、输出错误信息 signalExceptionForError(env, obj, err, true /*canThrowRemoteException*/, data-\u0026gt;dataSize()); return JNI_FALSE; } 上面标明了7处的注释，在①处如果传进来的java层的parcel类型的data数据为空，则直接返回失败。在②处将java层的parcel类型的data数据转成native层的parcel数据。在③处将java层的parcel类型的reply数据转成native层的parcel数据。在④处通过java层的BinderProxy获取到native层的BpBinder，主要是通过java层BinderProxy的mNativeData指针(native层BpBinder指针)来获取到native层的BpBinder。在⑤处调用native层的BpBinder的transact方法。在⑥处通过jni调用到java层的Binder的transactionCallback方法。最后在⑦处根据transact的结果输出错误信息。\n着重看下在上面⑤处，看下native层的BpBinder如何处理binder的：\n1 2 3 4 5 6 7 status_t BpBinder::transact( uint32_t code, const Parcel\u0026amp; data, Parcel* reply, uint32_t flags) { status_t status; status = IPCThreadState::self()-\u0026gt;transact(binderHandle(), code, data, reply, flags); return status; } 上面只列出关键代码，IPCThreadState::self()是线程单例，调用到IPCThreadState的transact方法，并且可以看到第一个参数是获取BpBinder的binderHandle方法，它就是获取服务端的binder句柄，通过它告诉驱动层，想要的服务端binder是哪个，下面来看下IPCThreadState的transact方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel\u0026amp; data, Parcel* reply, uint32_t flags) { status_t err; flags |= TF_ACCEPT_FDS; //往驱动层写数据 err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, nullptr); //如果有error就不往下执行 if (err != NO_ERROR) { if (reply) reply-\u0026gt;setError(err); return (mLastError = err); } //如果不是one way的请求方式 if ((flags \u0026amp; TF_ONE_WAY) == 0) { //等待返回结果 if (reply) { err = waitForResponse(reply); } else { Parcel fakeReply; err = waitForResponse(\u0026amp;fakeReply); } } else { //如果是one way，传进去的reply是空的 err = waitForResponse(nullptr, nullptr); } return err; } transact逻辑还是挺清晰的，首先往驱动层写数据，如果有error就不往下执行。如果没问题判断是不是one way的请求方式，如果不是则等待返回结果，如果是one way传进入的reply是null。\nwriteTransactionData是往驱动写数据的方法，看下该方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel\u0026amp; data, status_t* statusBuffer) { //定义驱动层认识的数据结构 binder_transaction_data tr; tr.target.ptr = 0; tr.target.handle = handle; tr.code = code; tr.flags = binderFlags; tr.cookie = 0; tr.sender_pid = 0; tr.sender_euid = 0; //判断发送的数据是否有问题 const status_t err = data.errorCheck(); if (err == NO_ERROR) { //如果没有问题，则往binder_transaction_data中写数据 tr.data_size = data.ipcDataSize(); tr.data.ptr.buffer = data.ipcData(); tr.offsets_size = data.ipcObjectsCount()*sizeof(binder_size_t); tr.data.ptr.offsets = data.ipcObjects(); } else if (statusBuffer) { tr.flags |= TF_STATUS_CODE; *statusBuffer = err; tr.data_size = sizeof(status_t); tr.data.ptr.buffer = reinterpret_cast\u0026lt;uintptr_t\u0026gt;(statusBuffer); tr.offsets_size = 0; tr.data.ptr.offsets = 0; } else { //有问题的话，则返回失败 return (mLastError = err); } //将BC_TRANSACTION和binder_transaction_data写入到mOut这个parcel里面 mOut.writeInt32(cmd); mOut.write(\u0026amp;tr, sizeof(tr)); return NO_ERROR; } 首先定义binder_transaction_data数据结构，然后判断发送的数据是否有问题，如果没有则将data相关的数据给到binder_transaction_data，如果有问题，则返回失败，最后将BC_TRANSACTION和binder_transaction_data写入到mOut这个parcel里面。\n上面通过data.errorCheck()来判断发送的数据是否有问题，下面来看下如何验证的：\n1 2 3 4 status_t Parcel::errorCheck() const { return mError; } 直接返回mError字段，它是在Parcel::continueWrite()方法中赋值的，而continueWrite()方法是在growData()-\u0026gt;writeInplace()-\u0026gt;android_os_Parcel.cpp.android_os_Parcel_write***()方法，最终是java层的Parcel.write***()等方法调用的，关于java层的parcel是如何通过jni调用到android_os_Parcel.cpp主要是因为java层parcel存储了native的parcel指针，它是mNativePtr。 其中关于最大parcel的内存值判断在growData方法中，其中变量SIZE_MAX是64位机器上最大的byte数。如果超过这个值，则返回NO_MEMORY，在continueWrite中会继续判断binder总内存，关于最大内存申请在ProcessState.cpp中调用mmap内存映射的时候，指定了binder的最大内存位BINDER_VM_SIZE = ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2)。 回到上面的IPCThreadState::transact，写完数据后如果发现有问题，则通过android_util_Binder.cpp中的signalExceptionForError抛出异常。接着就是判断如果不是one way的请求方式，则通过waitForResponse等待返回结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult){ uint32_t cmd; while (1) { //往驱动层写东西 talkWithDriver(); cmd = (uint32_t)mIn.readInt32(); switch (cmd) { case BR_TRANSACTION_COMPLETE: break; case BR_REPLY:{ binder_transaction_data tr; err = mIn.read(\u0026amp;tr, sizeof(tr)); reply-\u0026gt;ipcSetDataReference(tr.data.ptr.buffer,tr.data_size); } goto finish; } } return err; } 通过while循环来判断命令，首先每次先通过talkWithDriver往驱动层写东西：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 status_t IPCThreadState::talkWithDriver(bool doReceive) { binder_write_read bwr; const bool needRead = mIn.dataPosition() \u0026gt;= mIn.dataSize(); const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); if (doReceive \u0026amp;\u0026amp; needRead) { bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (uintptr_t)mIn.data(); } else { bwr.read_size = 0; bwr.read_buffer = 0; } ioctl(mProcess-\u0026gt;mDriverFD, BINDER_WRITE_READ, \u0026amp;bwr); return err; } 前面在分析writeTransactionData时候，会把binder_transaction_data数据结构写到oOut这个parcel里面，此处又把mOut中的数据给读到放到binder_write_read数据结构中，如果要读的话，通过mIn这个parcel读取，然后放到binder_write_read数据结构中。最后通过ioctl方法将binder_write_read发送到驱动层。关于ioctl是驱动层的方法，在linux内核代码中。 继续回到上面的waitForResponse方法在BR_REPLY指令中会从mIn这个parcel中读取到数据，然后放到binder_transaction_data数据结构中，这个跟前面写入到mOut中是一样的数据结构，最后将binder_transaction_data中的输入放到reply这个parcel中，最终客户端也就收到了服务端的数据。 在上面分析IPCThreadState::transact中如果是one way的请求方式，则调用waitForResponse时候传进入的reply和acquireResult都是null。而在waitForResponse中如果reply和acquireResult为null的时候，如果是BR_TRANSACTION_COMPLETE则直接goto finish，在one way中不会收到BR_REPLY指令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult){ uint32_t cmd; while (1) { //往驱动层写东西 talkWithDriver(); cmd = (uint32_t)mIn.readInt32(); switch (cmd) { case BR_TRANSACTION_COMPLETE: if (!reply \u0026amp;\u0026amp; !acquireResult) goto finish; break; } } return err; } 异步消息时序图： 同步消息时序图： 上面就是整个客户端到驱动层的调用流程，客户端到驱动层的流程图如下：\n服务端到驱动层 ","date":"2025-03-20T00:00:00Z","permalink":"https://example.com/p/binder%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/","title":"binder通信原理"},{"content":"booster-transform-activity-thread 作用：捕捉异常信息，是抛异常还是捕捉到异常，可以通过捕捉到异常后，上传到服务端 插件入口：ActivityThreadTransformer 通过解析manifest中的application标签，然后在application的onCreate方法最后插入ActivityThreadHooker.hook(\u0026quot;\u0026quot;)方法，其中参数传入的是忽略的包名，获取的是gradle.properties中的booster.transform.activity.thread.packages.ignore配置： 1 booster.transform.activity.thread.packages.ignore=com.demo.cdh.cardswipedemo 在ActivityThreadHooker中获取到ActivityThread类的mH，它是一个handler，然后给它的mCallback替换为ActivityThreadCallback，所以最终会回调到ActivityThreadCallback的handleMessage方法中，该方法会处理各种异常信息，在处理异常的时候，如果不是忽略的包名，则认为是需要处理的异常，然后把该异常抛出去了，交给系统去处理。否则不抛给系统，应用不会崩溃。 理解：在apk构建阶段，它是没有android环境的，所以在transform阶段只是在自定义的application的onCreate方法最后插入了ActivityThreadHooker.hook()方法，在该方法里面构建了ActivityThreadCallback对象，在该对象的构造器中通过重新定义一个和android一样的ActivityThread的包名和类名。所以等到apk运行的时候，通过启动了android的虚拟机，会优先找到系统的ActivityThread类。我可以理解有点偷梁换柱的感觉。 booster-transform-logcat 作用：将系统调用Log.()、e.printStackTrace()、System.out或System.err的方法分别替换成ShadowLog.()、ShadowThrowable.printStackTrace(e:Exception)、ShadowSystem.out或ShadowSystem.err等方法，而这些方法中都是空实现。 插件入口：LogcatTransformer 在transform方法中，通过ClassNode遍历方法，然后在方法的指令中如果遇到opcode是INVOKESTATIC，那么此时的指令是一个MethodInsnNode，如果MethodInsnNode的owner是android/util/Log并且是感兴趣的方法则命中；如果opcode是INVOKEVIRTUAL（java实例的普通方法的调用），此时也是一个MethodInsnNode，获取方法的name是printStackTrace，并且方法的描述是()V，并且通过判断当前owner的class类型是java.lang.throwable的class子类型时就命中；如果opcode是GETSTATIC，并且owner是java/lang/System，方法的name是out或是err时候也命中。 在上面判断当前MethodInsnNode的owner的class类型是java.lang.throwable的class子类型源码分析： 1 context.klassPool.get(THROWABLE).isAssignableFrom(it.owner) context.klassPool.get(THROWABLE)拿到的是一个AbstractKlassPool，它表示的是transform阶段所有已经加载过的class的池子，它是在BoosterTransformInvocation中初始化的，初始化的时候接收compileClasspath和transform.bootKlassPool，其中compileClasspath表示的transform阶段所有的输入class（包括所有transform阶段可以修改和不可修改的输入class和jar文件路径），此处的不可修改表示当前transform识别到的其它插件生成的class，例如dagger2、ButterKnife等。transform.bootKlassPool是获取AndroidExtensions的bootClasspath的路径，然后生成一个AbstractKlassPool，AndroidExtensions的bootClasspath的路径指的是编译时 JDK + Android Framework 的基础类库路径。所以此处有两个AbstractKlassPool，一个是用来表示bootClasspath的父类池子，另外一个就是compileClasspath的池子，bootClasspath的父类池子的classloader指向了compileClasspath的池子的父classloader，此处用到的classloader是一个URLClassLoader，用它是为了和gradle主类加载器避免冲突，能够独立管理项目类路径，支持按需加载类和资源，适应字节码操作需求，隔离Booster内部依赖，防止与项目依赖冲突，允许动态添加插件或模块的类路径。最后加载过的class会放到map中，下次直接拿到该class，最终通过class的isAssignableFrom方法来判断传入的class是否是父class的子类。 booster-transform-shared-preferences ","date":"2025-03-18T00:00:00Z","permalink":"https://example.com/p/booster%E5%85%B6%E4%BB%96%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/","title":"Booster其他插件介绍"},{"content":"平时如果有定制化pdf的时候，一般都是通过有道云笔记来到处pdf，自从用上VScode导出pdf后，发现非常nice。下面记录下整个定制pdf的过程。\n下载插件 在vscode中选择Extensions，并搜索Markdown PDF插件 安装完后，开始通过配置settings.json文件来配置Markdown PDF插件 使用快捷键command+shift+p调起vscode搜索功能，搜索框中输入settings.json settings.json关于markdwon pdf配置如下： 1 2 3 \u0026#34;markdown-pdf.displayHeaderFooter\u0026#34;: false,//不显示页码和页眉 \u0026#34;markdown-pdf.styles\u0026#34;:[\u0026#34;/Users/xiangcheng/desktop/youdao-style.css\u0026#34;],//自定义css \u0026#34;markdown-pdf.breaks\u0026#34;: true//是被br标签用来换行或者空一行 youdao-style.css的配置如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 /* 全局样式 */ body { font-family: \u0026#34;Helvetica Neue\u0026#34;, \u0026#34;Microsoft YaHei\u0026#34;, \u0026#34;Segoe UI\u0026#34;, Arial, sans-serif; font-size: 14px; line-height: 1.5; color: #28262a; margin: 0; padding: 0; } /* 标题样式 */ h1 { font-size: 24px; border-bottom: 2px solid #eee; padding-bottom: 0.3em; } h2 { font-size: 20px; border-bottom: 1px solid #eee; } h3 { font-size: 16px; font-weight: bold; } /* 代码块 */ pre { background-color: #f6f8fa; border-radius: 4px; padding: 12px; overflow: auto; } code { font-family: \u0026#34;Consolas\u0026#34;, \u0026#34;Monaco\u0026#34;, monospace; background-color: rgba(27, 31, 35, 0.05); padding: 0.2em 0.4em; border-radius: 3px; } /* Table styles ripped from Github */ table { display: block; overflow: auto; width: 100%; border-collapse: collapse; border-spacing: 0; } tbody { display: table-row-group; vertical-align: middle; border-color: inherit; } table tr { background-color: #fff; border-top: 1px solid #c6cbd1; } table tr:nth-child(2n) { background-color: #f6f8fa; } table th { font-weight: 600; } table td, table th { border: 1px solid #dfe2e5; padding: 6px 13px; } table tr { background-color: #fff; border-top: 1px solid #c6cbd1; } table tr:nth-child(2n) { background-color: #f6f8fa; } table\u0026gt;thead\u0026gt;tr\u0026gt;th { border-bottom: 0; } /* End of table styles */ /* 列表 */ ul, ol { padding-left: 2em; } li { margin: 0.15em 0; } /* 链接 */ a { color: #3f6bde; text-decoration: none; } /* 图片居中 */ p\u0026gt;img { display: block; margin: 0 auto; } blockquote { border-left: 2px solid #d0d7df; /* 左侧边框颜色 */ background: white; /* 背景色 */ } /* 页面设置 */ @page { size: A4; margin: 5mm; } 使用 打开一个md文件后，然后右键： 参考： https://github.com/yzane/vscode-markdown-pdf youdao-style.css\n","date":"2025-03-18T00:00:00Z","permalink":"https://example.com/p/vscode%E8%87%AA%E5%AE%9A%E4%B9%89pdf/","title":"VScode自定义pdf"},{"content":"bitmap解码方式 解码指的是把图片通过文件读取到内存中，而bitmap正是承载着图片在内存中存储的对象。关于图片的解码方式有如下几种：\nALPHA_8：只存储透明度信息，一个像素占用一个字节，一个字节是8位。所以在在该解码方式下，一个像素是占8位。 ARGB_4444：每个像素占2个字节，也就是16位，其中A占4位，R占4位，G占4位，B占4位（4+4+4+4），支持alpha通道 从API13开始不推荐使用，在android4.4上面，设置的ARGB_4444会被系统使用ARGB_8888替换 ARGB_8888：bitmap编码的默认方式，每像素占4字节，每个通道分别占8位 RGB_565：每像素占用2字节，RGB分别占5，6，5位，不支持alpha通道 参考：https://www.ieclipse.cn/2017/06/14/Android/Android-bitmap-config/ 上面提到的RGB_565解码方式，为什么是5,6,5呢？ RGB_565 是早期 Android 在 内存限制、渲染效率、视觉质量 三者间找到的平衡点。随着设备硬件提升，更高精度的格式（如 ARGB_8888）逐渐成为默认选项，但在特定优化场景中，RGB_565 仍是一个有效的省内存方案。 测试各种解码方式 对于带有透明的图片：在ALPHA_8下，它是只有透明信息，但是他占用的大小还是一个像素占4个字节，并且展示的图片和ARGB_8888一样的。RGB_565是不带透明通道的，但是带有透明度的图片还是能呈现透明样式的，并且占用内存和ARGB_8888一样的。 对于非透明的图片：RGB_565下内存占用是ARGB_8888的一半。在ALPHA_8下面展示的图片所占用的字节大小和ARGB_8888是一样的。 关于这块为什么带有透明的图片在alpha_8下还是和argb_8888下面一样的，下面文章有讲解： https://juejin.cn/post/7059206294959292452 测试了下带透明的图片使用RGB_565的时候，发现解码生成的bitmap的config还是ARGB_8888，说明系统还是会选择合适的颜色模式来解码，通过如下获取最终的解码方式： bitmap压缩 1.采样率压缩：设置BitmapFactory.Options.inSampleSize，值越大，对应的宽高的像素值越小，如果inSampleSize=2，则内存是原来的4分支1了，因为宽高各减少2倍 2.设置编码格式：BitmapFactory.Options.inPreferredConfig，一般设置有RGB_565，ARGB_8888，RGB_565的时候忽略了透明通道。 3.质量压缩：质量压缩不改变图片的像素，改变图片的位深和透明度，适合二进制图片数据，常见的有PNG、JPEG、WEBP压缩算法。其中PNG压缩算法称为无损压缩，基本不会改变图片占用文件的大小，JPEG会根据quality参数来实现压缩。 经过测试：在PNG压缩算法下，图片不会改变，因此被称为无损压缩\n在JPEG压缩算法下，如果是带有透明的图片，由于会忽略透明度，因此会显示成黑色。并且发现保存到本地的文件大小会增大，但是二进制的byte数会随着quality变小而变小。因此带有透明的图片慎用\nweb压缩算法是一种有损压缩，webp图像的体积要比jpeg格式图像小40%，但是webp的编码时间比jpeg格式长8倍。 https://juejin.cn/post/6844903725081821198#heading-12\nbitmap内存获取 bitmap的宽（像素个数）*bitmap的高（像素个数）*每个像素所占用的内存 bitmap的实际宽： 图片的真实宽*设备的densityDpi/图片所在的drawable的densityDpi 设备的densityDpi:最终会赋值到上BitmapFactory.Options.inTargetDensity，通过如下方式获取设备的densityDpi： 图片所在的drawable的densityDpi：最终会设置到BitmapFactory.Options.inDensity上，通过如下方式获取： 关于设备的dpi和drawable的dpi可以跟着源码看下： 1 2 3 4 5 6 7 8 9 10 public static Bitmap decodeResource(Resources res, int id, Options opts) { Bitmap bm = null; InputStream is = null; //获取图片所在drawable的dpi final TypedValue value = new TypedValue(); is = res.openRawResource(id, value); bm = decodeResourceStream(res, value, is, null, opts); return bm; } 上面逻辑是如果没获取到drawable的density，那么就设置为160，否则直接给Options.inDensity设置为density。然后将设备的density设置到Options.inTargetDensity。\n接着调用了decodeStream方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Nullable public static Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts) { validate(opts); Bitmap bm = null; try { //如果是asset目录中的图片，则走if if (is instanceof AssetManager.AssetInputStream) { final long asset = ((AssetManager.AssetInputStream) is).getNativeAsset(); bm = nativeDecodeAsset(asset, outPadding, opts, Options.nativeInBitmap(opts), Options.nativeColorSpace(opts)); } else { //如果是drawable目录下的图片，则走这里 bm = decodeStreamInternal(is, outPadding, opts); } setDensityFromOptions(bm, opts); return bm; } 可以看到如果是drawable目录下的图片，则走decodeStreamInternal：\n1 2 3 4 5 6 7 8 9 10 11 12 private static Bitmap decodeStreamInternal(@NonNull InputStream is, @Nullable Rect outPadding, @Nullable Options opts) { // ASSERT(is != null); byte [] tempStorage = null; if (opts != null) tempStorage = opts.inTempStorage; if (tempStorage == null) tempStorage = new byte[DECODE_BUFFER_SIZE]; return nativeDecodeStream(is, tempStorage, outPadding, opts, Options.nativeInBitmap(opts), Options.nativeColorSpace(opts)); } private static native Bitmap nativeDecodeStream(InputStream is, byte[] storage, Rect padding, Options opts, long inBitmapHandle, long colorSpaceHandle); 最终会调用nativeDecodeStream方法，此处通过aosp来查看源码，该c++代码在/frameworks/base/libs/hwui/jni/BitmapFactory.cpp下，找到cpp文件后，然后再看c++层的方法注册：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 static const JNINativeMethod gMethods[] = { { \u0026#34;nativeDecodeStream\u0026#34;, \u0026#34;(Ljava/io/InputStream;[BLandroid/graphics/Rect;Landroid/graphics/BitmapFactory$Options;JJ)Landroid/graphics/Bitmap;\u0026#34;, (void*)nativeDecodeStream }, { \u0026#34;nativeDecodeFileDescriptor\u0026#34;, \u0026#34;(Ljava/io/FileDescriptor;Landroid/graphics/Rect;Landroid/graphics/BitmapFactory$Options;JJ)Landroid/graphics/Bitmap;\u0026#34;, (void*)nativeDecodeFileDescriptor }, { \u0026#34;nativeDecodeAsset\u0026#34;, \u0026#34;(JLandroid/graphics/Rect;Landroid/graphics/BitmapFactory$Options;JJ)Landroid/graphics/Bitmap;\u0026#34;, (void*)nativeDecodeAsset }, { \u0026#34;nativeDecodeByteArray\u0026#34;, \u0026#34;([BIILandroid/graphics/BitmapFactory$Options;JJ)Landroid/graphics/Bitmap;\u0026#34;, (void*)nativeDecodeByteArray }, { \u0026#34;nativeIsSeekable\u0026#34;, \u0026#34;(Ljava/io/FileDescriptor;)Z\u0026#34;, (void*)nativeIsSeekable }, }; 此处对应到第一个方法nativeDecodeStream：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static jobject nativeDecodeStream(JNIEnv* env, jobject clazz, jobject is, jbyteArray storage, jobject padding, jobject options, jlong inBitmapHandle, jlong colorSpaceHandle) { jobject bitmap = NULL; std::unique_ptr\u0026lt;SkStream\u0026gt; stream(CreateJavaInputStreamAdaptor(env, is, storage)); if (stream.get()) { std::unique_ptr\u0026lt;SkStreamRewindable\u0026gt; bufferedStream(skia::FrontBufferedStream::Make( std::move(stream), SkCodec::MinBufferedBytesNeeded())); SkASSERT(bufferedStream.get() != NULL); bitmap = doDecode(env, std::move(bufferedStream), padding, options, inBitmapHandle, colorSpaceHandle); } return bitmap; } JNIEnv* env 作用\nJNIEnv 是 JNI 环境指针，提供所有 JNI 函数（如调用 Java 方法、操作 Java 对象等）的接口。 它是线程相关的，每个线程的 JNIEnv 独立，不可跨线程使用。 关键功能\n访问 Java 对象：例如通过 GetFieldID、GetMethodID 获取字段或方法。 调用 Java 方法：例如 CallVoidMethod、CallStaticIntMethod。 异常处理：例如 ExceptionCheck、ExceptionDescribe。 内存管理：例如 NewStringUTF 创建字符串，DeleteLocalRef 释放局部引用。 jobject clazz 作用 如果本地方法是 静态方法（static），jobject clazz 表示调用该方法的 Java 类对象（对应 Class 对象）。 如果本地方法是 实例方法（非静态），参数应为 jobject thiz，表示调用该方法的 Java 对象实例。 可以看到调用了另外一个静态方法doDecode： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 static jobject doDecode(JNIEnv* env, std::unique_ptr\u0026lt;SkStreamRewindable\u0026gt; stream, jobject padding, jobject options, jlong inBitmapHandle, jlong colorSpaceHandle) { // Set default values for the options parameters. int sampleSize = 1; bool onlyDecodeSize = false; SkColorType prefColorType = kN32_SkColorType; bool isHardware = false; bool isMutable = false; float scale = 1.0f; bool requireUnpremultiplied = false; jobject javaBitmap = NULL; sk_sp\u0026lt;SkColorSpace\u0026gt; prefColorSpace = GraphicsJNI::getNativeColorSpace(colorSpaceHandle); // Update with options supplied by the client. if (options != NULL) { sampleSize = env-\u0026gt;GetIntField(options, gOptions_sampleSizeFieldID); // Correct a non-positive sampleSize. sampleSize defaults to zero within the // options object, which is strange. if (sampleSize \u0026lt;= 0) { sampleSize = 1; } if (env-\u0026gt;GetBooleanField(options, gOptions_scaledFieldID)) { //获取图片所在文件夹的density const int density = env-\u0026gt;GetIntField(options, gOptions_densityFieldID); //获取屏幕所在的density const int targetDensity = env-\u0026gt;GetIntField(options, gOptions_targetDensityFieldID); const int screenDensity = env-\u0026gt;GetIntField(options, gOptions_screenDensityFieldID); if (density != 0 \u0026amp;\u0026amp; targetDensity != 0 \u0026amp;\u0026amp; density != screenDensity) { //得到bitmap的缩放比例 scale = (float) targetDensity / density; } } } // Determine the output size. //得到bitmap的大小 SkISize size = codec-\u0026gt;getSampledDimensions(sampleSize); int scaledWidth = size.width(); int scaledHeight = size.height(); bool willScale = false; // Apply a fine scaling step if necessary. if (needsFineScale(codec-\u0026gt;getInfo().dimensions(), size, sampleSize)) { willScale = true; scaledWidth = codec-\u0026gt;getInfo().width() / sampleSize; scaledHeight = codec-\u0026gt;getInfo().height() / sampleSize; } // Scale is necessary due to density differences. //根据前面算的缩放比例，得到最终的bitmap大小 if (scale != 1.0f) { willScale = true; scaledWidth = static_cast\u0026lt;int\u0026gt;(scaledWidth * scale + 0.5f); scaledHeight = static_cast\u0026lt;int\u0026gt;(scaledHeight * scale + 0.5f); } //算出最终的缩放比例 const float scaleX = scaledWidth / float(decodingBitmap.width()); const float scaleY = scaledHeight / float(decodingBitmap.height()); SkBitmap outputBitmap; if (willScale) { // Set the allocator for the outputBitmap. SkBitmap::Allocator* outputAllocator; if (javaBitmap != nullptr) { outputAllocator = \u0026amp;recyclingAllocator; } else { //最终的数据在outputAllocator中 outputAllocator = \u0026amp;defaultAllocator; } SkColorType scaledColorType = decodingBitmap.colorType(); // FIXME: If the alphaType is kUnpremul and the image has alpha, the // colors may not be correct, since Skia does not yet support drawing // to/from unpremultiplied bitmaps. outputBitmap.setInfo( bitmapInfo.makeWH(scaledWidth, scaledHeight).makeColorType(scaledColorType)); if (!outputBitmap.tryAllocPixels(outputAllocator)) { // This should only fail on OOM. The recyclingAllocator should have // enough memory since we check this before decoding using the // scaleCheckingAllocator. return nullObjectReturn(\u0026#34;allocation failed for scaled bitmap\u0026#34;); } SkPaint paint; // kSrc_Mode instructs us to overwrite the uninitialized pixels in // outputBitmap. Otherwise we would blend by default, which is not // what we want. paint.setBlendMode(SkBlendMode::kSrc); //最终解码的bitmap在outputBitmap上 SkCanvas canvas(outputBitmap, SkCanvas::ColorBehavior::kLegacy); //使用最终的缩放比例 canvas.scale(scaleX, scaleY); decodingBitmap.setImmutable(); // so .asImage() doesn\u0026#39;t make a copy canvas.drawImage(decodingBitmap.asImage(), 0.0f, 0.0f, SkSamplingOptions(SkFilterMode::kLinear), \u0026amp;paint); } Bitmap* heapBitmap = defaultAllocator.getStorageObjAndReset(); if (hasGainmap \u0026amp;\u0026amp; heapBitmap != nullptr) { heapBitmap-\u0026gt;setGainmap(std::move(gainmap)); } uirenderer::logBitmapDecode(*heapBitmap); // now create the java bitmap //创建bitmap return bitmap::createBitmap(env, heapBitmap, bitmapCreateFlags, ninePatchChunk, ninePatchInsets, -1); } decode中就是关于bitmap的缩放处理，根据option中的targetDensity/density，也就是屏幕的density/drawable的density得到scale，然后根据原始尺寸再乘以该scale得到最终的宽高像素。\n关于底层如何解析图片的解码方式，可以接着上面分析分析BitmapFactory.cpp的doDecode时候调用的，在doDecode时候有这么两句：\n1 2 3 SkColorType prefColorType = kN32_SkColorType; prefColorType = GraphicsJNI::getNativeBitmapColorType(env, jconfig); SkColorType decodeColorType = codec-\u0026gt;computeOutputColorType(prefColorType); 首先默认定义了prefColorType为kN32_SkColorType，然后调用了getNativeBitmapColorType方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 SkColorType GraphicsJNI::getNativeBitmapColorType(JNIEnv* env, jobject jconfig) { ALOG_ASSERT(env); if (NULL == jconfig) { return kUnknown_SkColorType; } ALOG_ASSERT(env-\u0026gt;IsInstanceOf(jconfig, gBitmapConfig_class)); //获取到java层BitmapFactory.Options中的inPreferredConfig（Bitmap.Config）的nativeInt值 int c = env-\u0026gt;GetIntField(jconfig, gBitmapConfig_nativeInstanceID); return legacyBitmapConfigToColorType(c); } SkColorType GraphicsJNI::legacyBitmapConfigToColorType(jint legacyConfig) { const uint8_t gConfig2ColorType[] = { kUnknown_SkColorType, kAlpha_8_SkColorType, kUnknown_SkColorType, // Previously kIndex_8_SkColorType, kRGB_565_SkColorType, kARGB_4444_SkColorType, kN32_SkColorType, kRGBA_F16_SkColorType, kN32_SkColorType, kRGBA_1010102_SkColorType, }; if (legacyConfig \u0026lt; 0 || legacyConfig \u0026gt; kLastEnum_LegacyBitmapConfig) { legacyConfig = kNo_LegacyBitmapConfig; } return static_cast\u0026lt;SkColorType\u0026gt;(gConfig2ColorType[legacyConfig]); } 在getNativeBitmapColorType方法中获取到BitmapFactory.Options中的inPreferredConfig（Bitmap.Config）的nativeInt值，然后传给了legacyBitmapConfigToColorType，在该方法中获取到对应的SkColorType，其实就是将在java层Bitmap.Config枚举中定义的nativeInt，映射到gConfig2ColorType数组中，然后对应获取到c++层的SkColorType枚举。对应关系如下\njava层 c++层 ALPHA_8 kAlpha_8_SkColorType RGB_565 kRGB_565_SkColorType ARGB_4444 kARGB_4444_SkColorType ARGB_8888 kN32_SkColorType RGBA_F16 kRGBA_F16_SkColorType HARDWARE kN32_SkColorType RGBA_1010102 kRGBA_1010102_SkColorType 获取到SkColorType后，接着调用了SkAndroidCodec的computeOutputColorType方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 SkColorType SkAndroidCodec::computeOutputColorType(SkColorType requestedColorType) { //如果每个颜色分量的位数超过8位，就认为是高精度 bool highPrecision = fCodec-\u0026gt;getEncodedInfo().bitsPerComponent() \u0026gt; 8; //从编码信息中获取颜色深度（例如 8-bit、10-bit） uint8_t colorDepth = fCodec-\u0026gt;getEncodedInfo().getColorDepth(); switch (requestedColorType) { //如果是kARGB_4444_SkColorType，直接返回kN32_SkColorType（ARGB_8888） //原因：ARGB_4444 格式已过时，现代设备更倾向使用 32 位格式（兼容性/性能优化）。 case kARGB_4444_SkColorType: return kN32_SkColorType; //如果是kN32_SkColorType，直接不处理 case kN32_SkColorType: break; case kAlpha_8_SkColorType: case kGray_8_SkColorType: //若当前图像颜色类型为 kGray_8，返回 kGray_8，否则跳过 //kAlpha_8 旧版本中可能用于灰度图，现需兼容性处理 //仅当原始图像为灰度时，才返回 kGray_8（避免无效转换） if (kGray_8_SkColorType == this-\u0026gt;getInfo().colorType()) { return kGray_8_SkColorType; } break; case kRGB_565_SkColorType: //若图像不透明（alphaType == kOpaque），返回 kRGB_565 //RGB_565 不支持透明度，仅适用于不透明图像 if (kOpaque_SkAlphaType == this-\u0026gt;getInfo().alphaType()) { return kRGB_565_SkColorType; } break; case kRGBA_1010102_SkColorType: //若颜色深度为 10-bit，返回 kRGBA_1010102，颜色深度表示每个通道占10位，如果是RGB的话，则是30位的二进制，如果是ARGB的话，则是40位的二进制 //10-bit 深度匹配该格式的高精度需求 if (colorDepth == 10) { return kRGBA_1010102_SkColorType; } break; case kRGBA_F16_SkColorType: //强制高精度浮点格式，每一个颜色通道是16位，如果是RGB的话，则是48位的二进制 return kRGBA_F16_SkColorType; default: break; } //如果高进度的则返回kRGBA_F16_SkColorType，如果位深是10的话，则返回kRGBA_1010102_SkColorType，其余的都返回kN32_SkColorType return highPrecision ? kRGBA_F16_SkColorType : (colorDepth == 10 ? kRGBA_1010102_SkColorType : kN32_SkColorType); } 这也就解释了在RGB_565解码方式下，如果是带透明的图片，直接使用kN32_SkColorType的解码方式，也就是ARGB_8888。默认的解码方式，如果是不带透明的图片，则使用的是RGB_565。如果使用的是ALPHA_8，不是灰度图像的时候，使用的是ARGB_8888。\n关于drawable的densityDpi的值如下： 结论：图片所占内存和drawable的densityDpi成反比。\n来源：https://juejin.cn/post/6844904166138069005\nbitmap内存分配： 8.0之前的Bitmap像素数据基本存储在Java heap 8.0之后的 Bitmap像素数据基本存储在native heap 参考：https://juejin.cn/post/6844903608887017485\nbitmap像素分配： 参考：https://juejin.cn/post/6844903715766272013\n","date":"2025-03-11T00:00:00Z","permalink":"https://example.com/p/bitmap%E6%80%BB%E7%BB%93/","title":"bitmap总结"},{"content":"设计原则 开闭原则 主要指对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节。 优点：保持软件的稳定性，不影响原有业务逻辑代码。使代码更具有模块化，易于维护。提高开发效率。 来源：https://segmentfault.com/a/1190000021922108 里式替换原则 所有引用基类的地方必须能透明地使用其子类的对象 原则：子类必须实现父类的抽象方法，不得重写父类的非抽象方法 子类可以增加自己特有的方法 子类在实现父类的方法的时候，形参要比父类的参数更加宽松。 子类实现父类的方法的时候，出参要比父类更加严格。 依赖倒置原则 高层模块不应该直接依赖底层模块，二者应该依赖抽象，抽象不应该依赖细节，细节应该依赖抽象。 比如A类是接口，B类是实现，而C类要使用B类，那么C类不能直接使用B类，而是通过依赖A接口来实现，这样将使用谁的权交给了外界。C类更加的灵活 单一职业原则 一个类或者模块只负责完成一个职责。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。 接口隔离原则 尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。和单一职责原则相比，他们都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想。两者不同在于单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。单一职责原则主要是约束类，它针对的是程序中的实现和细节。接口隔离原则主要是约束接口，主要针对抽象和程序整体框架的构建。 迪米特法则 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用，目的是降低类之间的耦合度，提高模块的相对独立性。由于亲合度降低，从而提高了类的可复用率和系统的扩展性。 比如A类想调用B类，但是他们又没有直接联系，而通过中间的C类来调用B类。A-\u0026gt;C-\u0026gt;B这种调用关系 合成复用原则 要求在软件复用时，尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用集成关系来实现。采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，从而新对象可以调用已有对象的功能。 维持了类的封装性，因为成分对象的内部细节是新对象看不见的，这种复用称为黑箱复用。 新旧类之间的耦合度低，这种复用所需的依赖较少，新对象存储成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 设计模式 设计模式分为创建型、结构型、行为型。 创建型：用于对象的创建，提高代码的灵活性和复用性 设计模式 描述 工厂方法模式（Factory Method） 通过工厂类提供一个创建对象的接口，而不是直接 new 一个对象，提高代码的可扩展性。 抽象工厂模式（Abstract Factory） 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。 单例模式（Singleton） 确保一个类只有一个实例，并提供一个全局访问点。 建造者模式（Builder） 用于创建复杂对象，将对象的构建与表示分离，以便相同的构建过程可以创建不同的表示。 原型模式（Prototype） 通过复制（克隆）已有的实例来创建新对象，而不是通过实例化。 结构型模式：主要用于类与对象的组合，确保系统的结构更加灵活和高效。 设计模式 描述 适配器模式（Adapter） 让原本不兼容的接口能够协同工作，相当于“转换器”。 桥接模式（Bridge） 分离抽象部分和实现部分，使它们可以独立变化，提高可扩展性。 装饰器模式（Decorator） 通过动态地给对象增加额外的功能，而不会改变其结构（类似于 Java 的 IO 流）。 组合模式（Composite） 允许将对象组合成树形结构，以表示“整体-部分”关系，适用于树形结构数据。 外观模式（Facade） 提供一个统一的接口，用于访问子系统的一组接口，简化客户端的调用。 享元模式（Flyweight） 通过共享对象，减少内存占用，提高性能。 代理模式（Proxy） 通过代理对象控制对目标对象的访问，例如：静态代理、动态代理（JDK/CGLIB）。 行为型模式：主要用于对象之间的通信和职责分配，提高代码的可维护性和可扩展性。 设计模式 描述 策略模式（Strategy） 定义一系列算法，将每种算法封装起来，并使它们可以互换。 观察者模式（Observer） 允许对象间建立一对多的依赖关系，当一个对象状态变化时，所有依赖它的对象都会收到通知（如 监听器 机制）。 责任链模式（Chain of Responsibility） 将请求沿着处理链传递，直到某个对象处理请求，降低耦合度（如 Java Web 过滤器）。 命令模式（Command） 将请求封装为对象，支持请求的撤销（Undo）和恢复（Redo）。 备忘录模式（Memento） 保存对象的历史状态，以便以后恢复（如 撤销/恢复 操作）。 状态模式（State） 允许对象在不同状态下改变行为，避免大量 if-else 语句。 中介者模式（Mediator） 通过一个中介对象来协调多个对象之间的交互，避免对象间的直接通信。 迭代器模式（Iterator） 提供一种访问集合对象元素的方法，而不暴露集合的内部表示。 访问者模式（Visitor） 允许在不修改对象结构的情况下，向对象结构中添加新的行为（如 XML 解析）。 解释器模式（Interpreter） 用于定义语言的语法规则，并解释相应的表达式（如 SQL 解析）。 单例模式 饿汉式：类加载时机就已经把单例对象实例化出来了，所以他不存在线程安全问题。但是它会浪费内存，在还没使用的时候，就已经创建了实例。 懒汉式（线程不安全） 创建对象的时机修改为了在getInstance内部，需要时再创建，可以节约系统资源。 getInstance方法在多个线程并发调用时，有可能会出现创建了多个实例，所以这是线程不安全的单例模式。 懒汉式（线程安全） 方法上加锁，这种加锁能保证线程安全问题，但是加锁的粒度较大，每次在调用getInstance方法的时候，都需要加锁，很显然，锁的开销很大。 懒汉式（线程安全-dcl模式） 双重判断，成员属性instance上，增加了volatile关键字，保障多线程对instance值的可见性以及禁止指令重排。 第一层空判断是为了锁的开销，只有为空的时候才加锁。第二层空判断是为了防止创建了多个实例。 静态内部类中加静态变量 静态内部类可以达到双检锁的效果。将instance放在了内部类中，不会在类加载的时候就加载实例，这个和饿汉式在类加载的时候就加载有区别。他只会在getInstance的时候，才会去加载内部类，此时才会去加载单例实例。并且instance是内部类类加载的时候才进行加载，所以线程安全问题也保证了。 枚举单例 这种不仅能避免多线程同步问题，还自动支持序列化机制，防止反序列化重新创建新的对象，防止多次实例化。 原型模式 Java原型模式（Prototype Pattern）是一种创建型设计模式，其目的是通过复制现有对象来创建新的对象。 使用场景： 当对象创建的过程比较耗时或者比较复杂，例如需要进行复杂的计算或者涉及到网络请求等操作，可以使用原型模式来避免重复的初始化过程。 当需要创建的对象需要和其他对象进行协同工作时，例如需要创建一个包含多个对象的组合对象，可以使用原型模式来复制一个已有的组合对象，然后进行修改来创建新的组合对象。 当需要动态地增加或者删除一些对象时，可以使用原型模式来复制一个已有的对象，然后进行修改来创建新的对象。 当需要保护对象的复杂状态时，例如当一个对象的创建需要大量的数据初始化时，可以使用原型模式来保护这些数据，避免因为对象的复制而产生意外的副作用。 代码实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 定义一个原型接口 interface Prototype { public Prototype clone(); } // 具体的原型类 class ConcretePrototype implements Prototype { public Prototype clone() { return new ConcretePrototype(); } } // 客户端代码 class Client { public static void main(String[] args) { Prototype prototype = new ConcretePrototype(); Prototype clone = prototype.clone(); } } 使用小结： Java中的Object类实现了Cloneable接口，这就意味着Java中的任何对象都可以实现原型模式。通过实现Cloneable接口，并重写Object类中的clone()方法，可以实现原型模式。例如 ArrayList、HashMap 等集合类都实现了Cloneable 接口，可以通过复制现有对象来创建新的对象。 Java中的线程池也是使用了原型模式，线程池中的每个线程都是从原型线程中复制而来，而不是每次创建新的线程。 工厂模式 分为简单工厂模式、工厂方法模式、抽象工厂模式。定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的创建与使用相分离。创建型模式可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。\n简单工厂模式 简单工厂类会很庞大，负责创建所有产品的创建，如果要新增产品类，会修改工厂类，违背了开闭原则。并且违背了高聚合原则。 工厂方法模式\n在简单工厂类基础上将工厂类也进行抽象化，每个工厂类只做一件事，那就是生产对应的对象，保证了单一职责原则，并且保证了开闭原则，如果要生产不同的对象，只需要提供对应的工厂实现类就可以。 抽象工厂模式\n和上面的工厂方法模式差不多，也是有对应的工厂实现类，区别是工厂类能生产不同级别的产品。 建造者模式 将一个复杂对象的构建与它的表示分离，使同样的构建过程可以创建不同的表示。将一个复杂对象进行一步步的构建而成，扩展性好，可以灵活配置的属性，来生成不同的对象。 构建指的是对象的创建过程，通过一步步组装的形式最终创建对象，而客户端在此过程中只需要提供组装的属性，而无需关心组装的过程 表示指的是对象创建完后的形态或结构，创建完后，对象就形成不可变的结构。此时客户端可以放心使用该对象。 静态代理模式 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用。 代理对象可以扩展目标对象的功能 其中静态代理要求代理类和被代理类实现同样的接口，旨在想扩展被代理类的某些功能，比如想添加些日志等行为 动态代理模式 动态代理模式和静态代理模式的区别是，静态代理在编译期就已经确定了代理类和被代理类的关系，而动态代理是在运行时通过Proxy创建了代理类，在代理类中通过反射动态调用了InvokeHandler接口的实现类的invoke方法，最后在invoke中统一调用被代理类的方法。\n总结： 代理模式主要是通过代理类来控制对象的访问，主要涉及到访问权限、延迟加载、日志记录。比如有一个用户角色权限比较低，不能访问数据库，此时在调用对象的时候，判断权限而抛异常。再者比如在代理类中，可以延迟初始化被代理类。再比如可以通过日志记录被代理类的访问。\n适配器模式 将一个类的接口转换成客户希望的另外一个接口，使得原本是由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式。类结构型模式的耦合度比后者高。 优点：客户端通过适配器可以透明地调用目标接口，复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。 角色：目标类，它是真正被调用的类；适配者类，它是被访问和适配的现存组件库中的组件接口；适配器类：它是一个转换器，把适配者接口转换成目标接口，让客户能通过适配者调用目标接口。 类适配器模式： 在上面Adaptee是业务要被适配的类，适配器类ClassAdapter通过继承自Adaptee和被适配器类耦合，不方便扩展，最好的方案是将被适配器类交给调用方自己传进来。 对象适配器模式： 从这里可以看出，对象适配模式更加的符合开闭原则，并且更加容易扩展。 桥接模式 强调的是抽象与实现分离，使它们可以独立变化。使用组合关系代替继承关系来实现。降低了抽象和实现两个可变维度的耦合度。和上面适配器模式不同，这里强调的是多种抽象的组合。它是有以下角色： 抽象化角色：定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化角色：定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化角色：给出实现化角色接口的具体实现。 实现化角色在这里是依附于抽象化角色上的，也就是最终是被扩展化角色所使用。 上面的color是一个实现化角色，其中具体实现化角色分为红色和黄色。抽象化角色是Bag类，它的扩展抽象化角色有Wallet和HandBag。他们使用了color这个实现化角色。 装饰者模式 在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。 有以下角色： 抽象构件角色：定义一个抽象接口以规范准备接收附加责任的对象。 具体构件角色：实现抽象构件，通过装饰角色为其添加一些职责。 抽象装饰角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。 具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。 上面ConcreteDecorator是具体的的装饰角色，它是持有了具体的构件角色ConcreteComponent，在调用具体的构建角色方法外，还调用了自己的另外一个方法，这个是和桥接模式的一个区别之处。并且装饰者模式的抽象的装饰角色实现了抽象构件角色，但是桥接模式中，抽象化构件角色中是不实现实现化角色接口的。 外观模式 是迪米特法则的体现，比如一个系统想调用子系统的某个方法的时候，为了降低客户端调用系统的时候，将调用子系统的方法，通过统一的中心来调用子系统。分为以下角色： 享元模式 相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。 具体有如下角色： 抽象享元角色：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。 具体享元角色：实现抽象享元角色中所规定的接口。 非享元角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。 享元工厂角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。 上面享元工厂通过key来管理不同的享元角色，而享元角色持有了非享元角色的接口引用。上面例子中前3次获取的是同一个享元角色，后两次获取的是同一个享元角色。 参考： Java常用设计模式(一) Java常用设计模式(二) Java常用设计模式(三) ","date":"2025-03-07T00:00:00Z","permalink":"https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/","title":"java设计原则与模式"},{"content":"在看booster内联R的时候，看到过滤R$color这种内部类的时候，是通过正则表达式进行过滤的，然后它的匹配规则是：\n1 2 internal const val R_REGEX = \u0026#34;.*/R\\\\\\$.*|.*/R\\\\.*\u0026#34; Pattern.matches(R_REGEX, klass.name) 我是想匹配到com/xc/lib/R$color或com/xc/lib/R形如这种class的名字，第一眼看的时候有点懵，然后通过查看正则表达式的语法时候，发现正则是有规律可循的，先看一张表格：\n符号 含义 示例 . 匹配任意单个字符（除换行符） a.b 可匹配 acb、a1b \\d 数字 (0-9) \\d{3} 匹配 123 \\w 单词字符 (a-z, A-Z, 0-9, _) \\w+ 匹配 abc_123 \\s 空白字符（空格、Tab、换行） Hello\\sWorld 匹配 Hello World \\S 单个非空白字符 任意单个非空格字符都匹配 \\b\t单词边界\t\\bcat\\b 仅匹配 cat，不匹配 catalog ^ 行首 ^Hello 仅匹配 Hello 在行首的情况 $ 行尾 end$ 仅匹配 end 在行尾的情况 * 匹配前一个字符 0 次或多次 ab*c 可匹配 ac、abc、abbc + 匹配前一个字符 1 次或多次 ab+c 仅匹配 abc、abbc，不匹配 ac ? 匹配前一个字符 0 次或 1 次 ab?c 可匹配 ac 或 abc {n} 匹配 n 次 a{3} 仅匹配 aaa {n,} 至少匹配 n 次 a{2,} 可匹配 aa、aaa {n,m} 匹配 n 到 m 次 a{2,4} 可匹配 aa、aaa、aaaa [] 字符集合 [aeiou] 匹配任意元音字母 ` ` 或（匹配左边或右边） () 分组 (ab)+ 匹配 ab、abab 上面\u0026quot;.*/R\\\\\\$.*|.*/R\\\\.*\u0026quot;可以拆解成两个正则，因为中间用了一个或，分别是.*/R\\\\\\$.*、.*/R\\\\.*，首先来看.*/R\\\\\\$.*它可以分解成:\n字符 含义 匹配字符 .* 表示有0次或多次的单个字符 com/xc/lib /R 直接匹配字符 /R \\$ 这里由于和$有冲突，所以前面加了转义，匹配的是$字符 $ .* 和开头的匹配一样，表示有0次或多次的单个字符 color 所以最终com/xc/lib/R$color能被匹配到，再来看.*/R\\\\.*它可以分解成： 字符 含义 匹配字符 \u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash; \u0026mdash;\u0026mdash; .* 表示有0次或多次的单个字符 com/xc/lib /R 直接匹配字符 /R \\.* 这里由于和.有冲突，所以前面加了转义，匹配的是0次或多次的.字符 . 所以最终com/xc/lib/R也能被匹配到。\n更多正则的匹配： 测试用例： #key_mmkv_migrate_version# ，正则表达式(#[^#]*[^#\\\\s]+[^#]*#)，使用\n1 2 Pattern pattern = Pattern.compile(\u0026#34;(#[^#]*[^#\\\\s]+[^#]*#)\u0026#34;); Matcher matcher = pattern.match(\u0026#34;#key_mmkv_migrate_version# \u0026#34;) 该正则表达式作用：用于匹配 以 # 开头和结尾的内容，并且内容中至少包含 一个非空白的非 # 字符。 正则解析：\n部分 含义 # 匹配 #（开始） [^#]* 匹配任意多个非 # 的字符（0 次或多次） [^#\\s]+ 至少匹配 1 个非 # 和非空格的字符（保证内容不是空的） [^#]* 再次匹配任意多个非 # 的字符（0 次或多次） # 匹配 #（结束） (\u0026hellip;) 括号用于捕获匹配内容 Matcher#replaceAll方法\n1 matcher.replaceAll(\u0026#34;\u0026lt;a type=\u0026#34;topic\u0026#34; \u0026gt;$1\u0026lt;/a\u0026gt;\u0026#34;) 会被替换成如下： \u0026lt;a type=\u0026quot;topic\u0026quot; \u0026gt;#key_mmkv_migrate_version#\u0026lt;/a\u0026gt; 正则: \u0026lt;a[^\u0026gt;]*?((\u0026gt;[\\s\\S]*?\u0026lt;/a\u0026gt;)|(/\u0026gt;))\n1 2 @kotlin.internal.InlineOnly public inline fun String.toRegex(): Regex = Regex(this) 将string转化成Regex:\n1 2 val regexStr = `\u0026lt;a[^\u0026gt;]*?((\u0026gt;[\\s\\S]*?\u0026lt;/a\u0026gt;)|(/\u0026gt;))` val regex = regexStr.toRegex() 用于 匹配 HTML 标签（包括自闭合 和 **带内容的 \u0026hellip; 形式）。 正则解析：\n部分 含义 \u0026lt;a 匹配 \u0026lt;a（开始的 标签） [^\u0026gt;]*? 非贪婪匹配 内的所有属性（不包括 \u0026gt;) `((… ) (/\u0026gt;))` \u0026gt;[\\s\\S]*? 情况 ①：匹配 \u0026gt; 后的内容，直到 / \u0026gt; 情况 ②：匹配 （自闭合标签） CharSequence.contains(regex: Regex):\n1 2 3 4 val source = `\u0026lt;a type=\u0026#34;topic\u0026#34; \u0026gt;#key_mmkv_migrate_version#\u0026lt;/a\u0026gt; ` val regexStr = `\u0026lt;a[^\u0026gt;]*?((\u0026gt;[\\s\\S]*?\u0026lt;/a\u0026gt;)|(/\u0026gt;))` val regex = regexStr.toRegex() source.contains(regex) contains方法表示是否符合这个正则判断。\nRegex.find(input: CharSequence, startIndex: Int = 0): MatchResult? Regex.find() 方法用于 查找字符串中第一个匹配的结果，返回 MatchResult?，如果找不到匹配项，则返回 null。 MatchResult.range:表示匹配的索引范围，分别用start和endInclusive来表示范围。 MatchResult.value:表示匹配到的内容\n正则：(\\\\S+)=\\\u0026quot;([^\\\u0026quot;]+)\\\u0026quot; 作用：主要是用来匹配html/xml属性及其值，比如\u0026lt;a type=\u0026quot;topic\u0026quot; \u0026gt;#key_mmkv_migrate_version#\u0026lt;/a\u0026gt; 能匹配到，它是匹配type=\u0026quot;topic\u0026quot;。 正则解析：\n正则部分 作用 (\\S+) 匹配属性名（非空字符 \\S，匹配至少一个字符 +） = 匹配等号（固定字符 =） \u0026quot;([^\u0026quot;]+)\u0026quot; 匹配属性值（被双引号 \u0026quot; 包裹，内容不含 \u0026ldquo;） Regex.findAll\n1 public actual fun findAll(input: CharSequence, startIndex: Int = 0): Sequence\u0026lt;MatchResult\u0026gt; 用于获取字符串中所有符合正则的结果，返回的是一个Sequence的MatchResult\n1 2 3 val attributeRegex = \u0026#34;(\\\\S+)=\\\u0026#34;([^\\\u0026#34;]+)\\\u0026#34;\u0026#34;.toRegex() val source = \u0026#34;\u0026lt;a type=\u0026#34;topic\u0026#34; \u0026gt;#key_mmkv_migrate_version#\u0026lt;/a\u0026gt; \u0026#34; val matchResultList = attributeRegex.findAll(source) MatchResult.destructured属性 用来提取匹配结果的捕获组，例如上面提取的是type和topic这一组内容。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 val regex = Regex(\u0026#34;(\\\\d{4})-(\\\\d{2})-(\\\\d{2})\u0026#34;) // 匹配日期格式 YYYY-MM-DD val input = \u0026#34;2024-03-07\u0026#34; val matchResult = regex.find(input) if (matchResult != null) { val (year, month, day) = matchResult.destructured println(\u0026#34;Year: $year, Month: $month, Day: $day\u0026#34;) } 输出： Year: 2024, Month: 03, Day: 07 然后通过MatchResult.destructured.toList()方法转成list，就可以获取type和topic内容了。\nSpannableStringBuilder使用\n在 Android 开发中，SpannableStringBuilder 主要用于富文本（Styled Text），可以让字符串的一部分具有不同的格式，比如 颜色、大小、样式、点击事件、图片等。它比 Html.fromHtml() 性能更好，更适合动态拼接文本。\n使用：\n1 2 3 4 5 6 7 8 9 10 11 val spannable = SpannableStringBuilder(\u0026#34;Hello, Android!\u0026#34;) // 给 \u0026#34;Android\u0026#34; 设置红色 spannable.setSpan( ForegroundColorSpan(Color.RED), 7, 14, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE ) // 应用到 TextView textView.text = spannable SpannableStringBuilder(\u0026ldquo;Hello, Android!\u0026rdquo;) 创建一个可变的 Spannable 对象。 setSpan(ForegroundColorSpan(Color.RED), 7, 14, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE) ForegroundColorSpan(Color.RED) → 设置前景色为红色。 7, 14 → 应用范围（“Android” 字符的索引）。 SPAN_EXCLUSIVE_EXCLUSIVE → 该 Span 只作用于当前字符范围，后续文本修改不会继承。 textView.movementMethod = LinkMovementMethod.getInstance()，设置 TextView 可点击 所以如果想要多个效果，可以添加多个span给SpannableStringBuilder，通过多次调用setSpan方法，然后设置不同的坐标信息。\nSpannableStringBuilder.append()，可以追加多个span的样式，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val spannable = SpannableStringBuilder() // 添加普通文本 spannable.append(\u0026#34;Normal Text \u0026#34;) // 添加红色文字 val redText = SpannableString(\u0026#34;Red Text\u0026#34;) redText.setSpan(ForegroundColorSpan(Color.RED), 0, redText.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE) spannable.append(redText) // 添加蓝色斜体文字 val blueText = SpannableString(\u0026#34; Blue Italic\u0026#34;) blueText.setSpan(ForegroundColorSpan(Color.BLUE), 0, blueText.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE) blueText.setSpan(StyleSpan(Typeface.ITALIC), 0, blueText.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE) spannable.append(blueText) // 应用到 TextView textView.text = spannable 上面用到了SpannableString，它是实现了CharSequence，是对字符串进行样式的扩展类，然后把它添加到SpannableStringBuilder中。\nspan中插入图片，通过imageSpan实现：\n1 2 3 4 5 6 7 8 9 10 11 12 val spannable = SpannableStringBuilder(\u0026#34;Text with image \u0026#34;) val drawable = ContextCompat.getDrawable(context, R.drawable.ic_launcher_foreground)!! drawable.setBounds(0, 0, drawable.intrinsicWidth, drawable.intrinsicHeight) // 在文本末尾添加图片 spannable.setSpan( ImageSpan(drawable, ImageSpan.ALIGN_BASELINE), spannable.length - 1, spannable.length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE ) textView.text = spannable ","date":"2025-03-04T00:00:00Z","permalink":"https://example.com/p/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%B4%E7%90%86/","title":"正则表达式整理"},{"content":"上一节通过booster-transform-toast的使用，接着介绍了booster插件的主框架，最后自己简单使用了asm替换class中方法的调用，这一节讲解booster通过R内联来减少包体积。\n首先我们了解下多组件打包的时候，资源是怎么管理的，首先每个module都会有自己的R.class，分别存储了anim、animator、attr、bool等属性： 可以看到R.class中分别用静态内部类的形式保存各种资源属性，每一个属性是用一个静态常量的形式保存，其中每一个属性值是由PackageId+TypeId+EntryId组合的一个值： 就拿abc_face_in这个属性值，它是0x7f010000这个值。下面来拆解下这个值：\nPackageId：是包的id值，android中如何三方应用的话，这个值一直是0x7f，系统应用的话是0x01，它是占用一个字节。 TypeId：是资源的类型Id值，一般都是由anim、animator、attr等类型，比如anim是0x01，animator是0x02，attr是0x03，依次类推。它也是占用一个字节 EntryId：是具体类型下资源实例的id值，从0开始，依次递增，它是占用2个字节。 在多module下，每一个module打包后，都会有自己的R.class，其中module为library如果引用了资源的时候，编译apk的时候module中引用的还是R.class中的资源id。如果是主module，也就是application类型的，它会直接被替换成常量值了。因为module的class文件，在主工程编译时，不会再次进行编译，module的calss文件原封不动的打包进apk。而资源id为常量是在主工程编译时才形成的，但module生成class时，使用的是上面说到的变量，所以一直被保留了下来。 如果同一个资源分别在module1和module2都定义了，module1中引用了自己module的资源，此时主module先后依赖了module1和module2，那么此时module1中引用的资源是module1中的资源，如果主module先后依赖了module2和module1，那么此时module1中引用的资源是module2中定义的。出现上面的原因是因为主module在编译的时候，看谁先依赖，如果找到了对应的资源，那么就会以先依赖的module中的资源为主。 在编译的过程中，会把合并后的资源生成一个临时的R.txt文件，它的路径在app模块下的build/intermediates/symbols/debug/R.txt中： 在不同版本的agp上symbols文件夹可能不同，我这里用的agp是3.5.3，可以看到R.txt中每一行标明了资源的值类型、资源类型、资源名、资源对应的16进制值。最终通过aapt工具会构建resource.arsc文件。resource.arsc是一个资源映射表，里面通过16进制值找到对应的资源名。其中values文件夹下的资源都会在该文件中定义： 可以看到多语言默认打到apk中，所以如果不需要国际化是可以省去多语言的。而像非values文件夹下的资源直接在res目录中。\n总结 app打包过程中，总会用先依赖的module中定义的资源，即使该module用的是该module中的资源，最终由于打包合并资源的时候，优先去用先依赖的module中的资源。然后会生成R.txt文件，该文件是资源合并后生成的文件，里面每一行定义了某个资源的资源值类型、资源类型、资源名、资源16进制值，最终通过该文件生成resources.arsc，该文件是描述每个资源的资源值和资源名的一个对应关系，最终通过该关系找到资源。 在代码中，主module默认是通过常量引用资源，而library的module中默认引用资源的时候，是引用自己module的R中的变量，而资源最终会合并，所以最终使用的资源看合并时候哪个资源被打到apk中。\n上面提到谁先依赖的问题， 其实这个可以通过gradle命令查看依赖关系，比如我想看app这个module的依赖，比如我想看运行时的依赖：\n1 ./gradlew app:dependencies --configuration debugRuntimeClasspath 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 debugRuntimeClasspath - Resolved configuration for runtime for variant: debug +--- project :lib | +--- project :lib2 | | +--- androidx.constraintlayout:constraintlayout:1.1.3 | | | \\--- androidx.constraintlayout:constraintlayout-solver:1.1.3 | | +--- com.google.android.material:material:1.1.0 | | | +--- androidx.annotation:annotation:1.0.1 -\u0026gt; 1.1.0 | | | +--- androidx.appcompat:appcompat:1.1.0 | | | | +--- androidx.annotation:annotation:1.1.0 | | | | +--- androidx.core:core:1.1.0 | | | | | +--- androidx.annotation:annotation:1.1.0 | | | | | +--- androidx.lifecycle:lifecycle-runtime:2.0.0 -\u0026gt; 2.1.0 | | | | | | +--- androidx.lifecycle:lifecycle-common:2.1.0 | | | | | | | \\--- androidx.annotation:annotation:1.1.0 | | | | | | +--- androidx.arch.core:core-common:2.1.0 | | | | | | | \\--- androidx.annotation:annotation:1.1.0 | | | | | | \\--- androidx.annotation:annotation:1.1.0 | | | | | +--- androidx.versionedparcelable:versionedparcelable:1.1.0 | | | | | | +--- androidx.annotation:annotation:1.1.0 | | | | | | \\--- androidx.collection:collection:1.0.0 -\u0026gt; 1.1.0 | | | | | | \\--- androidx.annotation:annotation:1.1.0 | | | | | \\--- androidx.collection:collection:1.0.0 -\u0026gt; 1.1.0 (*) | | | | +--- androidx.cursoradapter:cursoradapter:1.0.0 | | | | | \\--- androidx.annotation:annotation:1.0.0 -\u0026gt; 1.1.0 | | | | +--- androidx.fragment:fragment:1.1.0 | | | | | +--- androidx.annotation:annotation:1.1.0 | | | | | +--- androidx.core:core:1.1.0 (*) | | | | | +--- androidx.collection:collection:1.1.0 (*) | | | | | +--- androidx.viewpager:viewpager:1.0.0 | | | | | | +--- androidx.annotation:annotation:1.0.0 -\u0026gt; 1.1.0 | | | | | | +--- androidx.core:core:1.0.0 -\u0026gt; 1.1.0 (*) | | | | | | \\--- androidx.customview:customview:1.0.0 | | | | | | +--- androidx.annotation:annotation:1.0.0 -\u0026gt; 1.1.0 | | | | | | \\--- androidx.core:core:1.0.0 -\u0026gt; 1.1.0 (*) | | | | | +--- androidx.loader:loader:1.0.0 | | | | | | +--- androidx.annotation:annotation:1.0.0 -\u0026gt; 1.1.0 | | | | | | +--- androidx.core:core:1.0.0 -\u0026gt; 1.1.0 (*) | | | | | | +--- androidx.lifecycle:lifecycle-livedata:2.0.0 | | | | | | | +--- androidx.arch.core:core-runtime:2.0.0 | | | | | | | | +--- androidx.annotation:annotation:1.0.0 -\u0026gt; 1.1.0 | | | | | | | | \\--- androidx.arch.core:core-common:2.0.0 -\u0026gt; 2.1.0 (*) | | | | | | | +--- androidx.lifecycle:lifecycle-livedata-core:2.0.0 | | | | | | | | +--- androidx.lifecycle:lifecycle-common:2.0.0 -\u0026gt; 2.1.0 (*) | | | | | | | | +--- androidx.arch.core:core-common:2.0.0 -\u0026gt; 2.1.0 (*) | | | | | | | | \\--- androidx.arch.core:core-runtime:2.0.0 (*) | | | | | | | \\--- androidx.arch.core:core-common:2.0.0 -\u0026gt; 2.1.0 (*) | | | | | | \\--- androidx.lifecycle:lifecycle-viewmodel:2.0.0 -\u0026gt; 2.1.0 | | | | | | \\--- androidx.annotation:annotation:1.1.0 | | | | | +--- androidx.activity:activity:1.0.0 | | | | | | +--- androidx.annotation:annotation:1.1.0 | | | | | | +--- androidx.core:core:1.1.0 (*) | | | | | | +--- androidx.lifecycle:lifecycle-runtime:2.1.0 (*) | | | | | | +--- androidx.lifecycle:lifecycle-viewmodel:2.1.0 (*) | | | | | | \\--- androidx.savedstate:savedstate:1.0.0 | | | | | | +--- androidx.annotation:annotation:1.1.0 | | | | | | +--- androidx.arch.core:core-common:2.0.1 -\u0026gt; 2.1.0 (*) | | | | | | \\--- androidx.lifecycle:lifecycle-common:2.0.0 -\u0026gt; 2.1.0 (*) | | | | | \\--- androidx.lifecycle:lifecycle-viewmodel:2.0.0 -\u0026gt; 2.1.0 (*) | | | | +--- androidx.appcompat:appcompat-resources:1.1.0 | | | | | +--- androidx.annotation:annotation:1.1.0 | | | | | +--- androidx.core:core:1.0.1 -\u0026gt; 1.1.0 (*) | | | | | +--- androidx.vectordrawable:vectordrawable:1.1.0 | | | | | | +--- androidx.annotation:annotation:1.1.0 | | | | | | +--- androidx.core:core:1.1.0 (*) | | | | | | \\--- androidx.collection:collection:1.1.0 (*) | | | | | +--- androidx.vectordrawable:vectordrawable-animated:1.1.0 | | | | | | +--- androidx.vectordrawable:vectordrawable:1.1.0 (*) | | | | | | +--- androidx.interpolator:interpolator:1.0.0 | | | | | | | \\--- androidx.annotation:annotation:1.0.0 -\u0026gt; 1.1.0 | | | | | | \\--- androidx.collection:collection:1.1.0 (*) | | | | | \\--- androidx.collection:collection:1.0.0 -\u0026gt; 1.1.0 (*) | | | | +--- androidx.drawerlayout:drawerlayout:1.0.0 | | | | | +--- androidx.annotation:annotation:1.0.0 -\u0026gt; 1.1.0 | | | | | +--- androidx.core:core:1.0.0 -\u0026gt; 1.1.0 (*) | | | | | \\--- androidx.customview:customview:1.0.0 (*) | | | | \\--- androidx.collection:collection:1.0.0 -\u0026gt; 1.1.0 (*) | | | +--- androidx.cardview:cardview:1.0.0 | | | | \\--- androidx.annotation:annotation:1.0.0 -\u0026gt; 1.1.0 | | | +--- androidx.coordinatorlayout:coordinatorlayout:1.1.0 | | | | +--- androidx.annotation:annotation:1.1.0 | | | | +--- androidx.core:core:1.1.0 (*) | | | | +--- androidx.customview:customview:1.0.0 (*) | | | | \\--- androidx.collection:collection:1.0.0 -\u0026gt; 1.1.0 (*) | | | +--- androidx.core:core:1.1.0 (*) | | | +--- androidx.fragment:fragment:1.0.0 -\u0026gt; 1.1.0 (*) | | | +--- androidx.lifecycle:lifecycle-runtime:2.0.0 -\u0026gt; 2.1.0 (*) | | | +--- androidx.recyclerview:recyclerview:1.0.0 -\u0026gt; 1.1.0 | | | | +--- androidx.annotation:annotation:1.1.0 | | | | +--- androidx.core:core:1.1.0 (*) | | | | +--- androidx.customview:customview:1.0.0 (*) | | | | \\--- androidx.collection:collection:1.0.0 -\u0026gt; 1.1.0 (*) | | | +--- androidx.transition:transition:1.2.0 | | | | +--- androidx.annotation:annotation:1.1.0 | | | | +--- androidx.core:core:1.0.1 -\u0026gt; 1.1.0 (*) | | | | \\--- androidx.collection:collection:1.0.0 -\u0026gt; 1.1.0 (*) | | | +--- androidx.vectordrawable:vectordrawable:1.1.0 (*) | | | \\--- androidx.viewpager2:viewpager2:1.0.0 | | | +--- androidx.annotation:annotation:1.1.0 | | | +--- androidx.fragment:fragment:1.1.0 (*) | | | +--- androidx.recyclerview:recyclerview:1.1.0 (*) | | | +--- androidx.core:core:1.1.0 (*) | | | \\--- androidx.collection:collection:1.1.0 (*) | | +--- androidx.cardview:cardview:1.0.0 (*) | | \\--- androidx.appcompat:appcompat:1.1.0 (*) | +--- androidx.constraintlayout:constraintlayout:1.1.3 (*) | +--- com.google.android.material:material:1.1.0 (*) | +--- androidx.cardview:cardview:1.0.0 (*) | \\--- androidx.appcompat:appcompat:1.1.0 (*) +--- project :lib1 | +--- project :lib3 | | +--- androidx.constraintlayout:constraintlayout:1.1.3 (*) | | +--- com.google.android.material:material:1.1.0 (*) | | +--- androidx.cardview:cardview:1.0.0 (*) | | \\--- androidx.appcompat:appcompat:1.1.0 (*) | +--- androidx.constraintlayout:constraintlayout:1.1.3 (*) | +--- com.google.android.material:material:1.1.0 (*) | +--- androidx.cardview:cardview:1.0.0 (*) | \\--- androidx.appcompat:appcompat:1.1.0 (*) +--- androidx.constraintlayout:constraintlayout:1.1.3 (*) +--- com.google.android.material:material:1.1.0 (*) +--- androidx.cardview:cardview:1.0.0 (*) +--- androidx.appcompat:appcompat:1.1.0 (*) \\--- com.didiglobal.booster:booster-android-instrument-toast:3.1.0 \\--- com.didiglobal.booster:booster-android-instrument:3.1.0 可以看出来app的module先是依赖了lib和lib1这两个module，并且lib这个module又依赖了lib2，lib1依赖了lib3，所以资源合并的时候，优先使用lib和lib2中的资源。 关于更多依赖的gradle命令：\n1 2 //查看编译时的依赖，它只会看直接依赖的子module，间接依赖的子module不会查看 ./gradlew app:dependencies --configuration debugCompileClasspath 1 2 //它会输出debug、release、test、compile、runtime组合的依赖 ./gradlew app:dependencies 注：下面介绍的R内联插件是在booster3.1.0版本上 介绍完上面资源文件引用问题，我们发现随着module和aar越来越多的时候，R.class的数量会急剧增加，导致包体积急增。那booster是怎么解决这个R.class剧增的呢？ 它是通过把子module的R.class中定义的变量都删除掉，然后子module中的代码引用的资源变量会直接被R.txt中定义的常量值所代替。这就是R文件内联的过程。那下面就分析下这个过程怎么实现的，前面介绍过各个插件是通过自己的ClassTransformer来实现字节码修改，其中R文件内联的插件是通过RInlineTransformer实现的，首先看下onPreTransform中的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 override fun onPreTransform(context: TransformContext) { this.appPackage = context.originalApplicationId.replace(\u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;) //①解析R.txt，生成sybols信息 this.symbols = SymbolList.from(context.artifacts.get(SYMBOL_LIST).single()) this.appRStyleable = \u0026#34;$appPackage/$R_STYLEABLE\u0026#34; this.ignores = context.getProperty(PROPERTY_IGNORES)?.split(\u0026#39;,\u0026#39;)?.map { Wildcard(it) }?.toSet() ?: emptySet() //②忽略constrainlayout中的id属性 val retainedSymbols: Set\u0026lt;String\u0026gt; val classpath = context.compileClasspath.map { it.absolutePath } if (classpath.any { it.contains(PREFIX_SUPPORT_CONSTRAINT_LAYOUT) || it.contains(PREFIX_JETPACK_CONSTRAINT_LAYOUT) }) { // Find symbols that should be retained retainedSymbols = context.findRetainedSymbols() if (retainedSymbols.isNotEmpty()) { this.ignores += setOf(Wildcard.valueOf(\u0026#34;android/support/constraint/R\\$id\u0026#34;)) this.ignores += setOf(Wildcard.valueOf(\u0026#34;androidx/constraintlayout/R\\$id\u0026#34;)) } } else { retainedSymbols = emptySet() } } 在onPreTransform①处首先解析R.txt文件，文章开头已经介绍过该文件，它主要是用来存储资源文件合并后的信息。在②处会忽略ConstrainLayout中的R.id.**的变量，因为在 ConstraintLayout 中，R.id.xxx 可能会被 ConstraintSet 或者其他代码 动态解析，比如：\n1 2 3 val constraintSet = ConstraintSet() constraintSet.clone(constraintLayout) constraintSet.connect(R.id.viewA, ConstraintSet.START, R.id.viewB, ConstraintSet.END) Booster 进行 代码压缩/重排 时，如果对 R.id.xxx 进行了内联或优化，可能会导致 ID 失效，进而导致约束布局无法正常工作。接着看下transform方法，它是操作字节码的关键方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 override fun transform(context: TransformContext, klass: ClassNode): ClassNode { if (this.symbols.isEmpty()) { return klass } if (this.ignores.any { it.matches(klass.name) }) { logger.println(\u0026#34;Ignore `${klass.name}`\u0026#34;) } else if (Pattern.matches(R_REGEX, klass.name) \u0026amp;\u0026amp; klass.name != appRStyleable) { //通过正则匹配删除R$color这种内部类的所有属性 klass.fields.clear() removedR[klass.name] = klass.bytes() } else { //如果是代码中调用了R.color.**这种，直接操作字节码 klass.replaceSymbolReferenceWithConstant() } return klass } 在transform方法中，通过正则匹配删除R$color这种内部类的所有属性，如果不是R$color这种内部类，则通过扩展函数replaceSymbolReferenceWithConstant直接操作字节码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 private fun ClassNode.replaceSymbolReferenceWithConstant() { methods.forEach { method -\u0026gt; //①：通过方法的指令集来过滤 val insns = method.instructions.iterator().asIterable().filter { //②：如果当前指令是getstatic it.opcode == GETSTATIC }.map { it as FieldInsnNode }.filter { //③：返回值是int类型并且是以**R$开头获取R文件中的常量形式并且不是以android内部的R开头的话 (\u0026#34;I\u0026#34; == it.desc || \u0026#34;[I\u0026#34; == it.desc) \u0026amp;\u0026amp; it.owner.substring(it.owner.lastIndexOf(\u0026#39;/\u0026#39;) + 1).startsWith(\u0026#34;R$\u0026#34;) \u0026amp;\u0026amp; !(it.owner.startsWith(COM_ANDROID_INTERNAL_R) || it.owner.startsWith(ANDROID_R)) } //④：过滤出返回值为int类型的指令 val intFields = insns.filter { \u0026#34;I\u0026#34; == it.desc } val intArrayFields = insns.filter { \u0026#34;[I\u0026#34; == it.desc } intFields.forEach { field -\u0026gt; //⑤：获取R文件的资源类型 val type = field.owner.substring(field.owner.lastIndexOf(\u0026#34;/R$\u0026#34;) + 3) try { //⑥：在获取R中常量指令之前插入常量的指令，LdcInsnNode中的参数是获取这个常量值 method.instructions.insertBefore(field, LdcInsnNode(symbols.getInt(type, field.name))) //⑦：移除当前获取变量的指令 method.instructions.remove(field) } catch (e: NullPointerException) { logger.println(\u0026#34;Unresolvable symbol `R.$type.${field.name}` : $name.${method.name}${method.desc}\u0026#34;) } } //⑧：int数组类型的指令直接把owner替换成app目录的包名 intArrayFields.forEach { field -\u0026gt; field.owner = \u0026#34;$appPackage/${field.owner.substring(field.owner.lastIndexOf(\u0026#39;/\u0026#39;) + 1)}\u0026#34; } } } 在上面字节码操作如果不太熟悉的话，我们可以在library模块中定义类去获取R中的资源，比如我下面定义一个TestView，获取自己的R中的color属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class TestView extends View { public TestView(Context context) { this(context, null); } public TestView(Context context, @Nullable AttributeSet attrs) { this(context, attrs, 0); } public TestView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); setBackgroundColor(getResources().getColor(R.color.black_bg)); } } 上面获取R.color.black_bg，那此处会用booster的R内联给替换成常量，怎么替换，先肯定是找到这个指令对不？看下此处的指令，我们通过jclasslib bytecode viewer来查看编译后的class：\n1 2 3 4 5 6 7 8 9 10 11 12 0 aload_0 1 aload_1 2 aload_2 3 iload_3 4 invokespecial #3 \u0026lt;android/view/View.\u0026lt;init\u0026gt; : (Landroid/content/Context;Landroid/util/AttributeSet;I)V\u0026gt; 7 aload_0 8 aload_0 9 invokevirtual #4 \u0026lt;com/xc/lib/TestView.getResources : ()Landroid/content/res/Resources;\u0026gt; 12 getstatic #5 \u0026lt;com/xc/lib/R$color.black_bg : I\u0026gt; 15 invokevirtual #6 \u0026lt;android/content/res/Resources.getColor : (I)I\u0026gt; 18 invokevirtual #7 \u0026lt;com/xc/lib/TestView.setBackgroundColor : (I)V\u0026gt; 21 return 在12行，通过getstatic来获取com/xc/lib/R$color.black_bg，返回类型是I，表示整形。所以上面①-④的操作就是在获取该指令，在⑤处获取该资源类型，上面TestView中是获取color类型的资源，在⑥处表示在该获取变量的指令前插入一条LdcInsnNode的常量指令，在⑦处移除当前获取变量的指令。在⑧处如果是int数组类型的指令直接把owner替换成app目录的包名。 结合修改后的字节码，查看TestView修改后的字节码，通过BytecodeViewer来查看编译后的class： 可以看到最终通过ldc指令来获取一个常量来替换之前获取R.color.black_bg变量。同时再来看下module下的R$color.class: 可以看到该内部类所有的属性被置为空了，包括主module下的R$color.class下的属性也是清空了。所以booster的方案是不区分主module还是lib的module。\n为什么R$styleable中的静态变量不会被移除？并且主module是原封不动，lib的module是只保留了数组类型的变量，并且是在static代码块中定义数组，并且数组的定于缺少public static final关键字：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 package com.xc.lib; public final class R$styleable { static { ActionBar = new int[]{2130903092, 2130903099, 2130903100, 2130903224, 2130903225, 2130903226, 2130903227, 2130903228, 2130903229, 2130903255, 2130903264, 2130903265, 2130903284, 2130903343, 2130903349, 2130903355, 2130903356, 2130903358, 2130903368, 2130903381, 2130903481, 2130903513, 2130903532, 2130903536, 2130903537, 2130903598, 2130903601, 2130903673, 2130903683}; ActionBarLayout = new int[]{16842931}; ActionMenuItemView = new int[]{16843071}; ActionMenuView = new int[0]; ActionMode = new int[]{2130903092, 2130903099, 2130903192, 2130903343, 2130903601, 2130903683}; ActivityChooserView = new int[]{2130903303, 2130903369}; AlertDialog = new int[]{16842994, 2130903142, 2130903143, 2130903470, 2130903471, 2130903510, 2130903566, 2130903568}; AnimatedStateListDrawableCompat = new int[]{16843036, 16843156, 16843157, 16843158, 16843532, 16843533}; AnimatedStateListDrawableItem = new int[]{16842960, 16843161}; AnimatedStateListDrawableTransition = new int[]{16843161, 16843849, 16843850, 16843851}; AppBarLayout = new int[]{16842964, 16843919, 16844096, 2130903284, 2130903304, 2130903462, 2130903463, 2130903592}; AppBarLayoutStates = new int[]{2130903586, 2130903587, 2130903589, 2130903590}; AppBarLayout_Layout = new int[]{2130903460, 2130903461}; AppCompatImageView = new int[]{16843033, 2130903578, 2130903671, 2130903672}; AppCompatSeekBar = new int[]{16843074, 2130903668, 2130903669, 2130903670}; AppCompatTextHelper = new int[]{16842804, 16843117, 16843118, 16843119, 16843120, 16843666, 16843667}; AppCompatTextView = new int[]{16842804, 2130903087, 2130903088, 2130903089, 2130903090, 2130903091, 2130903269, 2130903270, 2130903271, 2130903272, 2130903274, 2130903275, 2130903276, 2130903277, 2130903326, 2130903329, 2130903337, 2130903399, 2130903464, 2130903633, 2130903660}; AppCompatTheme = new int[]{16842839, 16842926, 2130903040, 2130903041, 2130903042, 2130903043, 2130903044, 2130903045, 2130903046, 2130903047, 2130903048, 2130903049, 2130903050, 2130903051, 2130903052, 2130903054, 2130903055, 2130903056, 2130903057, 2130903058, 2130903059, 2130903060, 2130903061, 2130903062, 2130903063, 2130903064, 2130903065, 2130903066, 2130903067, 2130903068, 2130903069, 2130903070, 2130903074, 2130903075, 2130903076, 2130903077, 2130903078, 2130903086, 2130903120, 2130903135, 2130903136, 2130903137, 2130903138, 2130903139, 2130903144, 2130903145, 2130903157, 2130903164, 2130903198, 2130903199, 2130903200, 2130903201, 2130903202, 2130903203, 2130903204, 2130903211, 2130903212, 2130903218, 2130903236, 2130903261, 2130903262, 2130903263, 2130903266, 2130903268, 2130903279, 2130903280, 2130903281, 2130903282, 2130903283, 2130903355, 2130903367, 2130903466, 2130903467, 2130903468, 2130903469, 2130903472, 2130903473, 2130903474, 2130903475, 2130903476, 2130903477, 2130903478, 2130903479, 2130903480, 2130903522, 2130903523, 2130903524, 2130903531, 2130903533, 2130903540, 2130903542, 2130903543, 2130903544, 2130903553, 2130903554, 2130903555, 2130903556, 2130903575, 2130903576, 2130903605, 2130903644, 2130903646, 2130903647, 2130903648, 2130903650, 2130903651, 2130903652, 2130903653, 2130903656, 2130903657, 2130903685, 2130903686, 2130903687, 2130903688, 2130903696, 2130903698, 2130903699, 2130903700, 2130903701, 2130903702, 2130903703, 2130903704, 2130903705, 2130903706, 2130903707}; Badge = new int[]{2130903093, 2130903103, 2130903105, 2130903505, 2130903515}; BottomAppBar = new int[]{2130903101, 2130903284, 2130903314, 2130903315, 2130903316, 2130903317, 2130903318, 2130903350}; BottomNavigationView = new int[]{2130903101, 2130903284, 2130903373, 2130903376, 2130903378, 2130903379, 2130903382, 2130903394, 2130903395, 2130903396, 2130903398, 2130903508}; BottomSheetBehavior_Layout = new int[]{16843840, 2130903101, 2130903111, 2130903112, 2130903113, 2130903114, 2130903116, 2130903117, 2130903118, 2130903557, 2130903560}; ButtonBarLayout = new int[]{2130903079}; CardView = new int[]{16843071, 16843072, 2130903148, 2130903149, 2130903150, 2130903152, 2130903153, 2130903154, 2130903230, 2130903231, 2130903232, 2130903233, 2130903234}; Chip = new int[]{16842804, 16842904, 16842923, 16843039, 16843087, 16843237, 2130903160, 2130903161, 2130903163, 2130903165, 2130903166, 2130903167, 2130903169, 2130903170, 2130903171, 2130903172, 2130903173, 2130903174, 2130903175, 2130903180, 2130903181, 2130903182, 2130903184, 2130903185, 2130903186, 2130903187, 2130903188, 2130903189, 2130903190, 2130903191, 2130903296, 2130903348, 2130903359, 2130903363, 2130903547, 2130903557, 2130903560, 2130903564, 2130903658, 2130903661}; ChipGroup = new int[]{2130903159, 2130903176, 2130903177, 2130903178, 2130903569, 2130903570}; CollapsingToolbarLayout = new int[]{2130903195, 2130903196, 2130903235, 2130903305, 2130903306, 2130903307, 2130903308, 2130903309, 2130903310, 2130903311, 2130903548, 2130903550, 2130903593, 2130903673, 2130903674, 2130903684}; CollapsingToolbarLayout_Layout = new int[]{2130903405, 2130903406}; ColorStateListItem = new int[]{16843173, 16843551, 2130903080}; CompoundButton = new int[]{16843015, 2130903140, 2130903146, 2130903147}; ConstraintLayout_Layout = new int[]{16842948, 16843039, 16843040, 16843071, 16843072, 2130903107, 2130903108, 2130903156, 2130903220, 2130903221, 2130903407, 2130903408, 2130903409, 2130903410, 2130903411, 2130903412, 2130903413, 2130903414, 2130903415, 2130903416, 2130903417, 2130903418, 2130903419, 2130903420, 2130903421, 2130903422, 2130903423, 2130903424, 2130903425, 2130903426, 2130903427, 2130903428, 2130903429, 2130903430, 2130903431, 2130903432, 2130903433, 2130903434, 2130903435, 2130903436, 2130903437, 2130903438, 2130903439, 2130903440, 2130903441, 2130903442, 2130903443, 2130903444, 2130903445, 2130903446, 2130903447, 2130903449, 2130903450, 2130903451, 2130903452, 2130903453, 2130903454, 2130903455, 2130903456, 2130903459}; ConstraintLayout_placeholder = new int[]{2130903222, 2130903287}; ConstraintSet = new int[]{16842948, 16842960, 16842972, 16842996, 16842997, 16842999, 16843000, 16843001, 16843002, 16843039, 16843040, 16843071, 16843072, 16843551, 16843552, 16843553, 16843554, 16843555, 16843556, 16843557, 16843558, 16843559, 16843560, 16843701, 16843702, 16843770, 16843840, 2130903107, 2130903108, 2130903156, 2130903221, 2130903407, 2130903408, 2130903409, 2130903410, 2130903411, 2130903412, 2130903413, 2130903414, 2130903415, 2130903416, 2130903417, 2130903418, 2130903419, 2130903420, 2130903421, 2130903422, 2130903423, 2130903424, 2130903425, 2130903426, 2130903427, 2130903428, 2130903429, 2130903430, 2130903431, 2130903432, 2130903433, 2130903434, 2130903435, 2130903436, 2130903437, 2130903438, 2130903439, 2130903440, 2130903441, 2130903442, 2130903443, 2130903444, 2130903445, 2130903446, 2130903447, 2130903449, 2130903450, 2130903451, 2130903452, 2130903453, 2130903454, 2130903455, 2130903456}; CoordinatorLayout = new int[]{2130903397, 2130903591}; CoordinatorLayout_Layout = new int[]{16842931, 2130903402, 2130903403, 2130903404, 2130903448, 2130903457, 2130903458}; DrawerArrowToggle = new int[]{2130903084, 2130903085, 2130903106, 2130903197, 2130903273, 2130903340, 2130903574, 2130903664}; ExtendedFloatingActionButton = new int[]{2130903284, 2130903312, 2130903348, 2130903564, 2130903567}; ExtendedFloatingActionButton_Behavior_Layout = new int[]{2130903109, 2130903110}; FloatingActionButton = new int[]{2130903101, 2130903102, 2130903119, 2130903284, 2130903296, 2130903319, 2130903320, 2130903348, 2130903357, 2130903506, 2130903535, 2130903547, 2130903557, 2130903560, 2130903564, 2130903694}; FloatingActionButton_Behavior_Layout = new int[]{2130903109}; FlowLayout = new int[]{2130903390, 2130903465}; FontFamily = new int[]{2130903330, 2130903331, 2130903332, 2130903333, 2130903334, 2130903335}; FontFamilyFont = new int[]{16844082, 16844083, 16844095, 16844143, 16844144, 2130903328, 2130903336, 2130903337, 2130903338, 2130903693}; ForegroundLinearLayout = new int[]{16843017, 16843264, 2130903339}; GradientColor = new int[]{16843165, 16843166, 16843169, 16843170, 16843171, 16843172, 16843265, 16843275, 16844048, 16844049, 16844050, 16844051}; GradientColorItem = new int[]{16843173, 16844052}; LinearConstraintLayout = new int[]{16842948}; LinearLayoutCompat = new int[]{16842927, 16842948, 16843046, 16843047, 16843048, 2130903265, 2130903267, 2130903507, 2130903563}; LinearLayoutCompat_Layout = new int[]{16842931, 16842996, 16842997, 16843137}; ListPopupWindow = new int[]{16843436, 16843437}; MaterialAlertDialog = new int[]{2130903094, 2130903095, 2130903096, 2130903097}; MaterialAlertDialogTheme = new int[]{2130903483, 2130903484, 2130903485, 2130903486, 2130903487}; MaterialButton = new int[]{16843191, 16843192, 16843193, 16843194, 16843237, 2130903101, 2130903102, 2130903243, 2130903284, 2130903358, 2130903360, 2130903361, 2130903362, 2130903364, 2130903365, 2130903547, 2130903557, 2130903560, 2130903594, 2130903595}; MaterialButtonToggleGroup = new int[]{2130903158, 2130903570}; MaterialCalendar = new int[]{16843277, 2130903256, 2130903257, 2130903258, 2130903259, 2130903541, 2130903708, 2130903709, 2130903710}; MaterialCalendarItem = new int[]{16843191, 16843192, 16843193, 16843194, 2130903374, 2130903383, 2130903384, 2130903391, 2130903392, 2130903396}; MaterialCardView = new int[]{16843237, 2130903151, 2130903160, 2130903162, 2130903547, 2130903557, 2130903560, 2130903588, 2130903594, 2130903595}; MaterialCheckBox = new int[]{2130903146, 2130903695}; MaterialRadioButton = new int[]{2130903695}; MaterialShape = new int[]{2130903557, 2130903560}; MaterialTextAppearance = new int[]{16844159, 2130903464}; MaterialTextView = new int[]{16842804, 16844159, 2130903464}; MenuGroup = new int[]{16842766, 16842960, 16843156, 16843230, 16843231, 16843232}; MenuItem = new int[]{16842754, 16842766, 16842960, 16843014, 16843156, 16843230, 16843231, 16843233, 16843234, 16843235, 16843236, 16843237, 16843375, 2130903053, 2130903071, 2130903073, 2130903081, 2130903223, 2130903364, 2130903365, 2130903516, 2130903562, 2130903689}; MenuView = new int[]{16842926, 16843052, 16843053, 16843054, 16843055, 16843056, 16843057, 2130903534, 2130903596}; NavigationView = new int[]{16842964, 16842973, 16843039, 2130903284, 2130903342, 2130903373, 2130903375, 2130903377, 2130903378, 2130903379, 2130903380, 2130903383, 2130903384, 2130903385, 2130903386, 2130903387, 2130903388, 2130903389, 2130903393, 2130903396, 2130903508}; PopupWindow = new int[]{16843126, 16843465, 2130903517}; PopupWindowBackgroundState = new int[]{2130903585}; RecycleListView = new int[]{2130903518, 2130903521}; RecyclerView = new int[]{16842948, 16842987, 16842993, 2130903321, 2130903322, 2130903323, 2130903324, 2130903325, 2130903401, 2130903546, 2130903573, 2130903579}; ScrimInsetsFrameLayout = new int[]{2130903370}; ScrollingViewBehavior_Layout = new int[]{2130903115}; SearchView = new int[]{16842970, 16843039, 16843296, 16843364, 2130903185, 2130903219, 2130903260, 2130903341, 2130903366, 2130903400, 2130903538, 2130903539, 2130903551, 2130903552, 2130903597, 2130903602, 2130903697}; ShapeAppearance = new int[]{2130903238, 2130903239, 2130903240, 2130903241, 2130903242, 2130903244, 2130903245, 2130903246, 2130903247, 2130903248}; Snackbar = new int[]{2130903571, 2130903572}; SnackbarLayout = new int[]{16843039, 2130903072, 2130903082, 2130903098, 2130903284, 2130903503}; Spinner = new int[]{16842930, 16843126, 16843131, 16843362, 2130903532}; StateListDrawable = new int[]{16843036, 16843156, 16843157, 16843158, 16843532, 16843533}; StateListDrawableItem = new int[]{16843161}; SwitchCompat = new int[]{16843044, 16843045, 16843074, 2130903565, 2130903577, 2130903603, 2130903604, 2130903606, 2130903665, 2130903666, 2130903667, 2130903690, 2130903691, 2130903692}; SwitchMaterial = new int[]{2130903695}; TabItem = new int[]{16842754, 16842994, 16843087}; TabLayout = new int[]{2130903607, 2130903608, 2130903609, 2130903610, 2130903611, 2130903612, 2130903613, 2130903614, 2130903615, 2130903616, 2130903617, 2130903618, 2130903619, 2130903620, 2130903621, 2130903622, 2130903623, 2130903624, 2130903625, 2130903626, 2130903627, 2130903628, 2130903630, 2130903631, 2130903632}; TextAppearance = new int[]{16842901, 16842902, 16842903, 16842904, 16842906, 16842907, 16843105, 16843106, 16843107, 16843108, 16843692, 16844165, 2130903329, 2130903337, 2130903633, 2130903660}; TextInputLayout = new int[]{16842906, 16843088, 2130903125, 2130903126, 2130903127, 2130903128, 2130903129, 2130903130, 2130903131, 2130903132, 2130903133, 2130903134, 2130903249, 2130903250, 2130903251, 2130903252, 2130903253, 2130903254, 2130903288, 2130903289, 2130903290, 2130903291, 2130903292, 2130903293, 2130903297, 2130903298, 2130903299, 2130903300, 2130903301, 2130903302, 2130903344, 2130903345, 2130903346, 2130903347, 2130903351, 2130903352, 2130903353, 2130903354, 2130903525, 2130903526, 2130903527, 2130903528, 2130903529, 2130903557, 2130903560, 2130903580, 2130903581, 2130903582, 2130903583, 2130903584}; ThemeEnforcement = new int[]{16842804, 2130903294, 2130903295}; Toolbar = new int[]{16842927, 16843072, 2130903141, 2130903193, 2130903194, 2130903224, 2130903225, 2130903226, 2130903227, 2130903228, 2130903229, 2130903481, 2130903482, 2130903504, 2130903508, 2130903511, 2130903512, 2130903532, 2130903598, 2130903599, 2130903600, 2130903673, 2130903675, 2130903676, 2130903677, 2130903678, 2130903679, 2130903680, 2130903681, 2130903682}; View = new int[]{16842752, 16842970, 2130903519, 2130903520, 2130903662}; ViewBackgroundHelper = new int[]{16842964, 2130903101, 2130903102}; ViewPager2 = new int[]{16842948}; ViewStubCompat = new int[]{16842960, 16842994, 16842995}; } private R$styleable() { } } 下面测试下R.styleable结果在class中的体现： 可以看到在lib中引用到的styleable数组属性被替换成主module中的属性了。lib的R.class中只有R$styleable的数组属性，并且在静态代码块中。\n","date":"2025-02-28T00:00:00Z","permalink":"https://example.com/p/booster%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96%E4%B9%8Br%E5%86%85%E8%81%94/","title":"booster包体积优化之R内联"},{"content":"创建脚本 首先在终端下创建一个脚本文件\n1 touch apkcompare 给脚本赋予执行权限 1 chmod +x apkcompare 打开脚本 使用zsh中装的sublime插件打开脚本文件\n1 st apkcompare 编辑脚本内容 1 2 3 4 5 6 7 #!/bin/bash echo \u0026#34;请输入改变前的apk路径：\u0026#34; read path1 echo \u0026#34;请输入改变后的apk路径：\u0026#34; read path2 cd /Users/xiangcheng/downloads java -jar apkcompare-1.0.jar $path1 $path2 compare_result_file 执行脚本 1 ./apkcompare 如何全局能执行脚本 上面执行脚本要到指定的目录才行，如果我想全局都能运行脚本的话，可以通过配置脚本的根目录的环境变量，比如我的脚本都放在了desktop/脚本文件夹中，那么我可以在.zshrc中配置如下：\n1 export PATH=\u0026#34;$HOME/desktop/脚本:$PATH\u0026#34; 将脚本定制成应用 平时使用shell脚本的时候，每次都要找到shell脚本的执行文件非常麻烦，然后想到如果能将shell脚本制作成一个应用那就非常nice了。 下面就以平时用的比较多的反编译脚本jadx为例来实践。\n先通过Alfred工具搜索出本机的Automator工具： 选取应用程序 添加shell脚本 在左侧搜索 “运行 Shell 脚本”（Run Shell Script）。 拖动到右侧工作区。 在 Shell 选项里，选择 /bin/bash（或 /bin/zsh）。 在文本框里输入如下代码： 1 2 #!/bin/bash /opt/homebrew/Cellar/jadx/1.5.1/bin/jadx-gui 我是通过homebrew装的jadx工具，所以指定下自己的jadx目录。\n保存应用 给应用定制图标 mac下应用的图标都是通过应用下的Info.plist文件来控制的： 它是通过CFBundleIconFile字段控制的，这里我把图标放在了应用的Resources文件下： 可以看到需要一个.icns的文件，这里我是通过在线网站https://cloudconvert.com/png-to-icns来实现png-\u0026gt;icns的。一切替换完后，还需要刷新 Launch Services，否则 macOS 可能不会立刻识别新图标，执行如下脚本：\n1 2 touch /Applications/Jadx.app killall Finder 我在chatgpt搜索的时候，它是通过touch ~/Applications/Jadx.app来执行的，但是我发现我的Jadx.app是在如下目录： 所以不用定位到Users/用户名，要不然会报错找不到Jadx应用。这里提一句mac下~表示的目录是Users/用户名，比如我的如下： 操作完后，一个带图标的shell脚本的应用就创建成功了。\n我的脚本工具集 apk比对脚本： apkcompare\n字节码查看脚本： bytecode-viewer\n批量删除指定后缀的图片脚本： delete_images\n反编译apk的脚本： jadx\n","date":"2025-02-19T00:00:00Z","permalink":"https://example.com/p/mac%E4%B8%8B%E5%BF%AB%E9%80%9F%E5%86%99%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/","title":"mac下快速写一个脚本"},{"content":"booster是基于gradle transform、asm进行字节码操作的框架，内部有很多gradle transform来操作对应的字节码，首先我们将对应的插件依赖进来，我们以toast插件替换为测试，看下效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 buildscript { ext { plugin_version = \u0026#34;0.3.0\u0026#34; booster_version = \u0026#34;1.0.0\u0026#34; } // ext.plugin_version = \u0026#34;0.3.0\u0026#34; repositories { google() jcenter() maven { url \u0026#34;https://artifact.bytedance.com/repository/byteX/\u0026#34; } } dependencies { classpath \u0026#39;com.android.tools.build:gradle:3.5.3\u0026#39; //booster classpath \u0026#34;com.didiglobal.booster:booster-gradle-plugin:$booster_version\u0026#34; //booster toast插件 classpath \u0026#34;com.didiglobal.booster:booster-transform-toast:$booster_version\u0026#34; //bytex base // classpath \u0026#34;com.bytedance.android.byteX:base-plugin:${plugin_version}\u0026#34; // Add bytex plugins\u0026#39; dependencies on demand. 按需添加插件依赖 // classpath \u0026#34;com.bytedance.android.byteX:method-call-opt-plugin:${plugin_version}\u0026#34; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } 然后使用插件：\n1 2 apply plugin: \u0026#39;com.android.application\u0026#39; apply plugin: \u0026#39;com.didiglobal.booster\u0026#39; // ③ 在MainActivity中添加如下代码： 然后看编译后的类，这里有个细节，大家得熟悉打包流程，javac编译成class后，然后把class转化成dex文件，transform就是作用于class转成dex之间，所以如果看javac之后的class是看不到最终toast插件作用的效果，需要反编译看最终的apk或者dex文件： 可以看到此时是替换成了ShadowToast中的show方法了。下面结合源码看下booster如何做到class替换的，本次通过gradle下载的插件源码来分析，booster插件下载的地址在/Users/xiangcheng/.gralde/cache/modules-2/files-2.1/com.didiglobal.booster下： booster-gradle-plugin 是booster定义插件的模块，下面打开它的源码，找到它的plugin： booster插件对应的类名是com.didiglobal.booster.gradle.BoosterPlugin:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package com.didiglobal.booster.gradle import com.android.build.gradle.AppExtension import com.android.build.gradle.LibraryExtension import com.didiglobal.booster.task.spi.VariantProcessor import org.gradle.api.Plugin import org.gradle.api.Project import java.util.ServiceLoader /** * Represents the booster gradle plugin * * @author johnsonlee */ class BoosterPlugin : Plugin\u0026lt;Project\u0026gt; { override fun apply(project: Project) { when { //如果依赖booster插件的module是application类型 project.plugins.hasPlugin(\u0026#34;com.android.application\u0026#34;) || project.plugins.hasPlugin(\u0026#34;com.android.dynamic-feature\u0026#34;) -\u0026gt; project.getAndroid\u0026lt;AppExtension\u0026gt;().let { android -\u0026gt; //注册BoosterAppTransform android.registerTransform(BoosterAppTransform()) //project.afterEvaluate监听module配置阶段完成后 project.afterEvaluate { //通过ServiceLoader来找到所有的VariantProcessor子类，它是spi模块中定义的 ServiceLoader.load(VariantProcessor::class.java, javaClass.classLoader).toList().let { processors -\u0026gt; //首先遍历应用中所有的变体 android.applicationVariants.forEach { variant -\u0026gt; //遍历所有的VariantProcessor，把变体传到VariantProcessor的process方法中 processors.forEach { processor -\u0026gt; processor.process(variant) } } } } } //如果依赖booster插件的module是library类型 project.plugins.hasPlugin(\u0026#34;com.android.library\u0026#34;) -\u0026gt; project.getAndroid\u0026lt;LibraryExtension\u0026gt;().let { android -\u0026gt; //BoosterLibTransform android.registerTransform(BoosterLibTransform()) project.afterEvaluate { ServiceLoader.load(VariantProcessor::class.java, javaClass.classLoader).toList().let { processors -\u0026gt; android.libraryVariants.forEach { variant -\u0026gt; processors.forEach { processor -\u0026gt; processor.process(variant) } } } } } } } } 我们只看当前module是application类型的，library类型的module处理基本一致。首先注册BoosterAppTransform，然后监听project配置阶段完成，然后通过ServiceLoader找到所有的VariantProcessor子类，它是task.spi模块下的一个接口，然后调用所有子类的process方法，先来看下VariantProcessor接口的定义：\n1 2 3 4 5 6 7 8 9 package com.didiglobal.booster.task.spi import com.android.build.gradle.api.BaseVariant interface VariantProcessor { fun process(variant: BaseVariant) } 比如在toast模块下有如下子类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.didiglobal.booster.transform.toast import com.android.build.gradle.api.BaseVariant import com.android.build.gradle.api.LibraryVariant import com.didiglobal.booster.gradle.isDynamicFeature import com.didiglobal.booster.gradle.scope import com.didiglobal.booster.gradle.variantData import com.didiglobal.booster.task.spi.VariantProcessor import com.google.auto.service.AutoService @AutoService(VariantProcessor::class) class ToastVariantProcessor : VariantProcessor { override fun process(variant: BaseVariant) { //如果变体不是LibraryVariant，LibraryVariant只出现在library的module中，并且变体不是一个动态模块，动态模块是Android App Bundle(.aab)结构中一的一部分，允许按需下载和安装模块，然后添加instrument-toast的aar依赖 if (variant !is LibraryVariant \u0026amp;\u0026amp; !variant.variantData.isDynamicFeature()) { variant.scope.globalScope.project.dependencies.add(\u0026#34;implementation\u0026#34;, \u0026#34;${Build.GROUP}:booster-android-instrument-toast:${Build.VERSION}\u0026#34;) } } } 通过AutoService注解找到ToastVariantProcessor这个子类，而上面分析boosterPlugin的时候，VariantProcessor的process方法是在配置完后调用的，也就是每一个module的build.gradle解析完事之后。ToastVariantProcessor中的process方法判断如果变体不是LibraryVariant，LibraryVariant只出现在library的module中，并且变体不是一个动态模块，动态模块是Android App Bundle(.aab)结构中一的一部分，允许按需下载和安装模块，然后添加instrument-toast的aar依赖。\n来看下booster-android-instrument-toast的主要构成： 这不就是上面要将Toast的调用要替换成目标ShadowToast类吗？所以不难看出，其实对应的booster-android-instrument-toast模块就是将ShadowToast引入进来，方便asm操作字节码的时候能够替换，下面来看下如何替换的字节码。\n我们回到上面注册的BoosterAppTransform，它是核心流程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.didiglobal.booster.gradle import com.android.build.api.transform.QualifiedContent /** * Represents android transform for application project * * @author johnsonlee */ class BoosterAppTransform : BoosterTransform() { override fun getScopes(): MutableSet\u0026lt;in QualifiedContent.Scope\u0026gt; = SCOPE_FULL_WITH_FEATURES } 它是继承自BoosterTransform，所以接着看BoosterTransform的transform方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 final override fun transform(invocation: TransformInvocation?) { invocation?.let { //BoosterTransformInvocation是一个代理类 BoosterTransformInvocation(it).apply { //① dumpInputs(this) //② if (isIncremental) { //③ onPreTransform(this) doIncrementalTransform() } else { buildDir.file(AndroidProject.FD_INTERMEDIATES, \u0026#34;transforms\u0026#34;, \u0026#34;dexBuilder\u0026#34;).let { dexBuilder -\u0026gt; if (dexBuilder.exists()) { dexBuilder.deleteRecursively() } } outputProvider.deleteAll() onPreTransform(this) doFullTransform() } //④ this.onPostTransform(this) }.executor.apply { shutdown() awaitTermination(1, TimeUnit.MINUTES) } } } //将扫描到的jar写到inputs.txt文件中 private fun dumpInputs(invocation: BoosterTransformInvocation) { //invocation.context.temporaryDir：获取当前transform的临时目录，然后创建inputs.txt文件 invocation.context.temporaryDir.file(\u0026#34;inputs.txt\u0026#34;).touch().printWriter().use { printer -\u0026gt; invocation.inputs.flatMap { it.jarInputs }.map { it.file }.forEach(printer::println) } } 在transform方法中TransformInvocation对象是Transform核心类，它是获取所有class和输出class的处理类。接着将TransformInvocation代理到了BoosterTransformInvocation中，它是一个静态代理模式。在①处，dumpInputs方法将项目中使用到的jar都打印到transform的临时目录中的inputs.txt中： 不知道这个是干嘛的，可能是为了记录所有的jar吧。在②处，判断是不是增量编译，默认是增量的，在③处，调用了BoosterTransformInvocation的onPreTransform，接着调用了doIncrementalTransform，在④处，调用了onPostTransform，这些都是BoosterTransformInvocation的方法，注意了最后是调用了executor的shutdown和awaitTermination方法。此处的executor是一个ForkJoinPool。所以重点来到BoosterTransformInvocation：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 internal class BoosterTransformInvocation(private val delegate: TransformInvocation) : TransformInvocation, TransformContext, TransformListener, ArtifactManager { /* * Preload transformers as List to fix NoSuchElementException caused by ServiceLoader in parallel mode */ private val transformers = ServiceLoader.load(Transformer::class.java, javaClass.classLoader).toList() override fun onPreTransform(context: TransformContext) = transformers.forEach { it.onPreTransform(this) } @Suppress(\u0026#34;NON_EXHAUSTIVE_WHEN\u0026#34;) internal fun doIncrementalTransform() { //① this.inputs.parallelStream().forEach { input -\u0026gt; //② input.jarInputs.parallelStream().filter { it.status != NOTCHANGED }.forEach { jarInput -\u0026gt; when (jarInput.status) { REMOVED -\u0026gt; jarInput.file.delete() CHANGED, ADDED -\u0026gt; { //③ val root = outputProvider.getContentLocation(jarInput.name, jarInput.contentTypes, jarInput.scopes, Format.JAR) project.logger.info(\u0026#34;Transforming ${jarInput.file}\u0026#34;) //④ jarInput.file.transform(root) { bytecode -\u0026gt; //⑤ bytecode.transform(this) } } } } input.directoryInputs.parallelStream().forEach { dirInput -\u0026gt; val base = dirInput.file.toURI() dirInput.changedFiles.ifNotEmpty { it.forEach { file, status -\u0026gt; when (status) { REMOVED -\u0026gt; file.delete() ADDED, CHANGED -\u0026gt; { val root = outputProvider.getContentLocation(dirInput.name, dirInput.contentTypes, dirInput.scopes, Format.DIRECTORY) project.logger.info(\u0026#34;Transforming $file\u0026#34;) file.transform(File(root, base.relativize(file.toURI()).path)) { bytecode -\u0026gt; bytecode.transform(this) } } } } } } } } private fun ByteArray.transform(invocation: BoosterTransformInvocation): ByteArray { return transformers.fold(this) { bytes, transformer -\u0026gt; transformer.transform(invocation, bytes) } } override fun onPostTransform(context: TransformContext) = transformers.forEach { it.onPostTransform(this) } } 这里我把几个重点方法给搬过来了，BoosterTransformInvocation继承自TransformInvocation，而构造器中传入了BoosterTransform中的TransformInvocation，最终代理到了这个TransformInvocation。在onPreTransform中遍历Transformer，然后调用onPreTransform。 在doIncrementalTransform的①处中通过parallelStream遍历TransformInput集合，其中parallelStream是集合流的一种处理方式，它能并行遍历对象，一般适合大量数据的时候，在②处遍历TransformInput中的jarInputs，如果是REMOVED状态则直接删除，如果是更新、添加状态，则会走到③处，通过TransformOutputProvider获取到jar的输出路径。在④处拿到jar的file对象，然后调用扩展的transform，获取到jar中的byteArray。经过⑤处的byteArray的transform操作后，也就是字节码操作，然后在jar的transform中再写回到③中的root中。下面看下File的transform扩展方法是如何获取到byteArray，并回写到root中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Transform this file or directory to the output by the specified transformer * * @param output The output location * @param transformer The byte data transformer */ fun File.transform(output: File, transformer: (ByteArray) -\u0026gt; ByteArray = { it -\u0026gt; it }) { when { isDirectory -\u0026gt; { val base = this.toURI() this.search().forEach { it.transform(File(output, base.relativize(it.toURI()).path), transformer) } } isFile -\u0026gt; { when (output.extension.toLowerCase()) { //如果当前file是一个jar，① \u0026#34;jar\u0026#34; -\u0026gt; JarFile(this).use { //② it.transform(output, ::JarArchiveEntry, transformer) } //如果当前file是一个class，③ \u0026#34;class\u0026#34; -\u0026gt; inputStream().use { logger.info(\u0026#34;Transforming ${this.absolutePath}\u0026#34;) //④ it.transform(transformer).redirect(output) } else -\u0026gt; this.copyTo(output, true) } } else -\u0026gt; TODO(\u0026#34;Unexpected file: ${this.absolutePath}\u0026#34;) } } 整个transform方法，有两个参数一个是目标路径，第二个参数就是字节码操作的闭包。闭包返回的是ByteArray，也就是修改前的字节码数据。 在①处，如果当前File是一个jar的时候，会初始化一个JarFile，然后调用use扩展函数，其中use方法是对Closeable类型做的异常处理，流的关闭处理。在②处调用JarFile的transform扩展函数，其中JarFile是ZipFile的子类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 fun ZipFile.transform(output: File, entryFactory: (ZipEntry) -\u0026gt; ZipArchiveEntry = ::ZipArchiveEntry, transformer: (ByteArray) -\u0026gt; ByteArray = { it -\u0026gt; it }) { //① val creator = ParallelScatterZipCreator(Executors.newWorkStealingPool()) val entries = mutableSetOf\u0026lt;String\u0026gt;() //② entries().asSequence().forEach { entry -\u0026gt; //③ if (!entries.contains(entry.name)) { //④ val zae = entryFactory(entry) //⑤ val stream = InputStreamSupplier { when (entry.name.substringAfterLast(\u0026#39;.\u0026#39;, \u0026#34;\u0026#34;)) { //⑥ \u0026#34;class\u0026#34; -\u0026gt; getInputStream(entry).use { src -\u0026gt; logger.info(\u0026#34;Transforming ${this.name}!/${entry.name}\u0026#34;) src.transform(transformer).inputStream() } //⑦ else -\u0026gt; getInputStream(entry) } } //⑧ creator.addArchiveEntry(zae, stream) entries.add(entry.name) } else { logger.error(\u0026#34;Duplicated jar entry: ${this.name}!/${entry.name}\u0026#34;) } } //⑨ ZipArchiveOutputStream(output.touch()).use { it -\u0026gt; creator.writeTo(it) } } 在①处创建ParallelScatterZipCreator，它是多线程并行压缩多个文件，然后再合并到一个总的压缩文件中，常见的ZipOutputStream是单线程进行压缩所有的文件。在②处拿到ZipFile的entries数组，然后调用asSequence进行遍历，entries方法是一个ZipEntryIterator对象，其实它也有toList方法，在此处都是遍历，其实和list没有区别，Sequence区别是在处理中间操作符的时候不会创建临时的集合对象，比如map，filter等。在③主要是去重，在④处将ZipEntry转化成ZipArchiveEntry，方便给到ParallelScatterZipCreator。在⑤处构建InputStreamSupplier，它是一个接口，在get方法中返回InputStream，方便使用闭包。在⑥处通过ZipEntry获取到对应的inputStream，然后调用src（inputStream）的transform扩展方法，并把transformer闭包传入其中：\n1 2 3 fun InputStream.transform(transformer: (ByteArray) -\u0026gt; ByteArray): ByteArray { return transformer(readBytes()) } 可以看到通过InputStream的readBytes扩展方法获取到ByteArray：\n1 2 3 4 5 private fun InputStream.readBytes(estimatedSize: Int = DEFAULT_BUFFER_SIZE): ByteArray { val buffer = ByteArrayOutputStream(Math.max(estimatedSize, this.available())) copyTo(buffer) return buffer.toByteArray() } 其中最终通过构造ByteArrayOutputStream对象，然后调用InputStream的copyTo扩展方法将buffer复制到ByteArrayOutputStream中L\n1 2 3 4 5 6 7 8 9 10 11 private fun InputStream.copyTo(out: OutputStream, bufferSize: Int = DEFAULT_BUFFER_SIZE): Long { var bytesCopied: Long = 0 val buffer = ByteArray(bufferSize) var bytes = read(buffer) while (bytes \u0026gt;= 0) { out.write(buffer, 0, bytes) bytesCopied += bytes bytes = read(buffer) } return bytesCopied } 获取到file的byteArray后，交给了transformer进行修改字节码，剩下就是写回到目标路径中，回到上面ZipFile的transform⑥处，最终将ByteArray通过inputStream扩展方法转化成 ByteArrayInputStream：\n1 2 @kotlin.internal.InlineOnly public inline fun ByteArray.inputStream(): ByteArrayInputStream = ByteArrayInputStream(this) 所以最终的ByteArrayInputStream给到了⑤处InputStreamSupplier的get方法返回值了。在⑦中，如果不是class类型的entry，则不进行transform的闭包修改。在⑧处将修改后的InputStream添加到ParallelScatterZipCreator中，并添加到entries集合中，方便去重。在⑨处，通过ZipArchiveOutputStream的输出流回写到output目标文件中。整个修改并回写过程分为这9大步骤。关于file是目录结构和非目录结构中的class文件处理就不说了，代码很简单。\nBoosterTransformInvocation中全量编译过程就不分析了，和增量编译大差不差。\n小结： booster中修改字节码过程是在BoosterTransformInvocation中，它将具体的修改交给了Transformer的子类，其中修改步骤是先遍历TransformInput中JarInput和directoryInput的class文件，然后获取到class的byteArray，然后经过Transformer子类的transform方法修改byteArray，修改完后，再回写到原始class对应的目录中，这样就达到了修改并覆盖class的目的。\nbooster-transform-asm 前面分析了boosterPlugin中会遍历Transform的子类然后执行它的transform方法，其中AsmTransformer是实现了Transformer接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @AutoService(Transformer::class) class AsmTransformer : Transformer { /* * Preload transformers as List to fix NoSuchElementException caused by ServiceLoader in parallel mode */ private val transformers = ServiceLoader.load(ClassTransformer::class.java, javaClass.classLoader).toList() override fun transform(context: TransformContext, bytecode: ByteArray): ByteArray { return ClassWriter(ClassWriter.COMPUTE_MAXS).also { writer -\u0026gt; transformers.fold(ClassNode().also { klass -\u0026gt; ClassReader(bytecode).accept(klass, 0) }) { klass, transformer -\u0026gt; transformer.transform(context, klass) }.accept(writer) }.toByteArray() } override fun onPreTransform(context: TransformContext) { transformers.forEach { it.onPreTransform(context) } } override fun onPostTransform(context: TransformContext) { transformers.forEach { it.onPostTransform(context) } } } AsmTransformer通过AutoService注解被扫描到是Transformer的子类，我们将它的transform写成如下方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 override fun transform(context: TransformContext, bytecode: ByteArray): ByteArray { // ClassNode是ASM tree API的类 var classNode = ClassNode() val classReader = ClassReader(bytecode) // accept()方法，读取bytecode的相关.class信息赋值到classNode对象的相应字段 classReader.accept(classNode,0) transformers.foreach { transformer -\u0026gt; // 每次transform后，class的内容变化都缓存在classNodes中 // 注意此时的classNode对象的内容就是bytecode的内容，只是格式不同而已 transformer.transform(context, classNode) } //ClassWriter是ASM core API的类 ，专门用来写出修改后class的类 val classWriter = ClassWriter(ClassWriter.COMPUTE_MAXS) //将写好后的classNode回写到classWriter中 classNode.accept(classWriter) // classWriter把被洗礼后的classNode，即ClassNode对象， // 写成ByteArray返回到上层BoosterTransformInvocation return classWriter.toByteArray() } 小结: 可以发现asm字节码操作，基本都是模版代码，首先通过classReader读取到byteArray（在前面学习asm的时候，是通过FileInputStream来读取的），然后把class信息映射到classNode对象上。然后遍历字节码操作类，将要修改的classNode给到操作类，修改完后，将classNode同步到classWriter上，最后把修改后的byteArray回写到上层中。\nbooster-transform-toast 上面分析过会通过ClassTransformer的子类来修改字节码，toast字节码的修改是在ToastTransformer这个子类中，主要来看下它的transform方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 private const val TOAST = \u0026#34;android/widget/Toast\u0026#34; private const val SHADOW_TOAST = \u0026#34;com/didiglobal/booster/instrument/ShadowToast\u0026#34; override fun transform(context: TransformContext, klass: ClassNode): ClassNode { //① if (klass.name == SHADOW_TOAST) { return klass } klass.methods.forEach { method -\u0026gt; //② method.instructions?.iterator()?.asIterable()?.filterIsInstance(MethodInsnNode::class.java)?.filter { //③ it.opcode == Opcodes.INVOKEVIRTUAL \u0026amp;\u0026amp; it.name == \u0026#34;show\u0026#34; \u0026amp;\u0026amp; it.desc == \u0026#34;()V\u0026#34; \u0026amp;\u0026amp; (it.owner == TOAST || context.klassPool.get(TOAST).isAssignableFrom(it.owner)) }?.forEach { //④ it.optimize(klass, method) } } return klass } //⑤ private fun MethodInsnNode.optimize(klass: ClassNode, method: MethodNode) { logger.println(\u0026#34; * ${this.owner}.${this.name}${this.desc} =\u0026gt; $SHADOW_TOAST.apply(L$SHADOW_TOAST;)V: ${klass.name}.${method.name}${method.desc}\u0026#34;) this.owner = SHADOW_TOAST this.name = \u0026#34;show\u0026#34; this.desc = \u0026#34;(L$TOAST;)V\u0026#34; this.opcode = Opcodes.INVOKESTATIC this.itf = false } 上面transform方法中，在①处如果当前class是com/didiglobal/booster/instrument/ShadowToast，则不处理，在②处通过method.instructions拿到当前方法的所有的指令集，然后通过filterIsInstance过滤是方法调用指令，比如INVOKEVIRTUAL、INVOKESTATIC、INVOKESPECIAL 和 INVOKEINTERFACE，因为MethodInsnNode代表的是方法调用指令。所以在③处通过opcode、name、desc、owner来判断是不是要修改的字节码，我们可以通过工具来看下： 可以看到，修改前的字节码的opcode=invokevirtual，name=show，desc = ()V，owner = android/widget/Toast，所以通过上面的过滤条件，就能过滤出要修改的指令。在④处，调用了MethodInsnNode的扩展方法optimize，在⑤处就是修改字节码了，如果不知道修改后的字节码，我们可以借助工具查看： 可以看到最终的opcode= invokestatic，name = show，desc = (Landroid/widget/Toast;)V，owner = com/didiglobal/booster/instrument/ShadowToast。和上面optimize方法中修改的指令一样，新加了itf = false，表示新替换的owner是否是接口，此处的ShadowToast不是一个接口，所以为false，这就是替换指令的过程，是不是很简单。\n下面来实操一波，将某个类中的方法调用改成其它的方法调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.xc.asm; public class Main { public static void main(String[] args) { System.out.println(\u0026#34;Hello world!\u0026#34;); } public static void test(){ System.out.println(\u0026#34;Main中的test方法\u0026#34;); } public static void test1(){ System.out.println(\u0026#34;Main中的test1方法\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 package com.xc.asm; public class C { public void m() throws Exception { Thread.sleep(100); } public void n(){ Main.test(); } } 在C类中调用了Main类中的test静态方法，我们这里是想把调用test方法给替换成test1方法，话不多说，直接撸🐴：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class MethodReplaceTest { public static void main(String[] args) throws Exception { Class clazz = C.class; String clazzFilePath = Utils.getClassFilePath(clazz); ClassReader classReader = new ClassReader(new FileInputStream(clazzFilePath)); //ClassWriter.COMPUTE_FRAMES表示自动计算方法栈数 ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES); //通过构造一个新的classVisitor，然后将classWriter传入到该classVistor中，实际干活的还是classWriter，MethodReplaceClassVisitor只是作为一个代理类，进行添加属性 MethodReplaceClassVisitor methodReplaceClassVisitor = new MethodReplaceClassVisitor(Opcodes.ASM5, classWriter); classReader.accept(methodReplaceClassVisitor, 0); // 写入文件 byte[] bytes = classWriter.toByteArray(); FileOutputStream fos = new FileOutputStream(clazzFilePath); fos.write(bytes); fos.flush(); fos.close(); //验证结果 C c = new C(); c.n(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class MethodReplaceClassVisitor extends ClassVisitor { protected MethodReplaceClassVisitor(int api, ClassVisitor classVisitor) { super(api, classVisitor); } @Override public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) { MethodVisitor methodVisitor = super.visitMethod(access, name, descriptor, signature, exceptions); if(name.equals(\u0026#34;n\u0026#34;)){ return new MethodReplaceMethodVisitor(Opcodes.ASM5,methodVisitor); } return methodVisitor; } } 1 2 3 4 5 6 7 8 9 10 11 12 public class MethodReplaceMethodVisitor extends MethodVisitor { protected MethodReplaceMethodVisitor(int api, MethodVisitor methodVisitor) { super(api, methodVisitor); } @Override public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) { if (mv != null) { mv.visitMethodInsn(Opcodes.INVOKESTATIC,\u0026#34;com/xc/asm/Main\u0026#34;,\u0026#34;test1\u0026#34;,\u0026#34;()V\u0026#34;,false); } } } 关于asm的基础操作就不多说了，主要看下MethodReplaceMethodVisitor的visitMethodInsn方法是操作方法指令的，通过传进来的MethodVisitor，来进行修改指令，其中指令中的name字段传test1，其余的字段和原来调用test方法一致的。\n参考: 滴滴开源库Booster:架构运作及源码分析\n","date":"2025-02-17T00:00:00Z","permalink":"https://example.com/p/booster%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","title":"booster源码分析"},{"content":"gradle的很多插件涉及到了字节码修改，内部修改字节码基本都是通过asm来修改，本文章就是通过asm来修改class。本文基于intellij idea来体验的。\n下载依赖 首先我创建的工程是一个java工程，然后将项目配置成maven工程： 接着去maven官网找下对应依赖： 然后在工程里面添加依赖： 读取class 首先定义一个普通的类： 1 2 3 4 5 6 7 8 9 10 11 public class User { private String name;//Ljava/lang/String表示string类型 private int age;//I表示int类型 private long lang;//在class中J表示long类型 public String getName() { return name; } public int getAge() { return age; } } 读取到User类对应class的路径 1 2 3 4 5 6 7 8 9 public class Utils { public static String getClassFilePath(Class clazz) { // file:/Users/xiangcheng/IdeaProject/Asm/target/classes/ String buildDir = clazz.getProtectionDomain().getCodeSource().getLocation().getFile();//获取到文件所在位置 String fileName = clazz.getSimpleName() + \u0026#34;.class\u0026#34;; File file = new File(buildDir + clazz.getPackage().getName().replaceAll(\u0026#34;[.]\u0026#34;, \u0026#34;/\u0026#34;) + \u0026#34;/\u0026#34;, fileName); return file.getAbsolutePath(); } } 通过ClassReader获取到class的读取 1 2 3 4 Class clazz = User.class; String clazzFilePath = Utils.getClassFilePath(clazz); //首先通过class的路径获取到classReader，然后通过classReader的accept方法，传入一个classNode，然后使用classNode获取到方法和属性 ClassReader classReader = new ClassReader(new FileInputStream(clazzFilePath)); 通过classReader获取到classNode 1 2 ClassNode classNode = new ClassNode(Opcodes.ASM5); classReader.accept(classNode, 0); ClassNode读取方法和属性 1 2 3 4 5 6 7 8 9 10 List\u0026lt;MethodNode\u0026gt; methods = classNode.methods; List\u0026lt;FieldNode\u0026gt; fields = classNode.fields; System.out.println(\u0026#34;methods:\u0026#34;); for (MethodNode methodNode : methods) { System.out.println(methodNode.name + \u0026#34;, \u0026#34; + methodNode.desc); } System.out.println(\u0026#34;fields:\u0026#34;); for (FieldNode fieldNode : fields) { System.out.println(fieldNode.name + \u0026#34;, \u0026#34; + fieldNode.desc); } 获取信息如下：\n1 2 3 4 5 6 7 8 methods: \u0026lt;init\u0026gt;, ()V getName, ()Ljava/lang/String; getAge, ()I fields: name, Ljava/lang/String; age, I lang, J 我们通过jclasslib验证下： 其中属性的名字，描述符，访问标识都和上面的对应的上。方法也是如此。 上面是通过classNode树形结构访问的，下面通过visit回调的形式访问属性和方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Class clazz = User.class; String clazzFilePath = Utils.getClassFilePath(clazz); ClassReader classReader = new ClassReader(new FileInputStream(clazzFilePath)); //前面介绍的classNode是继承自classVisitor，classNode是把所有的方法和属性全部都读到内存中，然后再遍历，ClassVisitor边读边遍历 ClassVisitor classVisitor = new ClassVisitor(Opcodes.ASM5) { @Override public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) { System.out.println(\u0026#34;visit field:\u0026#34; + name + \u0026#34; , desc = \u0026#34; + descriptor); return super.visitField(access, name, descriptor, signature, value); } @Override public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) { System.out.println(\u0026#34;visit method:\u0026#34; + name + \u0026#34; , desc = \u0026#34; + descriptor); return super.visitMethod(access, name, descriptor, signature, exceptions); } }; classReader.accept(classVisitor, 0); 通过ClassVisitor也能访问到属性和方法，上面介绍的ClassNode是继承自ClassVisitor，ClassVisitor是边读边遍历，而ClassNode是把方法和属性全部都读到内存中，然后再遍历。\n修改class 上面介绍的都是读取class，我们最终的目的是修改class，下面也通过一个🌰来介绍如何修改class，还是先来一个类：\n1 2 3 4 5 6 7 public class C { public void m() throws Exception { Thread.sleep(100); } } 我们要把它修改成如下：\n1 2 3 4 5 6 7 8 9 public class C { public static long timer; public void m() throws Exception { timer -= System.currentTimeMillis(); Thread.sleep(100L); timer += System.currentTimeMillis(); } } asm修改字节码先通过ClassReader把class信息读取到，然后通过ClassWriter把修改后的class再写会到文件里面，先介绍下通过ClassWriter把class写到文件中：\n1 2 3 4 5 6 7 8 9 10 11 12 Class clazz = C.class; String clazzFilePath = Utils.getClassFilePath(clazz); ClassReader classReader = new ClassReader(new FileInputStream(clazzFilePath)); ClassWriter classWriter = new ClassWriter(0); classReader.accept(classWriter, 0); // 写入文件 byte[] bytes = classWriter.toByteArray(); String buildDir = clazz.getProtectionDomain().getCodeSource().getLocation().getFile(); FileOutputStream fos = new FileOutputStream(buildDir + clazz.getPackage().getName().replaceAll(\u0026#34;[.]\u0026#34;, \u0026#34;/\u0026#34;) +\u0026#34;/copyed.class\u0026#34;); fos.write(bytes); fos.flush(); fos.close(); 可以看到classReader的accept方法也可以接受一个classWriter对象，它也是继承自classVisitor，然后把它转化成byte数组，最后通过文件输出流把byte数组写会到文件中，整个过程很简单。修改class也是如此把修改后的byte数组也是写会到文件中的。\n在上面我们知道classVisitor是读取class的核心类，最终把该classVistor传到accept方法中，而classWriter也需要传到accept方法中。所以看下两者都要使用的话，该怎么处理： 可以看到构造器中可以传入classVisitor，最终里面的所有visit**方法都是调用了传入进来的classVisitor方法。所以不难看出来这是个代理模式，传入进来的classVisitor是一个被代理对象，该classVisitor是一个代理对象，首先自定义一个classVisitor：\n1 2 3 4 5 6 public class AddTimerClassVisitor extends ClassVisitor { public AddTimerClassVisitor(int api, ClassVisitor classVisitor) { super(api, classVisitor); } } 然后看下怎么调用AddTimerClassVisitor：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Class clazz = C.class; String clazzFilePath = Utils.getClassFilePath(clazz); ClassReader classReader = new ClassReader(new FileInputStream(clazzFilePath)); //ClassWriter.COMPUTE_FRAMES表示自动计算方法栈数 ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES); //通过构造一个新的classVisitor，然后将classWriter传入到该classVistor中，实际干活的还是classWriter，AddTimerClassVisitor只是作为一个代理类，进行添加属性 AddTimerClassVisitor addTimerClassVisitor = new AddTimerClassVisitor(Opcodes.ASM5, classWriter); classReader.accept(addTimerClassVisitor, 0); // 写入文件 byte[] bytes = classWriter.toByteArray(); FileOutputStream fos = new FileOutputStream(clazzFilePath); fos.write(bytes); fos.flush(); fos.close(); 将ClassWriter传到AddTimerClassVisitor中，可以看出来ClassWriter是被代理的对象，AddTimerClassVisitor是代理对象，在前面我们通过重写visitField访问到属性，通过visitMethod访问到方法，这两个方法是多次被调用，而我们是想添加一个静态的timer属性，和修改方法m，那此时visitField肯定不会被调用到，在class开始访问和结束访问的时候会分别调用visit和visitEnd方法，那添加timer属性可以放到visitEnd中，修改方法可以在visitMethod中通过过滤来达到修改的目的，而最终的字节码照样可以先把结果通过jclasslib来查看： 在class中名字是timer，描述符是J，访问标志是public+static，那么通过asm如何添加该属性：\n1 2 3 4 5 6 7 8 9 10 11 @Override public void visitEnd() { System.out.println(\u0026#34;AddTimerClassVisitor visitEnd\u0026#34;); //通过visitField方法添加属性,cv是传进来的classWriter，实际干活的还是classWriter，此处用到了代理模式 FieldVisitor fv = cv.visitField(Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC, \u0026#34;timer\u0026#34;, \u0026#34;J\u0026#34;, null, null);//visitField方法第一个参数定义访问标志，它是public+static类型，第二个参数是参数的名字，第三个参数是参数的描述符，表示什么类型，long类型用J表示 if (fv != null) { fv.visitEnd(); } cv.visitEnd(); } 通过cv（传进来的classWriter）来访问属性来添加timer属性，和上面用jclasslib工具查看的结果一样。下面再看下如果修改m方法：\n1 2 3 4 5 6 7 8 9 10 @Override public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) { System.out.println(\u0026#34;AddTimerClassVisitor visitMethod\u0026#34;); MethodVisitor methodVisitor = super.visitMethod(access, name, descriptor, signature, exceptions); if (methodVisitor != null \u0026amp;\u0026amp; !name.equals(\u0026#34;\u0026lt;init\u0026gt;\u0026#34;)) { NewMethodVisitor newMethodVisitor = new NewMethodVisitor(Opcodes.ASM5, methodVisitor, mOwner); return newMethodVisitor; } return methodVisitor; } 首先是拿到当前的MethodVisitor，然后判断方法不是构造函数，最后放回一个新的NewMethodVisitor，否则返回原来的MethodVisitor，下来来看下NewMethodVisitor如何修改方法m，先看下jclasslib修改后class的方法m： 其实我们通过javap -v com.xc.asm.C来查看字节码： 更多的javap命令如下： 有了上面反编译的字节码后，其实就是asm对应的方法操作了，在NewMethodVisitor中重写visitCode方法，在访问该方法之前添加对应的字节码，重写visitInsn方法，在方法return之前添加对应的字节码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class NewMethodVisitor extends MethodVisitor { private String mOwner; public NewMethodVisitor(int api, MethodVisitor methodVisitor, String mOwner) { super(api, methodVisitor); this.mOwner = mOwner; } @Override public void visitCode() { mv.visitCode(); mv.visitFieldInsn(GETSTATIC, mOwner, \u0026#34;timer\u0026#34;, \u0026#34;J\u0026#34;); mv.visitMethodInsn(INVOKESTATIC, \u0026#34;java/lang/System\u0026#34;, \u0026#34;currentTimeMillis\u0026#34;, \u0026#34;()J\u0026#34;); mv.visitInsn(LSUB); mv.visitFieldInsn(PUTSTATIC, mOwner, \u0026#34;timer\u0026#34;, \u0026#34;J\u0026#34;); } @Override public void visitInsn(int opcode) { if ((opcode \u0026gt;= IRETURN \u0026amp;\u0026amp; opcode \u0026lt;= RETURN) || opcode == ATHROW) { mv.visitFieldInsn(GETSTATIC, mOwner, \u0026#34;timer\u0026#34;, \u0026#34;J\u0026#34;); mv.visitMethodInsn(INVOKESTATIC, \u0026#34;java/lang/System\u0026#34;, \u0026#34;currentTimeMillis\u0026#34;, \u0026#34;()J\u0026#34;); mv.visitInsn(LADD); mv.visitFieldInsn(PUTSTATIC, mOwner, \u0026#34;timer\u0026#34;, \u0026#34;J\u0026#34;); } mv.visitInsn(opcode); } } 可以结合上面的反编译的字节码，对应着看asm的操作。最后asm操作完后，就是通过输出流把byte数组写会到文件中。\n参考: Android 进阶之路：ASM 修改字节码，这样学就对了！ asm依赖 asm官网 jclasslib\n","date":"2025-02-10T00:00:00Z","permalink":"https://example.com/p/asm%E4%BF%AE%E6%94%B9%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%9D%E4%BD%93%E9%AA%8C/","title":"asm修改字节码初体验"},{"content":"平时工作中需要经常变jdk的版本配置，使用jenv来管理jdk的时候，不用来回配置环境变量。\n安装jenv 1 brew install jenv 配置.zshrc 1 2 export PATH=\u0026#34;$HOME/.jenv/bin:$PATH\u0026#34; eval \u0026#34;$(jenv init -)\u0026#34; 同步.zshrc 1 source ~/.zshrc 查看本机安装了哪些jdk 1 /usr/libexec/java_home -V 结果如下： 添加jdk 1 2 3 jenv add /Users/xiangcheng/Library/Java/JavaVirtualMachines/corretto-18.0.2/Contents/Home jenv add /Users/xiangcheng/Library/Java/JavaVirtualMachines/corretto-11.0.23/Contents/Home jenv add /Users/xiangcheng/Library/Java/JavaVirtualMachines/corretto-1.8.0_412/Contents/Home 查看jenv管理的jdk版本 1 jenv versions 结果如下： 切换全局的jdk版本 1 jenv global 18 当前 shell 切换 JDK 1 jenv shell 18 项目目录指定 JDK 1 2 cd ~/my_project jenv local 18 ","date":"2025-02-10T00:00:00Z","permalink":"https://example.com/p/%E4%BD%BF%E7%94%A8jenv%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAjdk/","title":"使用jenv管理多个jdk"},{"content":"zsh的插件分为预装的插件和自定义的插件，自定义插件在.oh-my-zsh/custom文件夹下，预装的插件在plugins文件夹下： 我是装了4个自定义插件，关于自定义插件的安装可以在对应的插件介绍中找到\nsublime插件 sublime插件能快速打开某个文件或文件，并在sublime应用中展示。它是预装的插件，所以不用单独安装 使用：\n1 2 st . # 打开当前目录 st myfile.txt # 打开 myfile.txt 参考： ohmyzsh zsh-autosuggestions zsh-completions zsh-syntax-highlighting\n","date":"2025-02-08T00:00:00Z","permalink":"https://example.com/p/oh-my-zsh%E6%8F%92%E4%BB%B6%E5%BF%85%E5%A4%87/","title":"oh-my-zsh插件必备"},{"content":"Gradle基础 gradle是一个脚本框架，用来构建android程序的一个脚本，在认识前，我们先以最基础的方式来认识它。\ngradle配置 首先在官网下载对应的版本，这里我选择6.6.1-all的版本，下载完后，放到指定的目录，然后配置gradle的环境变量:\nopen -e .bash_profile 打开配置文件 添加 GRADLE_HOME、PATH 1 2 3 4 5 6 7 export GRADLE_HOME=/Users/xiangcheng/gradle/gradle-6.6.1 export PATH=${PATH}:/Users/xiangcheng/gradle/gradle-6.6.1/bin ----------------官方写法如下-------------------------------- export GRADLE_HOME=/Users/xiangcheng/gradle/gradle-6.6.1 export PATH=$PATH:$GRADLE_HOME/bin source .bash_profile 重置配置文件，以便新 path 生效 open -e ~/.zshrc 打开另一个配置 在最后一行添加 source ~/.bash_profile source ~/.zshrc 重置配置文件 配置 zshrc 是因为有的机器 bash_profile 配置不管用，添加这个就行了\n运行 gradle \u0026ndash;version，出现版本号则 Gradle 配置成功 注意：gradle版本和jdk版本需要有对应关系： 这里我安装的是gradle-6.6.1的版本，因此我需要设置JDK8，如果本地安装的jdk版本多个的话，mac会使用最高的版本，先查看本地安装了哪些jdk版本 1 /usr/libexec/java_home -V 输出如下：\n1 2 3 4 Matching Java Virtual Machines (3): 18.0.2 (arm64) \u0026#34;Amazon.com Inc.\u0026#34; - \u0026#34;Amazon Corretto 18\u0026#34; /Users/xiangcheng/Library/Java/JavaVirtualMachines/corretto-18.0.2/Contents/Home 11.0.23 (arm64) \u0026#34;Amazon.com Inc.\u0026#34; - \u0026#34;Amazon Corretto 11\u0026#34; /Users/xiangcheng/Library/Java/JavaVirtualMachines/corretto-11.0.23/Contents/Home 1.8.0_412 (arm64) \u0026#34;Amazon\u0026#34; - \u0026#34;Amazon Corretto 8\u0026#34; /Users/xiangcheng/Library/Java/JavaVirtualMachines/corretto-1.8.0_412/Contents/Home 所以默认用的是jdk18，我需要改下环境变量，将jdk改成8：\n1 2 export JAVA_HOME=/Users/xiangcheng/Library/Java/JavaVirtualMachines/corretto-1.8.0_412/Contents/Home export PATH=$JAVA_HOME/bin:$PATH 再运行：\n1 source ~/.bash_profile 上面的jdk配置好后，然后找个文件夹，创建build.gradle，然后输入：\n1 println(\u0026#34;hello world!\u0026#34;) 然后用gradle build.gradle运行该文件，输出如下： 说明已经成功了。\ngradle初始化工程 平时都是直接通过as创建工程，下面通过gradle来创建一个工程：\n输入gradle init来初始化 接着会输入相关配置信息： 命令行提示选择项目模板 命令行提示选择开发语言 命令行提示选择脚本语言 输入工程名 输入包名 最终工程创建如下： 和android studio创建的工程结构是一致的。 Gradle Wrapper as创建一个工程的时候，默认会有Gradle Wrapper文件夹，它里面会有个wrapper.properties文件夹，配置了gradle相关信息。 Gradle Wrapper 文件的作用就是可以让你的电脑在不安装配置 Gradle 环境的前提下运行 Gradle 项目，你的机器要是没有配 Gradle 环境，那么你 clone gradle 项目下来，执行 init 命令，会根据 gradle-wrapper.properties 文件中声明的 gradle URL 远程路径去下载 gradle 构建工具，cd 进该项目，执行了./gradlew -v，然后下载了对应版本的gradle，如果此时执行的是gradle -v，就用的是本地配置的环境变量中的gradle版本，此时不会去下载。 然后就可以在项目目录下运行 gradle 命令了，不过还是推荐大家在机器配置统一的 Gradle 环境\ngradlew \u0026ndash;\u0026gt; linux 平台脚本 gradlew.bat \u0026ndash;\u0026gt; window 平台脚本 gradle-wrapper.jar \u0026ndash;\u0026gt; Gradle 下载、管理相关代码 gradle-wrapper.properties \u0026ndash;\u0026gt; Gradle 下载、管理配置参数 gradle-wrapper.properties 文件中参数详解：\ndistributionUrl \u0026ndash;\u0026gt; Gradle 压缩包下载地址\nzipStoreBase \u0026ndash;\u0026gt; 本机存放 Gradle 压缩包主地址\nzipStorePath \u0026ndash;\u0026gt; 本机存放 Gradle 压缩包主路径\nGradle 压缩包完整的路径是 zipStoreBase + zipStorePath distributionBase \u0026ndash;\u0026gt; 本机 Gradle 压缩包解压后主地址\ndistributionPath \u0026ndash;\u0026gt; 本机 Gradle 压缩包解压后路径\nGradle 解压完整的路径是 distributionBase + distributionPath distributionBase 的路径是环境 path 中 GRADLE_USER_HOME 的地址 Windows：C:/用户/你电脑登录的用户名/.gradle/ MAC：～/.gradle/ 你 MAC 要是配了 Gradle 环境变量，distributionBase 就是你自己解压缩的 gradle 路径 这几个地址还是要搞清楚的~\n关于as如果配置统一的gradle版本，可以看如下截图： gradle-wrapper.properties \u0026ndash; 使用 wrapper 也就是 AS 来管理 Gradle Specifiled location \u0026ndash; 使用本地文件，也就是我们自己管理 Gradle，这样每个工程的gradle-wrapper.properties就不起作用了，使用本机配置的gradle版本 gradlw和gradle区别 gradlew实际是一个脚本文件，它是在gradle工程的根目录下面，如果是windows的话，会执行gradlew.bat文件，这个在前面通过命令初始化工程的时候可以看到，其中gradlew脚本会通过gradle/wrapper/gradle-wrapper.jar来使用项目中配置的gradle版本，而gradle命令是使用本机配置的gradle版本。\nGradle中task task可以认为是gradle中最小执行单元，正是因为有了task，gradle框架才能有序的工作。实际上根据 Gradle 构建项目的流程，是先把所有的 .gradle 脚本执行一遍，编译生成对应的 Gradle、Setting、Project 对象，然后根据我们在构建脚本中设置的构建配置，生成一张 Task 组成的：有向无环图，先来看看这张图: 左边表示的是task之间的依赖关系，右边表示的是项目构建过程中要经过的任务，正是因为有了这些任务，项目才能构建出来。\n实际上在gradle构建过程中，会把每一个工程的build.gradle文件会构建成一个project对象，而该project对象由一个个的task组成，比如在构建android项目的时候会有编译java代码的task，编译资源的task等。这些task其实是定义在android插件中，关于插件后面再说。\n比如android工程中有很多我们熟悉的task： 可以看到在build这个分组下面有很多熟悉的task，比如有assemble的task，它是用来打包的task。而它们又依赖其它的task，最终一个个的task被执行完，包也打出来了。 比如我在终端上运行./gradlew build的时候，会执行一大堆的task： Task 是完成一类任务，实际上对应的也是一个对象。而 Task 是由无数个 Action 组成的，Action 代表的是一个个函数、方法，每个 Task 都是一堆 Action 按序组成的执行图，就好像我们在 Class 的 main 函数中按照逻辑调用一系列方法一样。\n创建task 1 2 3 4 5 6 7 8 9 10 11 task hello{ println \u0026#34;hello world\u0026#34; } task(hello2){ println \u0026#34;hello world2\u0026#34; } task (\u0026#39;hello3\u0026#39;){ println \u0026#34;hello world3\u0026#34; } 运行task 通过./gradlew task名来运行task，运行结果如下： 如果是子模块的话，则通过./gradlew 模块名:task名运行task，运行结果如下： 这是在工程的根目录下build.gradle定义的三个task，然后通过./gradlew hello命令来执行hello这个task，而其它两个task也输出日志，是因为这几条日志都是在配置阶段输出，关于gradle的生命周期后面会说。那为什么gradlew执行脚本就在根目录下，还需要./来执行该脚本呢？ 这是因为在终端里面，需要通过./来获取当前目录，如果不加的话，会导致终端在目录下找不到。\n其实task是project的方法，project表示的是模块在初始化阶段会生成，上面使用task hello{}，创建的task实际是传入了action的闭包，它是在构建的时候被调用的： 在创建task的时候可以指定其他属性，可以通过task其他的重载方法来创建：\n1 2 3 task demo1(group: \u0026#34;demo组\u0026#34;,name:\u0026#34;demo2\u0026#34;,description:\u0026#34;我是demo2的task\u0026#34;,action:{ println(\u0026#34;我是demo2 task的action\u0026#34;) }) 比如在构建demo1的时候，申明了其它属性，此处的action跟上面写在括号外面是一回事，只不过此处是通过map来创建的，还有一点，map中指定的name不会生效，会被demo1的名字给覆盖了，目前发现没什么作用，执行结果如下： task.dofirst和dolast doFirst是task执行前要调用的action，doLast是task执行后要调用的action：\n1 2 3 4 5 6 7 8 9 task demo2{ println(\u0026#34;demo2\u0026#34;) doFirst{ println(\u0026#34;demo2 的 doFirst\u0026#34;) } doLast{ println(\u0026#34;demo2 的 doLast\u0026#34;) } } 关于task其它的使用可以在看三方插件的时候再看。\nGradle插件 gradle插件（plugin）是构建项目时候用到的，它其实是由一系列的task组成的，其实android的工程，google已经帮我们实现了android gradle plugin（agp）。google也是遵循了gradle的task依赖法则，构成一个有序无向图。最终去执行一个个的tak。\n插件主要通过定义仓库，然后定义插件的名字，比如安卓中依赖agp是通过如下的方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 buildscript { repositories { google() jcenter() } dependencies { classpath \u0026#39;com.android.tools.build:gradle:3.5.3\u0026#39; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { repositories { google() jcenter() } } buildscript是rootProject的方法，它声明插件的仓库、添加插件专用闭包 allprojects主要是指所有的模块需要的三方依赖库时候的仓库 像上面定了agp插件3.5.3，然后在app模块中通过apply plugin: 'com.android.application'来使用这个插件，而app模块选的android{}就是来自于该插件，我们叫他是DSL配置块。 其实像android{}的实现在插件中是通过delegate+闭包实现 DSL 配置块\n首先把闭包定义好： 1 2 3 4 5 6 7 8 9 10 11 12 def android = { compileSdkVersion 25 buildToolsVersion \u0026#34;25.0.2\u0026#34; // 这个对应相应的方法 defaultConfig { minSdkVersion 15 targetSdkVersion 25 versionCode 1 versionName \u0026#34;1.0\u0026#34; } } 定义数据模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Android { int mCompileSdkVersion String mBuildToolsVersion BefaultConfig mBefaultConfig Android() { this.mBefaultConfig = new BefaultConfig() } void defaultConfig(Closure closure) { closure.setDelegate(mProductFlavor) closure.setResolveStrategy(Closure.DELEGATE_FIRST) closure.call() } } class BefaultConfig { int mVersionCode String mVersionName int mMinSdkVersion int mTargetSdkVersion } 绑定数据 1 2 3 Android bean = new Android() android.delegate = bean//将上面定义好的bean给设置到闭包里面 android.call()//闭包的调用 Gradle构建过程 其实构建过程就是指编译对应的.gradle文件，然后生成对象，最后执行task。 主要分为三个步骤：\nInitialization：初始化阶段，按顺序执行init.gradle，setting.gradle，生成Gradle、Setting、Project对象 Configuration：配置阶段，按顺序执行 root build.gradle -\u0026gt; 子项目 build.gradle 脚本，生成 Task 执行流程图 Execution：执行阶段，按照 Task 执行图顺序运行每一个 Task，完成一个个步奏，生成最终 APK 文件 整个流程如下： 通过流程图观察，我们可以在合适的时机监听gradle的构建过程，也就是钩子方法。 下面通过这些钩子方法来获取项目构建各个阶段、任务的耗时情况，在setting.gradle中添加如下代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 long beginOfSetting = System.currentTimeMillis() def beginOfConfig def configHasBegin = false def beginOfProjectConfig = new HashMap() def beginOfProjectExcute gradle.projectsLoaded { println \u0026#39;初始化阶段，耗时：\u0026#39; + (System.currentTimeMillis() - beginOfSetting) + \u0026#39;ms\u0026#39; } gradle.beforeProject { project -\u0026gt; if (!configHasBegin) { configHasBegin = true beginOfConfig = System.currentTimeMillis() } beginOfProjectConfig.put(project, System.currentTimeMillis()) } gradle.afterProject { project -\u0026gt; def begin = beginOfProjectConfig.get(project) println \u0026#39;配置阶段，\u0026#39; + project + \u0026#39;耗时：\u0026#39; + (System.currentTimeMillis() - begin) + \u0026#39;ms\u0026#39; } gradle.taskGraph.whenReady { println \u0026#39;配置阶段，总共耗时：\u0026#39; + (System.currentTimeMillis() - beginOfConfig) + \u0026#39;ms\u0026#39; beginOfProjectExcute = System.currentTimeMillis() } gradle.taskGraph.beforeTask { task -\u0026gt; task.doFirst { task.ext.beginOfTask = System.currentTimeMillis() } task.doLast { println \u0026#39;执行阶段，\u0026#39; + task + \u0026#39;耗时：\u0026#39; + (System.currentTimeMillis() - task.beginOfTask) + \u0026#39;ms\u0026#39; } } gradle.buildFinished { println \u0026#39;执行阶段，耗时：\u0026#39; + (System.currentTimeMillis() - beginOfProjectExcute) + \u0026#39;ms\u0026#39; } 由于在setting.gradle执行前，Gradle对象其实已经生成，所以通过gradle对象的projectsLoaded回调获取初始化时间。第一次进入到beforeProject的时候记录配置的起始时间，并记录每一个project的配置起始时间，然后在afterProject中算出每一个project配置的时间。然后通过gradle.taskGraph来获取有序无向图，然后通过whenReady方法回调算出总的配置时间。最后通过有序无向图的beforeTask来添加task的开始和结束的执行时间来算出task的执行耗时。最后通过gradle的buildFinish来获取总共的构建时间。\ngradle打包速度优化 首先了解下安卓中的variant是什么意思，它表示一个包的变体，其中变体是由productFlavor（产品风味）和buildType（构建类型）组合而成的。其中productFlavor是由维度和渠道构成的，buildType指的是debug还是release，比如维度可以配置价格和渠道的两个维度，而渠道可以配置google、xiaomi等渠道：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 android { // 定义 buildTypes（构建类型） buildTypes { debug { minifyEnabled false applicationIdSuffix \u0026#34;.debug\u0026#34; } release { minifyEnabled true proguardFiles getDefaultProguardFile(\u0026#39;proguard-android-optimize.txt\u0026#39;), \u0026#39;proguard-rules.pro\u0026#39; } } // 定义 productFlavors（产品风味） flavorDimensions \u0026#39;channel\u0026#39;, \u0026#39;pricing\u0026#39; productFlavors { //配置渠道维度下两个变体 google { dimension \u0026#39;channel\u0026#39; } xiaomi { dimension \u0026#39;channel\u0026#39; } //配置价格下两个变体 free { dimension \u0026#39;pricing\u0026#39; } vip { dimension \u0026#39;pricing\u0026#39; } } // 在这里的 `productFlavors` 和 `buildTypes` 组合形成不同的 variants } 所以上面通过维度和渠道组合后的productFlavor有googleFree、googleVip、xiaomiFree、xiaomiVip四个，再和buildType组合后，就是8个变体，分别是：\ngoogleFreeDebug googleFreeRelease googleVipDebug googleVipRelease xiaomiFreeDebug xiaomiFreeRelease xiaomiVipDebug xiaomiVipRelease 知道了variant后，下面就是了解下打包了，一般通过build Analyze查看build过程中的一些警告，使用该工具需要先进行build，第二个工具是gradle profile工具，一般通过如下命令：\n1 2 ./gradlew installGoogleFreeDebug --build-cache -x lint -x test --warning-mode=none -Pkotlin.compiler.execution.strategy=in-process -PcompilerArgs=-Xlint:deprecation --no-configuration-cache --profile adb shell am start -n 包名/应用主入口 如果通过adb命令启动主入口的话，需要在清单文件中给主入口加上android:exported=\u0026quot;true\u0026quot;属性，装包完了后，本地会生成一个html文件，该文件会有gradle每个阶段的耗时情况，并且会有每个task的耗时。\n再个就是gradle scan工具，一般通过如下命令：\n1 2 ./gradlew installGoogleFreeDebug --build-cache -x lint -x test --warning-mode=none -Pkotlin.compiler.execution.strategy=in-process -PcompilerArgs=-Xlint:deprecation --no-configuration-cache --scan adb shell am start -n 包名/应用主入口 scan会生成一个在线的网页，第一次使用需要邮箱校验，它的信息比profile更全面，更加智能，其中performance跟profile中效果差不多，它多了timeline选项，表示什么时候执行了什么task，switchs选项表示一些建议，比如缓存没开，会提示off。 其实gradle优化最直接是通过组件化来开发，如果全app编译的话，组件越多，需要的时间越长，所以通过组件化来降低打包时间是最直接的，把一些其他依赖的组件通过aar进行依赖或远程依赖。 参考： Gradle 爬坑指南 \u0026ndash; 概念初解、Grovvy 语法、常见 API Gradle 爬坑指南 \u0026ndash; 理解 Plugin、Task、构建流程 深度探索 Gradle 自动化构建技术（三、Gradle 核心解密）\n","date":"2025-02-07T00:00:00Z","permalink":"https://example.com/p/gradle%E5%BF%85%E5%A4%87/","title":"Gradle必备"},{"content":"Recyclerview系列 缓存相关 RecyclerView 缓存机制 | 如何复用表项？ RecyclerView 缓存机制 | 回收些什么？ RecyclerView 缓存机制 | 回收到哪去？ RecyclerView缓存机制 | scrap view 的生命周期 RecyclerView 面试题 | 滚动时表项是如何被填充或回收的？ RecyclerView 面试题 | 哪些情况下表项会被回收到缓存池？ RecyclerView 刷新列表数据的 notifyDataSetChanged() 为什么是昂贵的? 掌握这17张图，没人比你更懂RecyclerView的预加载 【动画图解】这个值取对了，ViewPager2才能纵享丝滑 动画相关 RecyclerView 动画原理 | 换个姿势看源码（pre-layout） RecyclerView 动画原理 | pre-layout，post-layout 与 scrap 缓存的关系） RecyclerView 动画原理 | 如何存储并应用动画属性值？） 优化相关 浅谈RecyclerView的性能优化 RecyclerView 性能优化 | 把加载表项耗时减半 (一) RecyclerView性能优化之异步预加载 Kotlin系列 Kotlin中的协程、上下文和作用域 抽丝剥茧聊协程之深入理解Continuation原理 Kotlin 源码里成吨的 noinline 和 crossinline 是干嘛的？看完这个视频你转头也写了一吨 抽丝剥茧聊Kotlin协程之协程异常处理机制分析 kotlin的泛型 SurfaceFlinger系列 Android应用程序与SurfaceFlinger服务的关系概述和学习计划 Android系统Surface机制的SurfaceFlinger服务简要介绍和学习计划 Activity系列 Android应用程序窗口（Activity）实现框架简要介绍和学习计划 WMS系列 Android窗口管理服务WindowManagerService的简要介绍和学习计划 资源打包系列 Android应用程序资源的编译和打包过程分析 Android应用程序资源的查找过程分析 Android Apk 编译打包流程，了解一下~ AssetManager系列 Android资源管理框架（Asset Manager）简要介绍和学习计划 硬件加速系列 Android应用程序UI硬件加速渲染技术简要介绍和学习计划 ASM相关 Android 进阶之路：ASM 修改字节码，这样学就对了！ Gradle相关 Gradle 爬坑指南 \u0026ndash; 导论 Gradle 爬坑指南 \u0026ndash; 概念初解、Grovvy 语法、常见 API Gradle 爬坑指南 \u0026ndash; 理解 Plugin、Task、构建流程 Gradle 爬坑指南 \u0026ndash; Gradle 核心模型、Hook 函数、ext 扩展属性、Project API 深度探索 Gradle 自动化构建技术（一、Gradle 核心配置篇） 深度探索 Gradle 自动化构建技术（二、Groovy 筑基篇） 深度探索 Gradle 自动化构建技术（三、Gradle 核心解密） 深度探索 Gradle 自动化构建技术（四、自定义 Gradle 插件） 深度探索 Gradle 自动化构建技术（五、Gradle 插件架构实现原理剖析 — 上） 深度探索 Gradle 自动化构建技术（五、Gradle 插件架构实现原理剖析 — 下） 深入探索 Gradle 自动化构建技术（九、Gradle 插件平台化框架 ByteX 探秘之旅） 设计模式相关 Java常用设计模式(一) Java常用设计模式(二) Java常用设计模式(三) 《Android源码设计模式解析》读书笔记——Android中你应该知道的设计模式 大佬博客系列 老罗 Gracker 程序员江同学 ","date":"2025-01-22T00:00:00Z","permalink":"https://example.com/p/%E9%AB%98%E8%B4%A8%E9%87%8F%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/","title":"高质量文章汇总"},{"content":"上一篇(RecyclerView性能优化)理论知识讲过recyclerview有哪些优化点，该篇主要结合理论知识来实践下优化手段。\nxml布局替换为动态创建 一个简单的textview先通过xml创建，通过traceview观察耗时 这次三次创建viewholder的耗时，其中第一次由于需要类加载到jvm中，所以会耗时长一些，后面的话，基本在5ms左右。 通过new的形式创建viewholder： 第一次耗时在6ms，第二次耗时在4ms，基本比xml的形式要少个1ms 注意：这里演示的只是一个简单的textview，如果平时开发的布局是比较复杂，并且嵌套层级比较深的话，这种差距会更加明显。 通过perfetto观察create过程： 基本数据和traceview保持一致。 recyclerview.setHasFixSize(true) 用了sethasfixsize(true)的时候，会通过consumePendingUpdateOperations触发recyclerview的layout过程，没有走从根view到recyclerview的measure、layout过程，实际sethasfixsize(true)会给choreographer发送一条callback_animal的消息： 其实我们的属性动画也是这么做的，给choreographer发送一条animal的消息。sethasfixsize(true)在表项尺寸不发生变化的时候使用，减少不必要的measure过程。\nsethasstableids(true)和重写getItemId： 调用notifydatasetChange后，不会走oncreateviewholder： 从trace分析： detach过程调用的是scrap的缓存，并且此时不会回调ondetachfromwindow过程，并且都加入到了attach的scrap缓存中，在fill阶段通过重写的getItemId拿到了viewholder： 至于为什么会onbind，是因为notify过后的item的状态变成了invalid状态，所以会重新走onbind过程。\nrecyclerpool减少oncreateviewholder次数： tablayout+viewpager2，子页面是fragment，每个fragment中的rv用的viewholder是同种类型，我们将recyclerpool设置在activity中，然后传给子fragment，设置recyclerpool需要在setadapter之前。 我们在第一个页面滑动的时候，会有viewholder放到了recyclerpool中，此时我们滑动到第二个fragment的时候会用到recycerlpool中的viewholder。 从debug看，给另外一个recyclerview设置recyclerpool时候，已经存在一个viewholder，所以猜测该fragment会使用到viewholder，日志验证： 从日志来看，第一个viewholder只有bind过程，没有create。\n","date":"2025-01-17T00:00:00Z","permalink":"https://example.com/p/recyclerview%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/","title":"RecyclerView优化实践"},{"content":" 说起预加载，其实之前面试的时候被问到的，然后最近看到一篇关于预加载的文章，然后颇有感受，因此才有该篇文章。 在recyclerview的onAttachedToWindow有这么一句：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * On L+, with RenderThread, the UI thread has idle time after it has passed a frame off to * RenderThread but before the next frame begins. We schedule prefetch work in this window. */ static final boolean ALLOW_THREAD_GAP_WORK = Build.VERSION.SDK_INT \u0026gt;= 21; @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); //省略代码 if (ALLOW_THREAD_GAP_WORK) { // Register with gap worker mGapWorker = GapWorker.sGapWorker.get(); if (mGapWorker == null) { mGapWorker = new GapWorker(); // break 60 fps assumption if data from display appears valid // NOTE: we only do this query once, statically, because it\u0026#39;s very expensive (\u0026gt; 1ms) Display display = ViewCompat.getDisplay(this); float refreshRate = 60.0f; if (!isInEditMode() \u0026amp;\u0026amp; display != null) { float displayRefreshRate = display.getRefreshRate(); if (displayRefreshRate \u0026gt;= 30.0f) { refreshRate = displayRefreshRate; } } mGapWorker.mFrameIntervalNs = (long) (1000000000 / refreshRate); GapWorker.sGapWorker.set(mGapWorker); } mGapWorker.add(this); } } 可以看到有一个静态变量，ALLOW_THREAD_GAP_WORK是大于等于21（Android5.0）才会为true，这是因为在5.0之后，引进了RenderThread线程，专门用来渲染ui线程绘制好的数据，渲染完后，会提交到事先申请的bufferqueue中，然后当vsync-sf信号来的时候，sufaceflinger会去对应app的bufferqueue中取出前面提交的buffer数据，然后进行合成layer，最终屏幕（hwc）收到该请求后，进行图层进行合成，最终送到屏幕硬件上显示。这就是一针从创建到消费的过程。 由于ui线程把绘制好的数据绘制好后，会通知renderthread线程进行渲染，直到下一针来的时候才开始工作，此时会有主线程空闲的时候，recyclerview正是利用此空闲时间来进行预加载，而如果在下一针来临的时候，预加载还没有完成，那么此时会放弃此次的预加载，了解原理后，开始分析过程： 预加载的处理类是GapWorker类，一个线程对应一个GapWorker，它是存储在ThreadLocal中。GapWorker是一个runnable类，它如何要工作的话，是通过GapWorker.postFromTraversal工作的：\n1 2 3 4 5 6 7 8 9 10 11 12 void postFromTraversal(RecyclerView recyclerView, int prefetchDx, int prefetchDy) { if (recyclerView.isAttachedToWindow()) { if (RecyclerView.DEBUG \u0026amp;\u0026amp; !mRecyclerViews.contains(recyclerView)) { throw new IllegalStateException(\u0026#34;attempting to post unregistered view!\u0026#34;); } if (mPostTimeNs == 0) { mPostTimeNs = recyclerView.getNanoTime(); recyclerView.post(this); } } recyclerView.mPrefetchRegistry.setPrefetchVector(prefetchDx, prefetchDy); } 可以看出来实际是通过recyclerview.post，然后传的是自己，因此会直接run方法。预加载时机在源码里面有两处调用了：\nRecyclerview被拖动时： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Override public boolean onTouchEvent(MotionEvent e) { ... switch (action) { ... case MotionEvent.ACTION_MOVE: { ... if (mScrollState == SCROLL_STATE_DRAGGING) { ... // 处于拖动状态并且存在有效的拖动距离时 if (mGapWorker != null \u0026amp;\u0026amp; (dx != 0 || dy != 0)) { mGapWorker.postFromTraversal(this, dx, dy); } } } break; ... } ... return true; } Recyclerview惯性滑动时： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class ViewFlinger implements Runnable { ... @Override public void run() { ... if (!smoothScrollerPending \u0026amp;\u0026amp; doneScrolling) { ... } else { ... if (mGapWorker != null) { mGapWorker.postFromTraversal(RecyclerView.this, consumedX, consumedY); } } } ... } 看下GapWorker的run方法如何实现的预加载：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Override public void run() { try { TraceCompat.beginSection(RecyclerView.TRACE_PREFETCH_TAG); if (mRecyclerViews.isEmpty()) { // abort - no work to do return; } // Query most recent vsync so we can predict next one. Note that drawing time not yet // valid in animation/input callbacks, so query it here to be safe. final int size = mRecyclerViews.size(); long latestFrameVsyncMs = 0; for (int i = 0; i \u0026lt; size; i++) { RecyclerView view = mRecyclerViews.get(i); if (view.getWindowVisibility() == View.VISIBLE) { latestFrameVsyncMs = Math.max(view.getDrawingTime(), latestFrameVsyncMs); } } if (latestFrameVsyncMs == 0) { // abort - either no views visible, or couldn\u0026#39;t get last vsync for estimating next return; } long nextFrameNs = TimeUnit.MILLISECONDS.toNanos(latestFrameVsyncMs) + mFrameIntervalNs; prefetch(nextFrameNs); // TODO: consider rescheduling self, if there\u0026#39;s more work to do } finally { mPostTimeNs = 0; TraceCompat.endSection(); } } 在调用prefetch前传入nextFrameNs，该值表示预估的下一个vsync来临的时间，首先获取上一针的绘制起始时间，也就是latestFrameVsyncMs，而mFrameIntervalNs是通过刷新率算出来的一针需要的时间，比如60hz的手机，一秒是60帧，那么mFrameIntervalNs的值是一针需要16ms，mFrameIntervalNs的单位是纳秒，这个时间在开篇的onAttachedToWindow方法中计算的，所以可以看出来，nextFrameNs时间就是预加载最后的期限时间，超过这个时间就会放弃该预加载，上面提到的上一针时间是用过recyclerview的getDrawingTime获取的，它是获取的attachInfo的mDrawingTime时间，而mDrawingTime是在viewRootImpl中draw方法给赋值的：\n1 2 3 4 5 6 private boolean draw(boolean fullRedrawNeeded, boolean forceDraw) { //省略代码 mAttachInfo.mDrawingTime = mChoreographer.getFrameTimeNanos() / TimeUtils.NANOS_PER_MS; //省略代码 } 可以看出来，它是通过Choreographer的getFrameTimeNanos方法来获取的：\n1 2 3 4 5 @UnsupportedAppUsage public long getFrameTimeNanos() { //省略代码 return USE_FRAME_TIME ? mLastFrameTimeNanos : System.nanoTime(); } mLastFrameTimeNanos是在doFrame中将参数frameTimeNanos给赋值的，而frameTimeNanos参数表示的就是当前vsnyc信号来临的时间。所以最终结论就是通过遍历recyclerview的drawingtime，来获取最近一次的vsync时间，并加上当前设备一针所需要的时间，从而得到下一个vsync信号来临的时间，也就是预加载要完成的最晚时间。继续跟进GapWorker的prefetch方法：\n1 2 3 4 void prefetch(long deadlineNs) { buildTaskList(); flushTasksWithDeadline(deadlineNs); } buildTaskList，它是用来构建预加载的task列表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private void buildTaskList() { // Update PrefetchRegistry in each view final int viewCount = mRecyclerViews.size(); int totalTaskCount = 0; for (int i = 0; i \u0026lt; viewCount; i++) { RecyclerView view = mRecyclerViews.get(i); if (view.getWindowVisibility() == View.VISIBLE) { //收集要预加载的view的position view.mPrefetchRegistry.collectPrefetchPositionsFromView(view, false); totalTaskCount += view.mPrefetchRegistry.mCount; } } //省略代码 } 首先是调用了view.mPrefetchRegistry.collectPrefetchPositionsFromView(view, false)来收集预加载的view：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void collectPrefetchPositionsFromView(RecyclerView view, boolean nested) { mCount = 0; if (mPrefetchArray != null) { Arrays.fill(mPrefetchArray, -1); } final RecyclerView.LayoutManager layout = view.mLayout; if (view.mAdapter != null \u0026amp;\u0026amp; layout != null \u0026amp;\u0026amp; layout.isItemPrefetchEnabled()) { //省略代码 if (!view.hasPendingAdapterUpdates()) { layout.collectAdjacentPrefetchPositions(mPrefetchDx, mPrefetchDy, view.mState, this); } //省略代码 } } 可以看出来调用了layoutmanager的collectAdjacentPrefetchPositions的方法，把需要预加载的水平和竖直方向的偏移量传入其中，看下LinearLayoutManager的该方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Override public void collectAdjacentPrefetchPositions(int dx, int dy, RecyclerView.State state, LayoutPrefetchRegistry layoutPrefetchRegistry) { int delta = (mOrientation == HORIZONTAL) ? dx : dy; if (getChildCount() == 0 || delta == 0) { // can\u0026#39;t support this scroll, so don\u0026#39;t bother prefetching return; } ensureLayoutState(); final int layoutDirection = delta \u0026gt; 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START; final int absDelta = Math.abs(delta); updateLayoutState(layoutDirection, absDelta, true, state); collectPrefetchPositionsForLayoutState(state, mLayoutState, layoutPrefetchRegistry); } 通过方法来判断偏移量，然后把方向标识传入到updateLayoutState中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private void updateLayoutState(int layoutDirection, int requiredSpace, boolean canUseExistingSpace, RecyclerView.State state) { //省略代码 if (layoutToEnd) { //获取可见的最后一个表项 final View child = getChildClosestToEnd(); //判断是否是reverse的 mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD : LayoutState.ITEM_DIRECTION_TAIL; //获取预加载的position mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection; mLayoutState.mOffset = mOrientationHelper.getDecoratedEnd(child); //获取要预加载的表项与recyclerview底部的距离 scrollingOffset = mOrientationHelper.getDecoratedEnd(child) - mOrientationHelper.getEndAfterPadding(); } else { //省略代码 } //省略代码 mLayoutState.mScrollingOffset = scrollingOffset; } 此处只保留从上到下的滑动，先是获取页面滚动的最后一个表项，然后判断是不是reverseLayout，如果不是则取LayoutState.ITEM_DIRECTION_TAIL(该值等于1)，预加载的position等于最后一个表项的position+1，接着算出预加载的表项离recyclerview底部的距离。它是通过mOrientationHelper.getDecoratedEnd(child)- mOrientationHelper.getEndAfterPadding()得到的。 mOrientationHelper.getDecoratedEnd(child)它是在OrientationHelper中定义的createVerticalHelper方法中实现的：\n1 2 3 4 5 6 @Override public int getDecoratedEnd(View view) { final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) view.getLayoutParams(); return mLayoutManager.getDecoratedBottom(view) + params.bottomMargin; } 1 2 3 public int getDecoratedBottom(@NonNull View child) { return child.getBottom() + getBottomDecorationHeight(child); } getDecoratedBottom是获取child的bottom+child的底部间距高度，所以getDecoratedEnd是获取child的bottom+child的底部间距高度+下间距。 mOrientationHelper.getEndAfterPadding()也是在OrientationHelper中定义的createVerticalHelper方法中实现的：\n1 2 3 4 @Override public int getEndAfterPadding() { return mLayoutManager.getHeight() - mLayoutManager.getPaddingBottom(); } getEndAfterPadding是recyclerview的高度-recyclerview的下内边距。所以scrollingOffset是即将要预加载的表项离recyclerview底部的间距。接着看下collectPrefetchPositionsForLayoutState方法：\n1 2 3 4 5 6 7 void collectPrefetchPositionsForLayoutState(RecyclerView.State state, LayoutState layoutState, LayoutPrefetchRegistry layoutPrefetchRegistry) { final int pos = layoutState.mCurrentPosition; if (pos \u0026gt;= 0 \u0026amp;\u0026amp; pos \u0026lt; state.getItemCount()) { layoutPrefetchRegistry.addPosition(pos, Math.max(0, layoutState.mScrollingOffset)); } } 将刚才算的预加载的postion和偏移量传入到addPosition中，该方法是在GapWorker中实现的：\n1 2 3 4 5 6 7 8 @Override public void addPosition(int layoutPosition, int pixelDistance) { //省略代码 final int storagePosition = mCount * 2; mPrefetchArray[storagePosition] = layoutPosition; mPrefetchArray[storagePosition + 1] = pixelDistance; mCount++; } 将position和偏移量成对保存在mPrefetchArray数组中。构建完数组中，接着就是将数组的数据存到task中。这块逻辑在buildTaskList中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private void buildTaskList() { for (int i = 0; i \u0026lt; viewCount; i++) { RecyclerView view = mRecyclerViews.get(i); if (view.getWindowVisibility() != View.VISIBLE) { // Invisible view, don\u0026#39;t bother prefetching continue; } LayoutPrefetchRegistryImpl prefetchRegistry = view.mPrefetchRegistry; final int viewVelocity = Math.abs(prefetchRegistry.mPrefetchDx) + Math.abs(prefetchRegistry.mPrefetchDy); for (int j = 0; j \u0026lt; prefetchRegistry.mCount * 2; j += 2) { final Task task; if (totalTaskIndex \u0026gt;= mTasks.size()) { task = new Task(); mTasks.add(task); } else { task = mTasks.get(totalTaskIndex); } final int distanceToItem = prefetchRegistry.mPrefetchArray[j + 1]; task.immediate = distanceToItem \u0026lt;= viewVelocity; task.viewVelocity = viewVelocity; task.distanceToItem = distanceToItem; task.view = view; task.position = prefetchRegistry.mPrefetchArray[j]; totalTaskIndex++; } } } task信息由由以下组成： immediate：表示是否立即执行，判断依据预加载的表项离recyclerview底部距离是否小于滑动的速度 viewVelocity：滑动的速度 distanceToItem：预加载的表项离recyclerview底部距离 view：recyclerview position：预加载表项的位置 从上面可以看出来从mPrefetchArray数组中取值是每两个值取出的，和上面build过程对应。所有的完事后，在buildTaskList中就是对task进行排序：\n1 2 3 4 5 private void buildTaskList() { ... // 3.对任务列表进行优先级排序 Collections.sort(mTasks, sTaskComparator); } 上面就是整个buildTaskList的逻辑，接着就是根据构建的task来创建viewholder，该逻辑是在flushTasksWithDeadline方法中：\n1 2 3 4 5 6 7 8 9 10 private void flushTasksWithDeadline(long deadlineNs) { for (int i = 0; i \u0026lt; mTasks.size(); i++) { final Task task = mTasks.get(i); if (task.view == null) { break; // done with populated tasks } flushTaskWithDeadline(task, deadlineNs); task.clear(); } } flushTaskWithDeadline:\n1 2 3 4 5 6 private void flushTaskWithDeadline(Task task, long deadlineNs) { long taskDeadlineNs = task.immediate ? RecyclerView.FOREVER_NS : deadlineNs; RecyclerView.ViewHolder holder = prefetchPositionWithDeadline(task.view, task.position, taskDeadlineNs); //省略代码 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private RecyclerView.ViewHolder prefetchPositionWithDeadline(RecyclerView view, int position, long deadlineNs) { RecyclerView.Recycler recycler = view.mRecycler; RecyclerView.ViewHolder holder; holder = recycler.tryGetViewHolderForPositionByDeadline( position, false, deadlineNs); if (holder != null) { if (holder.isBound() \u0026amp;\u0026amp; !holder.isInvalid()) { //如果holder已经绑定过并且是可用的，加入到cacheview缓存中 recycler.recycleView(holder.itemView); } else { //否则加入到RecycledViewPool中 recycler.addViewHolderToRecycledViewPool(holder, false); } } return holder; } 上面通过tryGetViewHolderForPositionByDeadline获取viewholder，和正常获取viewholder的区别是传入了deadlineNs，直接看该方法是如何放弃超时的viewholder：\n1 2 3 4 5 6 7 8 9 10 ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) { if (holder == null) { long start = getNanoTime(); if (deadlineNs != FOREVER_NS \u0026amp;\u0026amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) { return null; } } } 如果deadlineNs不是FOREVER_NS，普通调用该方法传入的deadlineNs是FOREVER_NS，所以是通过该值区分是不是预加载调用的，接着通过willCreateInTime返回值判断要不要放弃：\n1 2 3 4 boolean willCreateInTime(int viewType, long approxCurrentNs, long deadlineNs) { long expectedDurationNs = getScrapDataForType(viewType).mCreateRunningAverageNs; return expectedDurationNs == 0 || (approxCurrentNs + expectedDurationNs \u0026lt; deadlineNs); } expectedDurationNs取的是对应viewholder的平均创建时间，其实也不叫平均时间：\n1 2 3 4 5 6 7 8 9 10 11 void factorInCreateTime(int viewType, long createTimeNs) { ScrapData scrapData = getScrapDataForType(viewType); scrapData.mCreateRunningAverageNs = runningAverage( scrapData.mCreateRunningAverageNs, createTimeNs); } long runningAverage(long oldAverage, long newValue) { if (oldAverage == 0) { return newValue; } return (oldAverage / 4 * 3) + (newValue / 4); } 每次将之前的创建viewholder时间占3分之4，当前创建的时间占1分之4。所以willCreateInTime的返回值是如果当前时间+平均创建viewholder时间小于最晚约定时间则不会放弃，否则直接放弃。如果不放弃接着会判断bind过程有没有超过约定时间：\n1 2 3 4 5 6 7 8 9 10 11 12 13 private boolean tryBindViewHolderByDeadline(@NonNull ViewHolder holder, int offsetPosition, int position, long deadlineNs) { final int viewType = holder.getItemViewType(); long startBindNs = getNanoTime(); if (deadlineNs != FOREVER_NS \u0026amp;\u0026amp; !mRecyclerPool.willBindInTime(viewType, startBindNs, deadlineNs)) { return false; } mAdapter.bindViewHolder(holder, offsetPosition); long endBindNs = getNanoTime(); mRecyclerPool.factorInBindTime(holder.getItemViewType(), endBindNs - startBindNs); return true; } bind过程是通过willBindInTime方法来判断有没有超过约定时间的，整个逻辑很清晰。\n前面分析过如果holder是bind过的，则会加入到cacheview缓存中，否则加入到RecycledViewPool中，正常滑动的时候离屏的viewholder也是添加到cacheview缓存中的，那两者在缓存中又是怎么区分的呢？直接看recycler的recycleViewHolderInternal方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void recycleViewHolderInternal(ViewHolder holder) { //省略代码 //默认插入cacheview缓存的索引是末尾 int targetCacheIndex = cachedViewSize; if (ALLOW_THREAD_GAP_WORK \u0026amp;\u0026amp; cachedViewSize \u0026gt; 0 \u0026amp;\u0026amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) {//如果是正常离屏的viewholder //默认指向最后一个元素 int cacheIndex = cachedViewSize - 1; while (cacheIndex \u0026gt;= 0) { int cachedPos = mCachedViews.get(cacheIndex).mPosition; //如果当前表项不是预拉取的表项则退出 if (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) { break; } cacheIndex--; } targetCacheIndex = cacheIndex + 1; } mCachedViews.add(targetCacheIndex, holder); //省略代码 } 默认插入cacheview缓存的索引是在末尾，在插入正常离屏的viewholder时候如果遇到预拉取的viewholder，则往前找直到最后一个离屏的viewholder，然后插入到它后面。所以不难看出，预拉取的会在后面，离屏的会在前面。这样的好处是预加载的viewholder由于在后面使用的机会会很大，放在集合的后面删除的概率要小。\n参考：掌握这17张图，没人比你更懂RecyclerView的预加载\n","date":"2025-01-17T00:00:00Z","permalink":"https://example.com/p/recyclerview%E7%9A%84%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/","title":"RecyclerView的预加载实现"},{"content":" 关于RecyclerView的优化，其实无非两点，尽可能的最大化使用viewholder的缓存，如果不能使用缓存，将构建和绑定viewholder的过程耗时降低到最低。\n缓存 这里再总结下RecyclerView的缓存知识：\n分类 scrap缓存：用于缓存页面暂时分离的viewholder，分为changeScrap和attachScrap，changeScrap用于缓存要update的viewholder，attachscrap缓存非update的viewholder。 不作用于页面滑动，开发干预不了该缓存。它缓存的个数是一屏的viewholder。 cacheview缓存：是一个arraylist的结构，在滑动的时候，滑出屏幕的viewholder会保存到该缓存中，默认保存的数量是2个，当超过2个的时候，会先移除集合中第一个viewholder，并把该viewholder进行重置。 然后加入到recyclerpool缓存中，最后把新的viewholder加入到cacheview缓存尾部，整个过程，cacheview缓存相当于是一个队列，先进先出的规则。它是根据position来取的，不需要重新bind ViewCacheExtension：mViewCacheExtension又称拓展缓存，为开发者预留的缓存池，开发者可以自己拓展回收池，一般不会用到。 最后就是recyclerpool缓存，它是在cacheview满了的时候，加入到该缓存中的，它是根据viewtype缓存的。在它里面的viewholder都被重置过了的，所以从它里面取出来的viewholder都需要重新bind。 缓存回收 在不滚动情况下： 会把页面上可见的viewholder缓存到scrap中，如果viewholder中有flag_update标记的时候，则把它添加到changeScrap中，否则加入到attachScrap中。 在滚动情况下： 会把滑出recyclerview的viewholder先添加到cacheView缓存中，如果cacheView缓存满了话，会把集合开始的位置viewholder给放到RecycledViewPool中，RecycledViewPool会按照每种viewtype的viewholder为5的容量进行回收，如果超过5个的时候，就不会往里面存了。\n缓存复用 如果是在pre-layout阶段，会去changeScrap缓存中通过position查找viewholder，如果通过position找不到，则通过id去查找，从changeScrap缓存中取出的。 在pre-layout和post-layout阶段会先从attachScrap缓存中通过position查找viweholder，如果没找到则会从cacheview缓存中通过position查找viewholder，如果没找到再通过id从attchScrap和cacheview中找viewholder，如果还没找到，则从ViewCacheExtension中找，如果还没找到则从RecycledViewPool中找，如果都没找到，则创建viewholder，由于changeScrap不参与post-layout阶段，所以在post-layout阶段会走创建表项和绑定表项，attachScrap由于是精准匹配，所以无需创建和绑定，cacheview缓存也是精准匹配，RecycledViewPool中的viewholder由于都重置了，所以需要走绑定。\n缓存说明 scrap缓存只会在非滑动场景下进行保存，并且它保存的数量是一屏的数据，该缓存开发无法干预，cacheview缓存的是可以直接用的viewholder，无需bind和create，但是默认容量很小，可以动态设置，RecycledViewPool里面的viewholder都是重置过的，需要重新bind，按viewtype进行存储，每种viewtype的容量默认是5，也是可以设置大小。而ViewCacheExtension缓存虽然是扩展缓存，但是很少去用，所以可优化的缓存只有cacheview和RecycledViewPool\n如何最大化使用缓存？ 多使用scrap缓存来局部刷新 前面分析过使用notifyDataSetChange的时候会使可见的viewholder和缓存中的viewholder都失效了，导致所有的viewhodler都会先从pool缓存中找一遍，如果有的话，就需要重新bind，如果找不到则先走创建，然后走bind过程，所以局部刷新使用notifyItemChange和notifyItemRemove，如果只是刷新viewholder中的某一个子view，则使用payload的形式。 使用diffutils来实现局部刷新，无需关心刷新的索引，只需要提供变化的数据源 合理使用pool缓存，如果一屏展示的viewholder比较多，则可以适当增加pool缓存的最大数量，减少频繁创建viewholder 合理设置cacheview的缓存，如果recyclerview需要经常来回滑动，则可以适当增加cacheview的缓存数量 重写adapter的getItemId并且给recyclerview设置setHasStableIds为true来给每一个viewholder增加唯一索引，这样在缓存查找的时候能增大复用。 如果两个recyclerview的viewholder有部分相同或者基本相同的情况下，给这两个recyclerview设置同一个RecycledViewPool来增加viewholder的复用度，注意此时给recyclerview设置pool的时候，需要在设置adapter之前 如果同一个recyclerview需要切换视图的时候，并且视图的样式是不同的adapter的时候，此时可以考虑用swapadapter来切换adapter，swapadapter是把attachScrap给清空，并把cacheview中的缓存加入到RecycledViewPool中，而setAdapter是清空所有的缓存。由于swapadapter是复用了RecycledViewPool中的缓存，因此要求前后的viewholder是同一种类型，否则会出现异常。 构建过程如何降低到最低？ 所谓构建就是指viewholder的create过程，该阶段主要是通过解析xml，来创建view，该阶段涉及到文件读取的io操作，以及反射生成view。一般我们可以通过动态创建view的形式来消除io操作和反射生成view。或者将xml的层级降到最低，减少inflate的时间。 提前解析xml，然后存放到缓存池中，等到使用的时候直接从池子中取。 绑定过程如何降低到最低？ 给视图设置监听器的时候，不要通过直接创建listener的形式，通过外界传入进来，然后在外界处理逻辑 绑定视图的时候不要做计算逻辑，将计算逻辑前置化，绑定应该是一个纯展示的过程 其它 如果item的大小是固定的，则使用setHasFixedSize(true)，这样可以避免在更新、添加、删除表项的时候重新requestLayout，而该过程会等到下一个vsync信号来的时候，走绘制流程，然后才是测量，使用该方法后，会给Choreographer发送一条animtion的消息，在下一个vsync来的时候，直接进行recyclerview的dispatchLayout。 开启recyclerview的预加载，recyclerview的预加载默认是开启的，如果要关闭通过layout.setItemPrefetchEnabled(false)来关闭，如果是自定义layoutmanager，则通过重写collectAdjacentPrefetchPositions来实现预加载 recyclerview会加载屏内可见的viewholder，如果viewholder对应的itemview高度或宽度很大的时候，可能加载的屏外viewholder很少，此时重写layoutmanager的calculateExtraLayoutSpace来实现屏外的viewholder加载，关于这块可以看viewpager2如何实现的屏外viewholder的加载。 参考： RecyclerView 性能优化 | 把加载表项耗时减半 (一) 浅谈RecyclerView的性能优化 RecyclerView性能优化之异步预加载 RecyclerView的预加载 【动画图解】这个值取对了，ViewPager2才能纵享丝滑 ","date":"2025-01-13T00:00:00Z","permalink":"https://example.com/p/recyclerview%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","title":"RecyclerView性能优化"},{"content":"大家有没有想过，scrap缓存存在的意义是什么？为什么存了后，又把它里面的viewholder又给删了？\n在上一篇(RecyclerView源码走读)中我们分析过更新和删除表项的过程，下面来总结下scrap缓存的过程：\n更新表项:页面上有表项0到9，总共有10个表项，然后更新表项0，在dispatchLayout1阶段（pre-layout），先把页面上的表项0到9存到scrap缓存中，由于表项0是更新的所以会把表项0放到changeScrap缓存中，把表项1到9存到attachScrap缓存中。同时会把这10个表项从页面上分离（child的parent置空，并把viewgroup中对应的child给置空），接着从scrap缓存中取出viewholder，由于存在更新表项，所以会去创建表项10的viewholder到recyclerview上。此时recyclerview中有11个表项了，同时把他们从scrap缓存中移除。 在dispatchLayout2阶段（post-layout）阶段，会把这11个表项加入到scrap缓存中，表项0还是放到changeScrap中，表项1到10加入到attachScrap缓存中。接着把他们从页面上分离。然后在fill中，从scrap缓存中获取viewholder，由于changeScrap不会在dispatchLayout2阶段生效，所以会创建了表项0，其余的表项正常从attachScrap缓存中获取。接着把所有的表项添加到recyclerview中，并把scrap中的viewholder缓存移除掉。但是表项10不会添加到recyclerview中，因为到表项9的时候，剩余空间就不够了，所以recyclerview中只有0到9的表项。注意：此时还有表项0个表项10分别存在于changeScrap和attachScrap中。\n上面更新表项经历了两次的布局，分别是dispatchLayout1和dispatchLayout2，在这两个步骤中，先加入到scrap缓存中，然后再从scrap缓存中移除。从现象来看，dispatchLayout1中会生成11个表项，分别是0到10，然后在dispatchLayout2先移除所有的表项，然后添加0到9的表项，而在dispatchLayout2中表项0是重新生成的，因为它要实现更新。而调用两次的布局是为了实现动画而这么做，先生成11个表项，来把他们的位置都记录下来，然后第二次布局的时候把10个表项的位置也记录下来，然后最后根据存储的位置信息做动画。下面来分析下动画如何实现的：\n在dispatchLayoutStep1将页面上可见的表项加入到ViewInfoStore中： 1 2 3 4 5 6 7 8 9 void addToPreLayout(RecyclerView.ViewHolder holder, RecyclerView.ItemAnimator.ItemHolderInfo info) { InfoRecord record = mLayoutHolderMap.get(holder); if (record == null) { record = InfoRecord.obtain(); mLayoutHolderMap.put(holder, record); } record.preInfo = info; record.flags |= FLAG_PRE; } 将viewholder和infoRecord绑定好关系，然后给该record添加上FLAG_PRE标记。注意：此处的InforRecord使用了对象池。 前面分析过在fill完之后，页面上会多出一个表项10，此时也会添加到ViewInfoStore中： 可以看到在onLayoutChildren之后会调用addToAppearedInPreLayoutHolders，此时只有表项10会调用addToAppearedInPreLayoutHolders：\n1 2 3 4 5 6 7 8 9 void addToAppearedInPreLayoutHolders(RecyclerView.ViewHolder holder, RecyclerView.ItemAnimator.ItemHolderInfo info) { InfoRecord record = mLayoutHolderMap.get(holder); if (record == null) { record = InfoRecord.obtain(); mLayoutHolderMap.put(holder, record); } record.flags |= FLAG_APPEAR; record.preInfo = info; } 所以只有表项10添加了FLAG_APPEAR标记。\n在dispatchLayoutStep2走完后，页面上可见的表项就只剩0到9了，在dispatchLayoutStep3中将变化的viewholder调用animateChange，而其他的viewholder调用了addToPostLayout，在该例子中表项0会调用animateChange，表项1到9会调用addToPostLayout：\nanimateChange：当有viewholder发生变化的时候，会触发该方法，该方法会触发mItemAnimator的animateChange方法：\n1 2 3 4 5 6 7 8 private void animateChange(@NonNull ViewHolder oldHolder, @NonNull ViewHolder newHolder, @NonNull ItemHolderInfo preInfo, @NonNull ItemHolderInfo postInfo, boolean oldHolderDisappearing, boolean newHolderDisappearing) { //省略代码 if (mItemAnimator.animateChange(oldHolder, newHolder, preInfo, postInfo)) { postAnimationRunner(); } } 调用了mItemAnimator的animateChange方法，并把改变之前的holder、itemholderinfo和改变之后的holder、itemholderinfo传进去了，默认的itemAnimator是DefaultItemAnimator，也是一个SimpleItemAnimator:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Override public boolean animateChange(@NonNull RecyclerView.ViewHolder oldHolder, @NonNull RecyclerView.ViewHolder newHolder, @NonNull ItemHolderInfo preInfo, @NonNull ItemHolderInfo postInfo) { if (DEBUG) { Log.d(TAG, \u0026#34;CHANGED: \u0026#34; + oldHolder + \u0026#34; with view \u0026#34; + oldHolder.itemView); } final int fromLeft = preInfo.left; final int fromTop = preInfo.top; final int toLeft, toTop; if (newHolder.shouldIgnore()) { toLeft = preInfo.left; toTop = preInfo.top; } else { toLeft = postInfo.left; toTop = postInfo.top; } return animateChange(oldHolder, newHolder, fromLeft, fromTop, toLeft, toTop); } fromLeft、fromTop是老的holder的坐标，toLeft、toTop是新的holder的坐标，最后调用了另外一个animateChange：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Override public boolean animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, int fromX, int fromY, int toX, int toY) { if (oldHolder == newHolder) { // Don\u0026#39;t know how to run change animations when the same view holder is re-used. // run a move animation to handle position changes. return animateMove(oldHolder, fromX, fromY, toX, toY); } final float prevTranslationX = oldHolder.itemView.getTranslationX(); final float prevTranslationY = oldHolder.itemView.getTranslationY(); final float prevAlpha = oldHolder.itemView.getAlpha(); resetAnimation(oldHolder); int deltaX = (int) (toX - fromX - prevTranslationX); int deltaY = (int) (toY - fromY - prevTranslationY); // recover prev translation state after ending animation oldHolder.itemView.setTranslationX(prevTranslationX); oldHolder.itemView.setTranslationY(prevTranslationY); oldHolder.itemView.setAlpha(prevAlpha); if (newHolder != null) { // carry over translation values resetAnimation(newHolder); newHolder.itemView.setTranslationX(-deltaX); newHolder.itemView.setTranslationY(-deltaY); newHolder.itemView.setAlpha(0); } mPendingChanges.add(new ChangeInfo(oldHolder, newHolder, fromX, fromY, toX, toY)); return true; } 如果新老holder是同一个，则调用animateMove，前面分析过oldHolder和newHolder不是同一个，所以先把newHolder的translationX和translationX设置到目标位置，其实此时的deltaX和deltaY为0，因为目标的viewholder位置也在原来表项0的位置，接着把透明度设置为0，最后创建了ChangeInfo，放入到mPendingChanges中。当animateChange返回true后，会调用postAnimationRunner方法：\n1 2 3 4 5 6 void postAnimationRunner() { if (!mPostedAnimatorRunner \u0026amp;\u0026amp; mIsAttached) { ViewCompat.postOnAnimation(this, mItemAnimatorRunner); mPostedAnimatorRunner = true; } } ViewCompat.postOnAnimation(this, mItemAnimatorRunner)是给Choreographer中添加一条CALLBACK_ANIMATION类型的事件，等到下一个vsync信号来的时候，就会执行mItemAnimatorRunner：\n1 2 3 4 5 6 7 8 9 private Runnable mItemAnimatorRunner = new Runnable() { @Override public void run() { if (mItemAnimator != null) { mItemAnimator.runPendingAnimations(); } mPostedAnimatorRunner = false; } }; 最终会执行DefaultItemAnimator的runPendingAnimations方法，该方法会执行changesPending的逻辑，最终会执行animateChangeImpl：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 void animateChangeImpl(final ChangeInfo changeInfo) { final RecyclerView.ViewHolder holder = changeInfo.oldHolder; final View view = holder == null ? null : holder.itemView; final RecyclerView.ViewHolder newHolder = changeInfo.newHolder; final View newView = newHolder != null ? newHolder.itemView : null; if (view != null) {//改变之前的view final ViewPropertyAnimator oldViewAnim = view.animate().setDuration( getChangeDuration()); mChangeAnimations.add(changeInfo.oldHolder); oldViewAnim.translationX(changeInfo.toX - changeInfo.fromX); oldViewAnim.translationY(changeInfo.toY - changeInfo.fromY); oldViewAnim.alpha(0).setListener(new AnimatorListenerAdapter() { @Override public void onAnimationStart(Animator animator) { dispatchChangeStarting(changeInfo.oldHolder, true); } @Override public void onAnimationEnd(Animator animator) { oldViewAnim.setListener(null); view.setAlpha(1); view.setTranslationX(0); view.setTranslationY(0); dispatchChangeFinished(changeInfo.oldHolder, true); mChangeAnimations.remove(changeInfo.oldHolder); dispatchFinishedWhenDone(); } }).start(); } if (newView != null) {//改变之后的view final ViewPropertyAnimator newViewAnimation = newView.animate(); mChangeAnimations.add(changeInfo.newHolder); newViewAnimation.translationX(0).translationY(0).setDuration(getChangeDuration()) .alpha(1).setListener(new AnimatorListenerAdapter() { @Override public void onAnimationStart(Animator animator) { dispatchChangeStarting(changeInfo.newHolder, false); } @Override public void onAnimationEnd(Animator animator) { newViewAnimation.setListener(null); newView.setAlpha(1); newView.setTranslationX(0); newView.setTranslationY(0); dispatchChangeFinished(changeInfo.newHolder, false); mChangeAnimations.remove(changeInfo.newHolder); dispatchFinishedWhenDone(); } }).start(); } } 该方法里面通过view的animate方法给view做动画，改变之前的view位置不会发生变化，只会发生alpha的动画，而改变之后的view会做从0到1的透明度动画。所以最终页面上会出现闪的一下，这个是做更新操作。 上面分析的是表项0会调用animateChange，表项1到9会执行addToPostLayout：\n1 2 3 4 5 6 7 8 9 void addToPostLayout(RecyclerView.ViewHolder holder, RecyclerView.ItemAnimator.ItemHolderInfo info) { InfoRecord record = mLayoutHolderMap.get(holder); if (record == null) { record = InfoRecord.obtain(); mLayoutHolderMap.put(holder, record); } record.postInfo = info; record.flags |= FLAG_POST; } 在dispatchLayout1的时候，表项1到9会添加上FLAG_PRE标记，接着在此处又添加上FLAG_POST标记，表项10添加了FLAG_APPEAR标记。所有的标记添加完后，最终会执行ViewInfoStore的process：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void process(ProcessCallback callback) { for (int index = mLayoutHolderMap.size() - 1; index \u0026gt;= 0; index--) { final RecyclerView.ViewHolder viewHolder = mLayoutHolderMap.keyAt(index); final InfoRecord record = mLayoutHolderMap.removeAt(index); if ((record.flags \u0026amp; FLAG_PRE_AND_POST) == FLAG_PRE_AND_POST) { // Persistent in both passes. Animate persistence callback.processPersistent(viewHolder, record.preInfo, record.postInfo); } else if ((record.flags \u0026amp; FLAG_APPEAR) != 0) { // Scrap view. RecyclerView will handle removing/recycling this. } InfoRecord.recycle(record); } } 这里省略了无关紧要的代码，表项1到9会调用callback.processPersistent回调，表项10不做相关更新：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Override public void processPersistent(ViewHolder viewHolder, @NonNull ItemHolderInfo preInfo, @NonNull ItemHolderInfo postInfo) { viewHolder.setIsRecyclable(false); if (mDataSetHasChangedAfterLayout) { // since it was rebound, use change instead as we\u0026#39;ll be mapping them from // stable ids. If stable ids were false, we would not be running any // animations if (mItemAnimator.animateChange(viewHolder, viewHolder, preInfo, postInfo)) { postAnimationRunner(); } } else if (mItemAnimator.animatePersistence(viewHolder, preInfo, postInfo)) { postAnimationRunner(); } } 由于mDataSetHasChangedAfterLayout是在setAdapter中设置的，所以会走mItemAnimator.animateChange逻辑，在上面分析过，如果两个viewholder是同一个，则调用animateMove方法，而位置信息又不发生变化，所以animateChange返回false，因此也不会触发postAnimationRunner。\nrecyclerview中只要被添加到页面上的viewholder，并且是scrap缓存中的，最终都会从scrap缓存中移除。而在上面的例子中，分析dispatchLayout2的时候总共有11个表项，分别是原来的表项0（存在于changeScrap缓存中），dispatchLayout1创建的表项10（存在于attachScrap中）。在dispatchLayout3做完动画后，会清空掉scrap缓存，也就是调用了mLayout.removeAndRecycleScrapInt方法：\n1 2 3 4 5 void removeAndRecycleScrapInt(Recycler recycler) { //省略代码 recycler.clearScrap(); //省略代码 } 最终会调用clearScrap来清空scrap缓存。\n关于删除表项的动画处理，可以看这里:RecyclerView 动画原理 | 如何存储并应用动画属性值？\n","date":"2025-01-09T00:00:00Z","permalink":"https://example.com/p/recyclerview%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86/","title":"RecyclerView动画原理"},{"content":"初始化过程 当我们app收到choregrapher的vsync信号的时候，choregrapher中会给主线程的messageQueue发送一条消息， 告诉app需要绘制了，而此时发送是通过给主线程的messageQueue设置一个callback（runnable），所以会触发handler的dispatchmessage-\u0026gt;handleCallback，接着就是触发FrameDisplayEventReceiver（runnable）的doframe方法，该方法会计算丢帧数，以及执行callbackqueue数组中的callbackqueue，也就执行到了我们的performTraversal方法，该方法里面会执行到measure，最后执行到recyclerview的onMeause，recyclerview的onMeasure中会判断自己的测量模式，如果是精确的模式，则不测量子item。\ntrace图如下： 接着走到recyclerview的onlayout，在onlayout里面触发dispatchlayout，该方法里面会判断state的step，默认是STEP_START，因此会触发dispatchLayoutStep1和dispatchLayoutStep2，在dispatchLayoutStep1中如果有动画要处理，则会触发layoutManager的onlayoutChildren\n有动画的条件是： 有表项新增或移除、有更改的时候。默认是没有动画要处理，紧接着来到了dispatchLayout2，该方法主要是触发了layoutManager.onLayoutChildren。 调用链如下： linearlayoutmanager.fill-\u0026gt;layoutmanager.layoutChunk-\u0026gt;layoutstate.next-\u0026gt;recycler.getviewforposition-\u0026gt;recycler.tryGeyViewHolderForPostionByDeadline-\u0026gt;adapter.createViewHolder-\u0026gt;adapter.bindViewHolder到这里一个holder的创建于bind过程就结束了，紧接着在layoutchunk中触发layoutmanager.addView和layoutmanager.measureChildWithMargin，到这里表项才会被加入到recyclerview中，但是此时不会刷新recyclerview。 上面说到的layoutchunk会在一个while循环中多次执行，直到recyclerview的空间没有了才不会执行，而layoutchunk又会走recycler.next去从缓存中拿viewholder，而此时缓存中没有viewholder，因此会走createviewholder和bindviewholder，所以一开始create和bind次数是一屏能展示多少个表项的次数。 接着在dispatchlayout中会调用dispatchlayoutstep3，该方法里面主要是执行scrap缓存的释放，以及动画的执行\n到这里，测量和layout已经梳理完了，最后就剩draw了： draw里面基本没干什么，还是沿用了viewgroup的drawchild方法，绿色表示非系统方法，因此可以看出来recyclerview是重写了该方法： 总结： 初始化分为onmeasure阶段：如果recyclerview设置了固定宽高，则直接跳过测量，调用到mLayout中，如果不是固定宽高，则会走dispatchLayoutStep1，dispatchLayoutStep2。其中dispatchLayoutStep1是预布局处理，如果有动画要处理才会在该阶段调用到layout的onLayoutChildren。在dispatchLayoutStep2中处理表项的测量。 在onlayout阶段：会判断step还是不是start状态，如果是的话，则再次执行dispatchLayoutStep1和dispatchLayoutStep2。最后调用dispatchLayoutStep3用来做动画执行并释放相关资源。 在draw阶段基本什么都没做，dispatchDraw本身会调用到drawChild，recyclerview只是重写了该方法。\n滑动过程 滑动过程中会调用到scrollByInternal-\u0026gt;layoutmanager.scrollBy-\u0026gt;fill-\u0026gt;layoutchunck。 layoutchunck里面会从缓存中取数据，如果有则命中，没有则走create和bind，接着划出屏幕的表项会先加入到cache缓存中，如果cache缓存满了，则重置该表项，加入到recyclerpool中，下次所以取的时候从recyclerpool根据viewtype取需要重新bind，不需要create，所以在滑动过程中create的次数是cache的大小次数，等到recyclerpool中有缓存的时候就不需要create了。\n在fill过程中，会找到划出屏幕的表项，然后先调用recycleByLayoutState，接着调用到了Linearlayoutmanager.recycleChildren，接着会触发recyclerview.removeAndRecycleViewAt方法，接着就触发了adapter.onViewDetachedFromWindow(viewHolder)，接着就把viewholder缓存到cache和recyclerpool中，对应的方法是recycler.recycleView-\u0026gt;recycleViewHolderInternal,其中cache缓存中默认是2个，如果大于2的话，会把最前面的那个给放到recyclerpool中，接着再把新的viewholder放进来。\n在fiil过程中，会通过LayoutState.next从缓存中获取viewholder，获取的时候会先判断是不是preLayout状态，如果是则从changeScrap缓存中获取，从changeScrap中获取缓存先通过position获取，如果用position获取不到，则再用id去获取（必须adapter设置setHasStableIds为true，并且adapter重写了getItemId）。如果没获取到则从attacheScrap和cache中获取，如果从attach和cache中找不到，则继续通过id从attachScrap中获取，如果还没获取到则从viewcacheExtension中去获取，如果还获取不到则再从recyclerpool中去获取，如果还获取不到则通过create来创建viewholder，接着走bind逻辑。\n所以整个缓存获取顺序： changeScrap(preLayout状态，先通过position获取，没获取到再通过id获取)-\u0026gt;attacheScrap-\u0026gt;cache-\u0026gt;attachScrap(id方式获取)-\u0026gt;viewcacheExtension-\u0026gt;recyclerpool-\u0026gt;createholder-\u0026gt;bindholder 这就是layoutstate.next获取viewholder整个逻辑，上面哪些会触发createholder和bindholder 如果从几个缓存中都拿不到viewholder，则会走createholder的逻辑。\n什么情况下会调用onBindViewHolder？ 不是bound状态 bound标志位：是在bindViewHolder的时候设置的，因此不是bound表示没有bind过。没有bind过有：1，createholder；2，从recyclerpool取的viewholder。 needsUpdate：该状态表示什么？什么时候才会是needUpdate()呢？ 在viewRangeUpdate设置的。猜测是在viewholder发生变化的时候设置的，验证猜想： recyclerview.processAdapterUpdatesAndSetAnimationFlags-\u0026gt;AdapterHelper.preProcess-\u0026gt;applyUpdate-\u0026gt;postponeAndUpdateViewHolders -\u0026gt;markViewHoldersUpdated-\u0026gt;viewRangeUpdate，所以在dispatchLayout1过程中给flag设置了update状态\nisInvalid：表示什么状态？什么时候赋值的？ markKnownViewsInvalid会对所有页面上可见的viewholder设置为FLAG_INVALID，并且把cache缓存中的viewholder设置为FLAG_INVALID，它是在notifydataSetChange时候调用 在holder缓存获取的时候，如果发现holder的viewtype和adapter中重写的viewtype不一致会重置，会给viewholder添加该标志位 从缓存（attachScrap、cacheview）中获取viewholder的时候，如果发现type和holder的type不一致，则会校验不通过。或者设置了stableids为true的时候，如果adapter中的id和holder的id一致，则也通过。 所以结论就是，需要bound的条件：没有bound过（createholder的holder还没有bound过）；needupdate的，holder发生更新了。invalid，从attachscrap、cache获取后， 如果type不一致也需要重新bound，或者是调用了notifydataSetChange后，所有的viewholder都会添加nvalid标志位，此时也需要bind。\n更新表项 notifyItemChange(0)：更新表项第0的位置\n首先是进入页面创建了10个表项，然后更新后日志如下： 首先给我创建了索引为10的表项，也就是屏幕上不可见的，接着又创建了表项0，通过traceview分析： 整体看经历了rv的layout过程，分别对应了dispatchLayoutStep1、dispatchLayoutStep2、dispatchLayoutStep3。\ndispatchLayoutStep1 detachAndScrapAttachedViews 共经历了10次scrapOrRecycleView： 它是反向遍历页面上的view，然后添加到srap缓存中： 从scrapOrRecycleView的调用栈来看，是走了else部分，也就是往scrap缓存中加入viewholder。由于viewHolder的isInvalid为false，所以会走else。 scrap缓存分两种，attachScrap和changeScrap。不是update的会放到attachScrap中，所以我们更新第0个的时候会放到changeScrap中，在detach的时候由于是反向加入到scrap缓存中的，因此我们看第10个的trace调用： 从这里看第0个表项在detach的时候会加入到changeScrap中。 结论：在dispatchLayout1中，先将页面上可见的viewholder从页面上分离，然后将update的viewholder放入到changeScrap中，把非update的viewholder放入到attachScrap中。\nfill fill阶段发生了layoutChunk11次，而我们刚开始列表是初始化了10个表项，那么说明dispatchLayout1阶段添加了一个新的viewholder，关于这块我们可以给出结论，如果viewhodler被设置了remove或者update标记的时候，则会给列表添加一个新的viewholder。关于这块可以看：https://juejin.cn/post/6890288761783975950 在fill的while循环中会判断remainingSpace时候大于0，而每次layoutChunk过程中会将remainingSpace减小，而layoutChunkResult.mIgnoreConsumed就是判断是否要减小，意思是如果不忽略才会减小，那什么时候会忽略呢？ layoutChunk中判断viewholder如果是remove或者是change时候，才会忽略减小。所以我们会有11次的layoutChunk，而最后一次的layoutChunk会走createViewHolder，也就对应了上面的日志先添加了position=10的viewholder。从trace上看下： 结论： dispatchLayout1过程中，将第0个放入到changeScrap中，1-9放入到了attacheScrap中，并且创建了索引为10的viewhodler。\n注意： 在dispatchLayout1过程中，如果viewholder经过了addView之后，则会把它从changescrap或者是attachscrap缓存中移除，所以在dispatchlayout2过程中change和attach的缓存为空的。 其实在dispatchLayout2过程中添加viewholder的view时候也是要从scrap缓存中移除。\ndispatchLayoutStep2 detachAndScrapAttachedViews 由于在dispatchLayout1过程中创建了position=10的viewholder，因此会有11次，这11个里面第0个还是添加到了changeScrap中，1-10是添加到attachScrap中。\nfill 为什么此过程只有10次layoutChunck呢？这块其实还是回到remainingSpace的计算说起： 所以在dispatchLayout2过程中当添加到索引等于9的时候remainingSpace就为0了，所以索引等于10的时候添加不上，因此只会有10次layoutChunck。\nlayoutChunck 我们可以看到第0个走了createViewholder和bindViewholder： 是由于第0个viewholder被添加到了changeScrap缓存中，而1-9的viewholder添加到了attachScrap中，而changeScrap只会在pre-layout过程中才会生效： 所以可以看到上面日志中会走了position=0的createViewHolder和bindViewHolder。\n总结: 更新表项的时候，会经历dispatchLayout1，dispatchLayout2，其中在dispatchLayout1（pre-layout阶段）会先把可见的表项给回收到scrap缓存中，回收后，会把可见的表项从recyclerview中分离，其中需要变化的表项会加入到 changeScrap中（第1个表项），不变化的加入到attachScrap中（第2个到第10个表项）。接着在fill阶段会从scrap缓存中取表项，由于有表项更新，所以此时会去创建不可见的表项（第11个表项），最后会添加到recyclerview上。 在dispatchLayout2（post-layout阶段）同样会把dispatchLayout1添加进来的表项给添加到changeScrap（第1个表项）和attachScrap（第2个到第11个表项）缓存中，注意此时的表项会是11个表项。在fill阶段会去创建表项0， 因为post-layout阶段不会去取changeScrap中的viewholder，所以表项0会经历创建。\n删除表项 notifyItemRemove(0)\ndispatchLayout1 detachAndScrapAttachedViews 调用了10次scrapOrRecycleView 第0个调用scrapView添加到attachScrap缓存中 1-9的表项也是添加到attachScrap缓存中，这个可以从trace中看到。 fill 和update过程一样，在dispatchlayout1有11次layoutChunk，delete和update的viewholder不作为消费remainingSpace。 接着调用layoutstate.next获取viewholder，此时只有索引等于10的时候会去创建viewholder。注意了：此时创建完viewholder后，bind过程传的position=9： 在bind过程中会传入postion=10，而此时的mPostponedList中有一个op是remove类型的，所以postion会减一，因此它的postion是9： dispatchLayout2 detachAndScrapAttachedViews 此处scrapOrRecyclerview发生了11次，因为在dispatchLayout1创建了一个新的viewholder，11个viewholder都加入到了attachScrap缓存中。 fill layoutChunk调用了10次： 在第一个viewholder获取的时候获取到原来的第二个表项了，原来的第一个表项的position被置为-1了，所以我们0-9的表项都不会重新创建viewholder。也就对应上面的日志。 疑问： 此处的position赋值貌似都重新赋值了，因此我们看下是哪里重新赋值了： 当调用notifyItemRemove(0)的时候，在dispatchlayout1过程中会触发offsetPositionRecordsForRemove方法，该方法会通过remove的itemCount数重新给每一个页面上的viewhodler重新给赋上position的值，所以会看到上面的attachScrap缓存中最后一个viewholder的postion=-1了。 scrap缓存 在fill之前会把页面上的viewholder先detach掉，最终会调用到viewgroup的detachViewFromParent方法，removeView也会调用该方法，只不过viewholder的detach不会立马requestLayout。接着就是调用scrapView。 scrap缓存分两种，一种是attach、另外一种是change，如果viewholder是发生了变化（notifyItemChange），则会加入到change中，否则加入到attach中。接着在layoutChunk过程中，会从scrap缓存中找viewholder。 在dispatchLayout3过程中，会调用layout.removeAndRecycleScrapInt方法： 里面会调用recycler.clearScrap： 会清空scrap缓存。 总结：scrap缓存在每次layoutChild之前会先把页面的viewholder先放到scrap缓存中，在dispatchLayout3的时候，会把该缓存清空掉。\nAdapter.onViewAttachedToWindow 刚进入屏幕会触发onViewAttachedToWindow，从0-9都打印了。 从trace来看，初次每个viewholder都会经历onViewAttachedToWindow方法。\n下面看看什么时候不会调用onViewAttachedToWindow方法？ 每次在layoutChunk的时候，从缓存中去拿viewholder，如果从scrap缓存中拿到了，则不触发childHelper的addView，也就不会触发adapter.onViewAttachedToWindow；如果当前view的parent是当前recyclerview的时候，也不触发childhelper的addview。如果都不满足则触发adapter.onViewAttachedToWindow。\n滑动的时候是否触发？ 滑动过程中表项从不可见到可见会触发onViewAttachedToWindow，因为它不是从scrap缓存中获取到的，它是从cache缓存或者是recyclerpool中获取的。onViewAttachedToWindow触发不一定会触发oncreateViewHolder，也不一定会触发onBindViewholder。如果cache缓存和pool缓存中都没有该viewholder，则会触发oncreateViewHolder和onBindViewholder。如cache中有，则只触发onViewAttachedToWindow。如果从pool中拿到缓存，则会触发onBindViewholder和onViewAttachedToWindow。\n更新列表是否会触发？ 拿上面更新表项0来看，由于在dispatchLayout1(pre-layout)过程中会创建表项10，所以会经历表项10的oncreate和onbind，并且把它添加到rv中，所以会有一次的表项10的onViewAttachedToWindow，接着会在dispatchLayout2过程中会创建表项0（因为表项0存在了changeScrap缓存中），所以会走表项0的onViewAttachedToWindow。\nAdapter.onViewDetachedFromWindow 滑动过程中，划出屏幕的表项会调用onViewDetachedFromWindow。\nfindViewHolderForAdapterPosition和findViewHolderForLayoutPosition区别： 结论：正常情况下adapterPostion和layoutPosition是相等的，当有add、remove、move的时候两者是不一样的。adapterPostion会算上要改变的表项，比如上面我要删除第一个表项，那么拿到的表项就是第二个。而layoutPostion是页面最终呈现的表项，上面例子中等到post完后，才会真正的删除掉。所以post（绘制后）后layoutposition获取到的是原来的第二个表项。\nnotifydatasetChange问题 先是把页面上所有的都detach掉，然后又走了所有的viewholder的onbind过程，从索引为5的viewholder走了oncreateviewholder。下面看下trace： layout过程只走了dispatchLayout2，在里面走到了linearlayoutManager.onLayoutChildren，里面会触发fill。在fill之前会走detach逻辑，里面会反向遍历可见的子view，并调用scrapOrRecylerview： 每一个子view回收都走了removeViewAt: 此处由于所有的viewholder都是invalid状态了，因为在notifyDatasetChange在调用requestLayout之前把页面上的子view都设置成invalid状态了： 所以在fill之前都会调用removeViewAt，而该方法会触发onViewDetachedFromWindow，因此可以看到前面日志中先反向打印了9-\u0026gt;0的onViewDetachedFromWindow。接着会调用recycler.recycleViewHolderInternal，该方法是把viewholder加入到cache或者是recyclerpool中： 如果存在invalid状态，则会把viewholder加入到pool缓存中，trace验证下： 而pool缓存是5个，因此先把9-\u0026gt;5存到poo中时，发现pool满了，则把9给移除掉，因此最后只剩下5个viewholder在pool中。接着在layoutChunk阶段，会从缓存中拿viewholder的时候，只有pool中5个viewhold的缓存，取完一个remove掉一个，当索引为5的时候，pool中已经拿完了，因此5-9会去创建viewholder。\n参考：\nRecyclerView 缓存机制 | 如何复用表项？ RecyclerView 缓存机制 | 回收些什么？ RecyclerView 缓存机制 | 回收到哪去？ RecyclerView缓存机制 | scrap view 的生命周期 ","date":"2025-01-02T00:00:00Z","permalink":"https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/","title":"RecyclerView源码走读"},{"content":"suspendCoroutine 在android中无处不在获取view的宽高，而获取宽高是需要在view绘制完后才能获取，所以这是一个时机问题，通常通过view.post来获取，那么用协程如何形如同步获取宽高呢？下面来试试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 GlobalScope.launch { val wh = getViewWh(view) Log.d(TAG, \u0026#34;width:${wh.first}\u0026#34;) Log.d(TAG, \u0026#34;height:${wh.second}\u0026#34;) } Log.d(TAG, \u0026#34;outer coroutine\u0026#34;) private suspend fun getViewWh(view: View) = suspendCoroutine\u0026lt;Pair\u0026lt;Int, Int\u0026gt;\u0026gt; { continuation -\u0026gt; view.post { val width = view.width val height = view.height continuation.resume(Pair(width, height)) } } 日志如下：\n1 2 3 11:00:57.708 D outer coroutine 11:00:57.810 D width:1080 11:00:57.810 D height:2206 使用了suspendCoroutine方法，方法的返回值，是suspendCoroutine指定的泛型。 可以看到日志正常获取，下面来看看字节码是如何实现的： launch启动的时候，内部的协程代码块编译结果是SuspendCoroutineActivity$onCreate$1： 调用了SuspendCoroutineActivity的静态方法access$getViewWh：\n静态方法是直接调用了成员方法getViewWh，它是本次的重要实现：\n传进来的Continuation对应了SuspendCoroutineActivity$onCreate$1，它是传给了SafeContinuation，此处注意到调用了continuation的intercepted方法，它是continuation的扩展方法，它是在continuationImpl中实现了，它实际是看context中是否有dispatcher，这块在协程切换线程中讲过，它实际是生成了一个CoroutineDispatcher。\n接着看又调用了SuspendCoroutineActivity$getViewWh$2$1这个suspendLambda，并把SafeContinuation传进去了： 此处的Runnable就对应了post中的代码块，最终在run方法中调用了continuation的resumeWith方法，并把宽高回调出去了。此处的continuation是SafeContinuation，看下它的resumeWith方法： 此处的result默认值是UNDECIDED： 由于默认值是UNDECIDED，在上面getViewWh中先调用了safeContinuation的getOrThrow方法： 所以会给result设置上了COROUTINE_SUSPENDED标记，所以在第一个suspendLambda的invokeSuspend方法中能被挂起，等到执行safeContinuation的resumeWith的时候，第一个suspendLambda就恢复了。最终获取到结果，整个流程就结束。\nsuspendCoroutine的回调中还有一个resumeWithException方法，用于返回失败的结果，如果返回失败的时候，需要捕捉异常。\nsuspendCancellableCoroutine 它和suspendCoroutine区别是回调中是一个CancellableContinuationImpl，它提供了cancel方法，当cancel的时候，程序不会崩溃。它会把cancel的结果分发到delegate中，此处的delegate其实就是对应了GlobalScope.launch启动时的suspendLambda，最后它会分发到父job中。看下CancellableContinuationImpl的cancel方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public override fun cancel(cause: Throwable?): Boolean { _state.loop { state -\u0026gt; if (state !is NotCompleted) return false // false if already complete or cancelling // Active -- update to final state val update = CancelledContinuation(this, cause, handled = state is CancelHandler || state is Segment\u0026lt;*\u0026gt;) if (!_state.compareAndSet(state, update)) return@loop // retry on cas failure // Invoke cancel handler if it was present when (state) { is CancelHandler -\u0026gt; callCancelHandler(state, cause) is Segment\u0026lt;*\u0026gt; -\u0026gt; callSegmentOnCancellation(state, cause) } // Complete state update detachChildIfNonResuable() dispatchResume(resumeMode) // no need for additional cancellation checks return true } } 此处会构造出CancelledContinuation，它是CompletedExceptionally对象，这个其实就是协程异常的扩展类，最终把该对象设置到CancellableContinuationImpl的state上。 一路跟到DispatchedTask的dispatch方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 internal fun \u0026lt;T\u0026gt; DispatchedTask\u0026lt;T\u0026gt;.dispatch(mode: Int) { assert { mode != MODE_UNINITIALIZED } // invalid mode value for this method val delegate = this.delegate val undispatched = mode == MODE_UNDISPATCHED if (!undispatched \u0026amp;\u0026amp; delegate is DispatchedContinuation\u0026lt;*\u0026gt; \u0026amp;\u0026amp; mode.isCancellableMode == resumeMode.isCancellableMode) { // dispatch directly using this instance\u0026#39;s Runnable implementation val dispatcher = delegate.dispatcher val context = delegate.context if (dispatcher.isDispatchNeeded(context)) { dispatcher.dispatch(context, this) } else { resumeUnconfined() } } else { // delegate is coming from 3rd-party interceptor implementation (and does not support cancellation) // or undispatched mode was requested resume(delegate, undispatched) } } 此处会走dispatcher.dispatch逻辑，因为上面的GlobalScope.launch其实创建的dispatcher是一个Dispatcher.Default类型的。DispatchedTask是一个runnable接口，看下它的run方法： 最终也是通过continuation的resumeWithException方法回调出去，然后交给了父job去处理，此时的exception是一个CancellationException，其实上面的suspendCoroutine也可以通过resumeWithException回调一个CancellationException，程序也不会崩溃。\n参考：https://juejin.cn/post/7121517604644061192\n","date":"2024-12-30T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/","title":"协程如何优雅的处理异步回调"},{"content":"案例一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private fun demo1() { val handler = CoroutineExceptionHandler { coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;onCreate: CoroutineExceptionHandler:${throwable.message}\u0026#34;) } GlobalScope.launch(handler) { Log.d(TAG, \u0026#34;onCreate: parentJob start\u0026#34;) withContext(Dispatchers.IO) { throw RuntimeException(\u0026#34;runtime exception\u0026#34;) delay(1000) Log.d(TAG, \u0026#34;onCreate: withContext end\u0026#34;) } Log.d(TAG, \u0026#34;onCreate: parentJob end\u0026#34;) } } 先上日志：\n1 2 com.example.coroutinescopedemo D onCreate: parentJob start com.example.coroutinescopedemo D onCreate: CoroutineExceptionHandler:withContext runtime exception 异常能被launch指定的handler所捕捉。 分析： launch启动的协程用到的coroutineScope是一个StandaloneCoroutine，withContext启动的协程对应的coroutineScope是一个DispatchedCoroutine。 在withContext中发生异常的时候，首先会回调到DispatchedCoroutine的resumeWith，最终会走到finalizeFinishingState方法，该方法里面会判断是否存在异常，如果有异常会调用cancelParent方法：\n可以看到如果isScopedCoroutine为true的时候，cancelParent直接返回true，如果返回true，那么就不触发自己的上面的handleJobException，也就是把异常继续往上抛了。例子中也就是launch对应的StandaloneCoroutine。而在StandaloneCoroutine中不会去cancelParent，所以会把异常交给了handleJobException了，所以上面的launch中传入的CoroutineExceptionHandler能捕获到该异常。\n总结：如果子job中在处理异常的时候，cancelParent中如果isScopedCoroutine为true的时候，则不触发自己的handleJobException，也就是把异常交给了父job，如果父job不处理该异常，则会程序崩溃。\n案例二 上面代码如果把withContext中的异常通过try-catch住，父job就收不到该异常了： 子携程把异常catch住后，父协程的handler捕捉不到异常，并且父协程的invokeOnCompletion收不到异常，并且父协程之后的代码也能正常执行。\n案例三 子协程给context传递coroutineExceptionHandler： 子协程抛了异常，然后子协程也传了CoroutineExceptionHandler，但是子协程的CoroutineExceptionHandler不起作用，还是把异常传给了父协程。并且父协程的invokeOnCompletion收到了异常回调，而且发现父协程的invokeSuspend方法也没走完，所以onCreate: parentJob end没有输出。\n分析：前面已经分析过withContext开启的协程对应的coroutineScope是一个DispatchedCoroutine重写了isScopedCoroutine=true，如果它为true，cancelParent方法则返回true，那么它自己的handleJobException就不会触发，所以就不会走到自己的CoroutineExceptionHandler回调了。\n案例四 当子协程抛的是CancellationException，父协程捕捉不到该异常： 此处handler没有捕捉到异常，并且程序也没崩溃，这是因为在子协程把异常回调给父协程后，父协程对应的scope，也就是StandaloneCoroutine在cancelParent中判断是CancelationException，它直接返回true，所以不会调用handleJobException方法，而向外抛异常的正是该方法。所以当子协程抛出CancellationException时候不会使父协程崩溃。\n案例五 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 private fun demo2() { val handler = CoroutineExceptionHandler { coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;handler:${throwable.message}\u0026#34;) } val job = Job() val coroutineScope = CoroutineScope(job + handler) val job1 = coroutineScope.launch { delay(100) Log.d(TAG, \u0026#34;job1 end\u0026#34;) throw RuntimeException(\u0026#34;runtime exception\u0026#34;) } job1.invokeOnCompletion { Log.d(TAG, \u0026#34;job1 invokeOnCompletion:${it?.message}\u0026#34;) } val job2 = coroutineScope.launch { delay(200) Log.d(TAG, \u0026#34;job2 end\u0026#34;) } job2.invokeOnCompletion { Log.d(TAG, \u0026#34;job2 invokeOnCompletion:${it?.message}\u0026#34;) } val job3 = coroutineScope.launch { delay(300) Log.d(TAG, \u0026#34;job3 end\u0026#34;) } job3.invokeOnCompletion { Log.d(TAG, \u0026#34;job3 invokeOnCompletion:${it?.javaClass?.simpleName}\u0026#34;) Log.d(TAG, \u0026#34;job3 invokeOnCompletion:${it?.message}\u0026#34;) } } 日志如下：\n1 2 3 4 5 6 com.example.coroutinescopedemo D job1 end com.example.coroutinescopedemo D handler:runtime exception com.example.coroutinescopedemo D job2 invokeOnCompletion:Parent job is Cancelling com.example.coroutinescopedemo D job1 invokeOnCompletion:runtime exception com.example.coroutinescopedemo D job3 invokeOnCompletion:JobCancellationException com.example.coroutinescopedemo D job3 invokeOnCompletion:Parent job is Cancelling 数据结构:父协程的job启动了三个子协程，在job1中抛出异常，job2和job3收到了JobCancellationException。其中父job是一个JobImpl对象，在每个子协程启动过程中都会创建一个ChildHandleNode对象，其中job指向了父Job，也就是JobImpl，childJob指向了当前子job，也就是StandaloneCoroutine，最后在子Job中通过parentHandle指向了父job，state指向了InvokeOnCompletion(是通过invokeOnCompletion添加的)。父job中通过state指向了一个NodeList，每一个next节点指向了三个子job。\n异常处理:当第一个job发生异常后，会通知自己的state中的InvokeOnComplete接口，所以job1中收到了runtime exception的信息，它是原始的失败信息。接着会调用到job1的cancelParent逻辑，该方法中会调用到parentHandle的childCancelled逻辑，它是一个ChildHandleNode对象，在它的childCancelled方法中，会触发父job的childCancelled方法，最终会来到父job的cancelImpl方法。该方法里面会去取消子job，是通过遍历state节点，调用里面的每一个ChildHandleNode的invoke方法，在invoke里面会调用到childJob的parentCancelled方法，里面会给每一个job的state设置上JobCancellationException，由于第一个job已经有exception了，也就是原始exception，所以job2和job3会设置上JobCancellationException异常。接着子协程会递归调用notifyHandlers通知子协程发生异常了，直到没有子协程为止。 当所有的子协程处理完异常后，会调用到父job的CoroutineExceptionHandler的回调。当回调完后，父job会给自己的state添加异常，防止在resumeWith中往下执行逻辑。其中给state添加异常是通过Finishing.addExceptionLocked添加异常信息。\n子协程invokeOnCompletion接口回调执行时机？\n在异常处理阶段，父协程会调用到ChildHandleNode中的invoke方法，继而会触发childJob的parentCancelled方法，最终会在notifyHandlers中触发invokeOnCompletion的回调。 子协程的job为什么在添加完异常后resumeWith不会被执行？\n在协程job中在执行resumeWith的时候，调用到tryMakeCompleting时，会判断state，如果不是Incomplete状态，则直接返回，不会往下执行。 父协程在cancelImpl的时候除了取消子协程还做了什么？\n在取消完子协程的时候，给第一个child添加了ChildCompletion回调，该回调执行的时候会执行到continueCompleting，最终会回到自己处理异常的逻辑。 案例六 把案例五中的Job()换成SupervisorJob()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 private fun demo3() { val handler = CoroutineExceptionHandler { coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;handler:${throwable.message}\u0026#34;) } val coroutineScope = CoroutineScope(SupervisorJob() + handler) val job1 = coroutineScope.launch { delay(100) Log.d(TAG, \u0026#34;job1 end\u0026#34;) throw RuntimeException(\u0026#34;runtime exception\u0026#34;) } job1.invokeOnCompletion { Log.d(TAG, \u0026#34;job1 invokeOnCompletion:${it?.message}\u0026#34;) } val job2 = coroutineScope.launch { delay(200) Log.d(TAG, \u0026#34;job2 end\u0026#34;) } job2.invokeOnCompletion { Log.d(TAG, \u0026#34;job2 invokeOnCompletion:${it?.message}\u0026#34;) } val job3 = coroutineScope.launch { delay(300) Log.d(TAG, \u0026#34;job3 end\u0026#34;) } job3.invokeOnCompletion { Log.d(TAG, \u0026#34;job3 invokeOnCompletion:${it?.javaClass?.simpleName}\u0026#34;) Log.d(TAG, \u0026#34;job3 invokeOnCompletion:${it?.message}\u0026#34;) } } 只是换了个job，job1还是一样收到了原始异常，job2和job3正常执行，并能执行完。按照上面分析，当job1发生异常的时候，会调用到cancelParent，它会分发到父job的childCancelled方法，而SupervisorJob重写了该方法直接返回false。所以异常不会分发到子协程中，当job1的cancelParent返回false的时候，会执行到handleJobException，而job1使用的context中的CoroutineExceptionHandler是使用的父job中指定的CoroutineExceptionHandler。因为context是plus叠加的方式。所以最后handler中收到了异常。\n以下的案例来自于https://juejin.cn/post/7049537608262615070\n案例七 结果：try-catch竟然捕获不住，程序直接抛异常了\n此处try-catch的位置不在子协程的SuspendInvoke位置，它是在主协程的launch位置，其实它是在invokeSuspend中调用内部launch的时候加了try-catch，对应的class代码如下：\n从字节码来看，只是启动子协程的时候给try-catch，从原理上分析，当子协程发生异常后，会调用父协程的cancelChild，在父job里面会调用到cancelParent，而父job(shi 也就是JobImpl)，它的parentHandle是空，所以cancelParent的方法返回false，因此会调用到handleJobException，而父job没有传handler，因此程序会崩溃。 上面的案例，其实可以理解为launch启动的协程中再启动一个lanuch协程，然后try-catch捕捉位置在外层lauch上，此时是捕捉不到异常的\n案例八 结果：此处不会发生异常，异常被exceptionHandler捕捉 因此当父job接收到异常后，会将异常传递到handleJobException方法中，而父job是有handler的，所以将异常回调到了handler中，程序不会崩溃。\n案例九 结果：程序崩溃了，不会被子协程的handler捕捉到异常\n因为当子协程异常的时候，会把异常抛给了父job，而父job又没有处理该异常，所以程序崩溃了\n案例十 结果：程序不会崩溃，异常被try catch捕获住，而不是被exceptionHandler捕获住。\n前面分析过当子协程发生异常后，会把异常分发给到父job，在父job中需要等子job都处理完异常了，才会往下走，该处逻辑主要体现在子job中添加了一个ChildCompletion节点到state中，在invoke中会执行到parent.continueCompletion方法： 此处的parent实际是coroutineScope启动的协程对应的job，它是ScopeCoroutine，看下它的continueCompleting实现： 最终会把结果回调给到了传递进来的continuation，也就是最外层launch启动的时候的SuspendLambda，最终会调用它的invokeSuspend方法： 所以最终被try-catch捕捉到异常。\n案例十一 结果：程序被内层launch指定的exceptionHandler捕捉了 supervisorScope用到的job是SupervisorCoroutine，它重写了childCancel方法，并返回false，所以当子job发生异常的时候，不会抛给父job，并执行自己的handleJobException方法，所以被自己的handler捕获到。\n案例十二 此时被外层launch的handler所捕捉，原因是异常抛给了父job。\n案例十三 此时被内层launch的handler所捕捉，原因是supervisorScope启动的协程不会往上抛，交给了子协程自己处理。\n","date":"2024-12-17T00:00:00Z","image":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AD%90%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/cover_hu17536845123992820283.jpg","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AD%90%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"协程中子协程异常处理"},{"content":"invokeOnCompletion监听协程状态 在了解协程的异常处理之前，先来熟悉下协程之间job是如何绑定关系，还是通过一个例子来熟悉他们之间的关系：\n1 2 3 4 5 6 7 8 private fun demo(){ val job = GlobalScope.launch { Log.d(TAG, \u0026#34;demo: launch代码\u0026#34;) } job.invokeOnCompletion { Log.d(TAG, \u0026#34;demo: invokeOnCompletion\u0026#34;) } } 执行结果：\n1 2 CoroutineJobActivity com.example.coroutinescopedemo D demo: launch代码 CoroutineJobActivity com.example.coroutinescopedemo D demo: invokeOnCompletion 可以看出来invokeOnCompletion是job执行完毕的回调。\n通过launch创建协程内部会构造一个StandaloneCoroutine，它就是一个job，并且launch返回的就是该job： StandaloneCoroutine继承自AbstractCoroutine： 因此parentHandle为NonDisposableHandle，然后方法结束。 此时执行完launch后，继续执行了job的invokeOnCompletion方法，它是一个抽象方法，实现方法在jobSupport类： 我们看下makeNode方法实现： 从调用链上看onCancelling传进来的是false，并且此时的handler还不是一个JobNode节点，所以会创建了一个InvokeOnCompletion对象，并把外面传进来的ComppletionHandler传到InvokeOnCompletion中，看下InvokeOnCompletion对象：\n1 2 3 4 5 private class InvokeOnCompletion( private val handler: CompletionHandler ) : JobNode() { override fun invoke(cause: Throwable?) = handler.invoke(cause) } InvokeOnCompletion是一个JobNode节点：\n1 2 3 4 5 6 7 8 9 10 internal abstract class JobNode : CompletionHandlerBase(), DisposableHandle, Incomplete { /** * Initialized by [JobSupport.makeNode]. */ lateinit var job: JobSupport override val isActive: Boolean get() = true override val list: NodeList? get() = null override fun dispose() = job.removeNode(this) override fun toString() = \u0026#34;$classSimpleName@$hexAddress[job@${job.hexAddress}]\u0026#34; } JobNode实现了CompletionHandlerBase抽象类：\n1 2 3 internal actual abstract class CompletionHandlerBase actual constructor() : LockFreeLinkedListNode(), CompletionHandler { actual abstract override fun invoke(cause: Throwable?) } 它也是实现了CompletionHandler接口，CompletionHandler是一个闭包，从上面继承以及JobNode实现来看，在它的invoke实现里面，会触发传进来的CompletionHandler的invoke实现，从实现来看其实这就是个静态代理的模式。\n结论： makeNode内部会返回一个InvokeOnCompletion对象，它是一个JobNode节点。\n回到上面的invokeOnComletion的实现，创建了InvokeOnCompletion后，会走到loopOnState的函数，它是遍历state，它的初始状态是一个Empty状态，并且state.isActive=true。所以最终把刚才创建的InvokeOnCompletion设置到了state上，并且返回了该InvokeOnCompletion。\n结论： 当调用了job的invokeOnCompletion方法后，会把外界创建好的CompletionHandler传给了InvokeCompletion，InvokeCompletion是一个JobNode，在它的invoke实现中，会回调到外界的CompletionHandler中。并且把创建的InvokeCompletion设置到当前job的state上了。\n协程体执行完job的执行： 在之前分析协程体其实是一个SuspendLambda，在它的invokeSuspend调用完后，会执行它的continuation的resumeWith方法，在上面例子中其实是StandaloneCoroutine，它是一个job，所以看下它的resumeWith实现：\n1 2 3 4 5 public final override fun resumeWith(result: Result\u0026lt;T\u0026gt;) { val state = makeCompletingOnce(result.toState()) if (state === COMPLETING_WAITING_CHILDREN) return afterResume(state) } 将协程体的结果传到了makeCompletingOnce方法中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 internal fun makeCompletingOnce(proposedUpdate: Any?): Any? { loopOnState { state -\u0026gt; val finalState = tryMakeCompleting(state, proposedUpdate) when { finalState === COMPLETING_ALREADY -\u0026gt; throw IllegalStateException( \u0026#34;Job $this is already complete or completing, \u0026#34; + \u0026#34;but is being completed with $proposedUpdate\u0026#34;, proposedUpdate.exceptionOrNull ) finalState === COMPLETING_RETRY -\u0026gt; return@loopOnState else -\u0026gt; return finalState // COMPLETING_WAITING_CHILDREN or final state } } } 轮训获取state，并调用了tryMakeCompleting方法： 从上面的分析知道state它是一个JobNode，它是一个InvokeCompletion，它不是一个ChildHandleNode，并且proposedUpdate不是CompletedExceptionally，所以会执行tryFinalizeSimpleState： 内部调用了completeStateFinalization方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private fun completeStateFinalization(state: Incomplete, update: Any?) { /* * Now the job in THE FINAL state. We need to properly handle the resulting state. * Order of various invocations here is important. * * 1) Unregister from parent job. */ parentHandle?.let { it.dispose() // volatile read parentHandle _after_ state was updated parentHandle = NonDisposableHandle // release it just in case, to aid GC } val cause = (update as? CompletedExceptionally)?.cause /* * 2) Invoke completion handlers: .join(), callbacks etc. * It\u0026#39;s important to invoke them only AFTER exception handling and everything else, see #208 */ if (state is JobNode) { // SINGLE/SINGLE+ state -- one completion handler (common case) try { state.invoke(cause) } catch (ex: Throwable) { handleOnCompletionException(CompletionHandlerException(\u0026#34;Exception in completion handler $state for $this\u0026#34;, ex)) } } else { state.list?.notifyCompletion(cause) } } 该方法中判断state是否是JobNode，如果是的话，会调用invoke方法。在上面分析过state是一个InvokeOnCompletion对象，在它的invoke里面会回调到传进来的CompletionHandler的invoke中，所以在上面例子中打印了job执行完成的日志。\ninvokeOnCompletion监听job的异常 还是通过一个例子来分析下：\n1 2 3 4 5 6 7 8 9 10 11 12 private fun demo3(){ val exceptionHandler =CoroutineExceptionHandler{ coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;demo3: CoroutineExceptionHandler--异常信息：${throwable?.message}\u0026#34;) } val job = GlobalScope.launch(exceptionHandler) { Log.d(TAG, \u0026#34;demo3: launch代码\u0026#34;) throw RuntimeException(\u0026#34;协程体里面发生异常了\u0026#34;) } job.invokeOnCompletion { Log.d(TAG, \u0026#34;demo3: invokeOnCompletion--异常信息：${it?.message}\u0026#34;) } } 此处用了一个CoroutineExceptionHandler方法，来创建CoroutineExceptionHandler对象来拦截异常的，这块先不用管，我们看下日志：\n1 2 3 com.example.coroutinescopedemo D demo3: launch代码 com.example.coroutinescopedemo D demo3: CoroutineExceptionHandler--异常信息：协程体里面发生异常了 com.example.coroutinescopedemo D demo3: invokeOnCompletion--异常信息：协程体里面发生异常了 可以看出来，invokeOnCompletion中也能收到异常的消息。 但是异常和正常收数据可能不太一样，主要区别是在resumeWith之后的处理不太一样： 如果是非异常的话，会走tryFinalizeSimpleState；如果是异常的时候会走tryMakeCompletingSlowPath，在该方法里面会触发finalizeFinishingState方法，该方法有个很重要逻辑： 由于cancelParent返回false，所以会触发handleJobException，StandaloneCoroutine重写了该方法： handleCoroutineException： 如果context中CoroutineExceptionHandler不为空，则异常不会往上抛了，所以此例中定义了context的CoroutineExceptionHandler程序不会崩溃。 回到上面再来看invokeOnCompletion的CompletionHandler触发时机，它是在finalizeFinishingState中触发，接着会调用到completeStateFinalization，最终在里面触发了invokeOnCompletion传进来的CompletionHandler。\n协程异常try住：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private fun demo4() { val exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;demo4: CoroutineExceptionHandler--异常信息：${throwable?.message}\u0026#34;) } val job = GlobalScope.launch(exceptionHandler) { try { Log.d(TAG, \u0026#34;demo4: launch代码\u0026#34;) throw RuntimeException(\u0026#34;协程体里面发生异常了\u0026#34;) } catch (e: Exception) { Log.d(TAG, \u0026#34;demo4: catch中代码\u0026#34;) } } job.invokeOnCompletion { Log.d(TAG, \u0026#34;demo4: invokeOnCompletion--异常信息：${it?.message}\u0026#34;) } } 日志如下：\n1 2 3 com.example.coroutinescopedemo D demo4: launch代码 com.example.coroutinescopedemo D demo4: catch中代码 com.example.coroutinescopedemo D demo4: invokeOnCompletion--异常信息：null 从日志中看，此处的CoroutineExceptionHandler不回调，并且invokeOnCompletion收不到异常信息。 我们通过字节码可以看到原因： 此处的异常catch住后，给到JobSupport就不是异常了，所以按照成功的处理方式一样。\n总结： job初始化阶段：通过引入invokeOnCompletion方法，来熟悉job如何分发异常，在上面事例中，通过launch启动的协程，它对应的job是StandaloneCoroutine，它的父类是AbstractCoroutine，在它的构造方法里面会调用initParentJob方法，该方法就是构建父job和当前job的关系，由于上面launch启动的协程的父job是空的，因此parentHandle指向了NonDisposableHandle对象。接着当调用了invokeOnCompletion方法的时候，会构造InvokeOnCompletion对象，并把业务方构造的CompletionHandler传到了InvokeOnCompletion对象中，当InvokeOnCompletion对象的invoke被调用的时候，会调用到外界传入的CompletionHandler的invoke方法。InvokeOnCompletion是一个JobNode对象，最终会被添加到job的state上。 job执行阶段：前面我们分析过SuspendLambda执行完invokeSuspend逻辑后，会接着调用上级continuation的resume方法，通过resumeWith-\u0026gt;makeCompletingOnce-\u0026gt;tryMakeCompleting。 异常处理：接着会判断是不是异常类型，如果是异常类型，则会触发tryMakeCompletingSlowPath-\u0026gt;finalizeFinishingState-\u0026gt;completeStateFinalization，其中在finalizeFinishingState是job处理异常的关键逻辑，如果cancelParent为false，则表示父job不处理异常，则会调用自己的handleJobException方法，在该方法中看context中是否有CoroutineExceptionHandler，如果有则捕获到异常，将异常分发给CoroutineExceptionHandler。如果没有则将异常往上抛，直到程序崩溃。如果不崩溃会在completeStateFinalization中拿到job的state中的InvokeOnCompletion对象，然后触发外界传入的CompletionHandler。 非异常处理：如果是非异常在tryMakeCompleting中会走tryFinalizeSimpleState-\u0026gt;completeStateFinalization，最终也会触发到InvokeOnCompletion对象。\nInvokeOnCompletion类图 异常处理流程图 ","date":"2024-12-16T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"协程的异常处理"},{"content":"首先看一个例子： 日志如下： 和withContext的区别是launch后面的代码无需等到async执行完才执行。 字节码如下： launch部分启动的协程的invokeSuspend逻辑里面，只有label0的逻辑，和withContext不同的是会有挂起部分的判断，所以是同步执行的。\nasync的异步执行： 日志如下： 可以看到async2是先执行的，因为它没有进行delay，等到两个async执行完了后，才会执行launch里面的代码。 字节码如下： 编译后的代码： label=0的时候，通过async启动了两个协程，我们这里叫async1和async2，并且在里面通过await挂起了launch启动的协程。 分析：async1调用await后，由于状态是COROUTINE_SUSPENDED，所以第一次invokeSuspend方法结束，此时label=1。等到await逻辑执行完后，又会第二次执行invokeSuspend方法，此时由于lable=1，会执行async2的await方法，此时返回COROUTINE_SUSPENDED，所以invokeSuspend第二次结束，此时label=2。等到async2的await执行完后，第三次执行invokeSuspend方法，由于此时label=2，所以此时切回到自己的线程，执行launch部分的代码逻辑。\n总结： async的同步执行是因为没有挂起SuspendLambda的invokeSuspend方法，所以父协程不会挂起，而await方法是挂起函数，默认是返回COROUTINE_SUSPENDED，所以父协程挂起，当子协程逻辑执行完后，会回调父协程的invokeSuspend，当再次执行invokeSuspend的时候，label值发生了变化，因此会执行launch部分的逻辑。\n","date":"2024-11-28T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/","title":"协程的同步执行原理"},{"content":"先来一个例子： 日志如下： 可以看到上面先是执行了withContext中的代码，然后执行了launch中的代码，注意到launch中也是在单独线程中执行的，其中launch中使用的Dispatcher是Dispatchers.Default类型的。前面分析过launch调度情况，最后会执行到continuation的resumeWith，然后调用它的invokeSuspend方法： 可以看到先执行withContext，因为withContext启动的时候，默认的状态是COROUTINE_SUSPENDED，所以退出了invokeSuspend方法，返回了var2，此时的label=1了。当执行完withContext的时候，会通知传给withContext的continuation，也就是上面的CoroutineDispatchersActivity$demo2$1这个SuspendLambda。所以会再次执行它的invokeSuspend方法，此时lable=1，所以最后返回了Unit.INSTANCE，整个invokeSuspend结束，这就是挂起的原因。 至于为什么在CoroutineDispatchersActivity$demo2$1中遇到了返回值为COROUTINE_SUSPENDED时候，不会继续执行了呢？看下BaseContinuationImpl中的resumeWith逻辑： 在BaseContinuationImpl的resumeWith中，如果invokeSuspend返回值是COROUTINE_SUSPENDED，则直接return了，不往上层的continuation调用了。\n至于再次执行CoroutineDispatchersActivity$demo2$1的invokeSuspend方法是在什么时候，可以追溯到withContext中： 执行了block的startCoroutineCancellable： 此处很熟悉啊，这不又启动了一个协程吗？协程套协程啊。好吧，我们直接看completion的回调，在协程挂起函数执行完后，会执行complete的resumeWith方法，此处是DispatchedCoroutine对象，继承自ScopeCoroutine： 它是先取continuation中context的ContinuationInterceptor，也就是上面launch启动的dispatchers，对应的是Dispatchers.Default，最终执行Dispatchers的resumeCancellableWith方法，在该方法里面最终会在协程指定的线程中执行协程代码块。所以在上面日志中能看到withContext执行完后，launch之后的代码能回到指定的线程中执行。\nwithcontext执行完了后会执行外面协程的resumeWith，所以launch的invokeSuspend再次执行。再次执行的时候会回到自己的线程。真相大白了！\n总结： 首先每一个协程代码块都会被编译成SuspendLambda对象，它也是一个Continuation对象，每次在执行到SuspendLambda的resume时候，都会去执行invokeSuspend方法，而该方法里面会去执行子协程，如果子协程返回COROUTINE_SUSPENDED状态的时候，父协程的resume方法会直接return了。当子协程执行完后，会通知父协程，此时父协程的的invokeSuspend方法再次被执行，而此时的状态机会发生变化，如果此时状态恢复后，会执行父协程中的Continuation，也就是父父协程的执行。\n","date":"2024-11-15T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E6%8C%82%E8%B5%B7%E5%8E%9F%E7%90%86/","title":"协程挂起原理"},{"content":"在上一节介绍过Dispatchers.IO，它是一个CoroutineDispatcher对象，CoroutineDispatcher的执行是在DispatchedContinuation中的resumeCancellableWith方法，如果CoroutineDispatcher的isDispatchNeeded返回true，则会执行CoroutineDispatcher的dispatch方法。否则直接执行该runnable。\nDispatchers.Main 在安卓平台下，它其实是一个HandlerContext对象： 看下它的isDispatchNeeded和dispatch方法： 此时invokeImmediately默认是false，因此isDispatchNeeded返回true。所以会执行它的dispatch方法。在dispatch方法中将runnable给到了主线程的消息队列中，然后等主线程从消息队列中取该runnable。所以在上一节例子中它是晚于onCreate方法执行的。\nDispatchers.Main.immediate 它是HandlerContext中的immediate变量: 可以看到它是新创建了一个HandlerContext，并且invokeImmediately是true。在上一节的例子中，它的isDispatchNeeded返回false。所以它是直接执行SuspendLambda的resumeWith方法，因此上一节例子中它是要早于Dispatchs.Main执行的。\nDispatchers.IO 看下它的CoroutineDispatcher，对应的子类是DefaultIoScheduler，CoroutineDispatcher的isDispatchNeeded方法默认返回true，所以会执行它的dispatch方法： 在dispatch方法中调用了default的dispatch方法，default实际是一个LimitedDispatcher对象，看下它的dispatch方法： 在上面2处，判断当前runningWokers的数量，如果大于parallelism的时候，则不创建Worker，此处的parallelism的大小是64。从此处也能看出来Dispatchers.IO的线程数量不会超过64个。 最终该方法里面会通过DefaultScheduler.dispatchWithContext来创建CoroutineScheduler，来看下创建线程池的几个参数： 核心线程数： 最小2个，最大是cpu的核数。 最大线程数： 最大线程数取值(1 shl BLOCKING_SHIFT) - 2：最终得到的值是2^21-2 = 2097150。 非核心线程空闲时间是60s。\n结论：Dispatchers.IO指定的线程池最少线程数是cpu的核数，最大线程数是64个。\nDispatchers.Default 它是由DefaultScheduler构建的线程池，它所创建的最大的线程个数为:Math.max(2,cpu核数)。 上面两者在源码中主要体现在通过CoroutineScheduler的corePoolSize来控制最大线程数，而上面的Dispatchers.IO的最大64个线程其实在LimitedDispatcher中通过runningWorkers的原子类来控制着最大的任务数，当超过64个任务的时候，就不允许往里面添加了。它是通过把任务添加到queue中，如果当前正在执行的任务数小于64个的时候，才会从queue取走最前面的task，如果当前大于正在执行大于64个，则不会从queue中取最前面的task。\nDispatchers.IO和Dispatchers.Default都是由DefaultScheduler构建的，而DefaultScheduler其实是一个单例，因此不难看出它两是共用一个线程池的，只不过当Dispatchers.IO时候，最大线程个数控制在Math.min(64,cpu核数)，最多不会超过64个，Dispatchers.Default控制在cpu核数个数上。Dispatchers.Default常用作cpu密集型的任务，比如图片模糊处理、繁杂的计算型可以用这种类型的线程池。Dispatchers.IO由于它的线程数量多，并且它不能消耗cpu资源，因此常用作io处理，文件读写等操作上。 关于这点，可以看这篇文章：dispatcher拆解\n","date":"2024-11-13T00:00:00Z","image":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/cover_hu17536845123992820283.jpg","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/","title":"协程中的线程"},{"content":"在讲解如何切换线程之前，有必要先了解下CoroutineScope。协程作用域，它里面持有CoroutineContext，用来管理它的作用域范围内的所有协程。\nCoroutineScope(协程作用域) CoroutineScope组成 可见它只是一个接口，里面定义了一个coroutineContext。前面介绍过coroutineContext是协程的上下文，它里面是由Element拼接而成的，而Element主要分为如下几种：\nCoroutineDispatcher：它是线程分发器。其中Dispatcher.IO和Dispatcher.Main、Dispatchers.Main.immediate都是继承自于它 Job：它是用来取消协程、父协程与子协程取得联系的桥梁。常见的有SupervisorJob CoroutineName：用来给协程起名字的作用 CoroutineExceptionHandler：它是用来捕捉协程异常的回调器 所以完整的CoroutineContext组成部分如下： job+dispatchers+CoroutineName+CoroutineExceptionHandler\nCoroutineScope分类 目前kotlin已经内置了各种CoroutineScope，下面来说下他们的区别\nGlobalScope 上面用到的GlobalScope就是一个协程作用域： 可以看出来它是一个单例的scope，生命周期和app保持一致，并且它的context是一个EmptyCoroutineContext。平时开发时候不会去用它\nrunBlocking 是一个阻塞式的协程作用域，会阻塞协程外面的线程，内部是通过java的LockSupport.park阻塞住线程来实现的。 MainScope 它是一个指定协程分发在主线程中，并且使用到的Job是SupervisorJob，它的作用是当子协程出错的时候，不影响到父协程中的其他子协程 它是一个ContextScope，继承自CoroutineScope，并且它的context是由SupervisorJob()和Dispatchers.Main组成的一个context。我们一般自定义CoroutineScope的时候也是定义一个ContextScope，他的构造方法需要传入一个CoroutineContext。 CoroutineScope顶级方法 它也是一个ContextScope，它的上下文先看传进来的context中的job是否为空，如果为空，则初始化一个job。如果不为空，则使用传进来的context。\ncoroutineScope顶级方法 它是一个suspend方法，它是通过闭包的形式返回一个CoroutineScope，对应的字节码如下： 会将ScopeCoroutine给到block，也就是闭包中的CoroutineScope，接着会调用UndispatchedKt.startUndispatchedOrReturn: 最终调用了block.invoke方法，写个demo看下效果： 日志如下： 从日志可以看出来，它是先等到coroutineScope里面delay执行完了，才执行外面的逻辑。在字节码层面，它会把coroutineScope外面的代码编译成SuspendLambda，它也是个Continuation，等到执行完了coroutineScope内部的代码，才会回调到coroutineScope外面的SuspendLambda中来： 上面分析过UndispatchedKt.startUndispatchedOrReturn中调用了block的invoke方法，此处的block正对应了CoroutineDispatchersActivity$demo7$1这个SuspendLambda对象： 在demo7中将CoroutineDispatchersActivity$demo7$1这个continuation传递到coroutineScope中，而它的invoke方法如下： 创建了CoroutineDispatchersActivity$demo7$1后，继而调用了invokeSuspend方法，而invokeSuspend里面是要等到coroutineScope闭包中的delay挂起结束后，才会再次回到invokeSuspend方法，最后才会输出「demo7: coroutineScope outside」的日志，这也是协程挂起的调用顺序。\nsupervisorScope顶级方法 它和上面的coroutineScope顶级方法差不多，也是先调用完闭包中的逻辑，然后才执行supervisorScope外面的代码。看下它的实现就知道区别了： 他所使用的CoroutineScope是一个SupervisorCoroutine，它和上面用到的ScopeCoroutine区别是重写了childCancelled方法，并返回false，此方法是子协程发生异常后，该不该取消其它的子协程，下面来验证下： 在supervisorScope闭包中launch1发生异常了，由于supervisorScope不会去处理异常，将异常交给了launch1处理，所以launch2中的代码能继续执行。而在coroutineScope中，当launch1发生异常的时候，会将异常交给了coroutineScope，最终导致launch2的协程无法继续执行。\nJob Job实现了CoroutineContext.Element，可以用来取消、启动一个协程，并且和父协程绑定了关系： 它下面有几个关键的子类： 从图上可以看出来前面分析的coroutineScope和supervisorScope两个顶级方法所使用的作用域ScopeCoroutine最终也是一个Job。\n线程例子 先看一个例子： 分别指定了四种线程的用法，日志如下： 第一次： 第二次： Dispatchers.Main.immediate：指定的主线程会最先执行 Dispatchers.Main：指定的主线程会晚于协程外面的主线程 Dispatchers.IO和Dispatchers.Default：指定的线程没有先后之分\nCoroutineScope.lanuch lanuch方法是协程作用域的扩展方法，比如上面例子中的GlobalScope它就是继承自CoroutineScope:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public fun CoroutineScope.launch( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -\u0026gt; Unit ): Job { //① val newContext = newCoroutineContext(context) //② val coroutine = if (start.isLazy) LazyStandaloneCoroutine(newContext, block) else StandaloneCoroutine(newContext, active = true) //③ coroutine.start(start, coroutine, block) //④ return coroutine } 参数： context：launc传进来的context，比如上面例子中传进来的Dispatchers.Main、Dispatchers.IO这些都是CoroutineContext。如果没传就用EmptyCoroutineContext。 start：CoroutineStart的枚举类，表示启动模式，默认是DEFAULT block：协程代码块，是一个CoroutineScope的扩展挂起函数 将外界传进来的context和当前CoroutineScope的context进行合并处理 默认是DEFAULT模式，所以会初始化一个StandaloneCoroutine，会把newContext作为自己的parentContext，它既是一个Continuation，也是一个CoroutineScope 调用StandaloneCoroutine的start方法，并把启动模式，StandaloneCoroutine，协程挂起函数传进去了 StandaloneCoroutine作为lauch的返回值 StandaloneCoroutine它是一个Job类型，也是继承自AbstractCoroutine，看下它的start方法： 这里调用了start变量的invoke方法，因为CoroutineStart重写了invoke方法，所以能直接这么调，相当于是一个闭包的调用方式，这里调用了三参的invoke： 第一个参数：挂起函数闭包，也就是协程要执行的代码块 第二个参数：start方法传进来的StandaloneCoroutine 第三个参数：start方法传进来的this，也是StandaloneCoroutine CoroutineStart是DEFAULT类型，所以会调用挂起函数的startCoroutineCancellable方法： 在上面分析createCoroutine时候也是通过createCoroutineUnintercepted(receiver, completion).intercepted()，创建了delegate，最终是一个Continuation，也是一个suspendLambda。我们直接看ContinuationImpl的intercepted方法： intercepted方法里面取context变量中的key为ContinuationInterceptor的context，而context最终是completion的context，completion是前面start方法传进来的StandaloneCoroutine，它是继承自AbstractCoroutine： parentContext是launch方法传进来的context+CoroutineScope自己的context拼接的一个context this：AbstractCoroutine实现了job接口，job也是一个CoroutineContext 在上面例子中lauch方法是通过GlobalScope启动的，它的context是一个EmptyCoroutineContext，所以传给AbstractCoroutine的parentContext其实就是launch方法传进去的context，也就是Dispatchers.io、Dispatchers.main等。 回到ContinuationImpl的intercepted方法，取context的ContinuationInterceptor,然后调用interceptContinuation方法，看下Dispatchers.io，它最终继承自CoroutineDispatcher： 结论： 如果lauch传的是Dispatchers.io，则lauch先创建DispatchedContinuation，然后调用resumeCancellableWith方法： 如果dispatcher.isDispatchNeeded（默认是true），才会进入到dispatch逻辑，看下dispatchers.io： 调用了default.dispatch方法，diefault是由UnlimitedIoScheduler.limitedParallelism创建的LimitedDispatcher，最终会执行到UnlimitedIoScheduler.dispatch方法： DefaultScheduler的dispatchWithContext方法如下： coroutineScheduler创建如下： 最终会执行到CoroutineScheduler的dispatch方法，里面的代码就不细看了，是线程池部分执行block，关于这部分后面可以深究下，而block是在DispatchedContinuation中resumeCancellableWith方法里面把this给到了dispatcher的dispatch方法，说明DispatchedContinuation实现了Runnable接口，直接看它的run方法，该方法定义在它的父类DispatchedTask中： 此处执行了delegate的resume方法，resume方法执行了resumeWith，注意此处的delegate是DispatchedContinuation中传进来的continuation，它是createCoroutineUnintercepted(receiver, completion).intercepted()创建的delegate，是一个continuation对象，也是suspendlambda，在上面创建协程分析过baseContinuationImpl的resumeWith方法，里面会执行协程的invokeSuspend方法，也就是我们的协程执行代码。执行完了后会执行complete的resumeWith，而通过lauch创建的协程，此处的complete是launch方法构造的StandaloneCoroutine对象，它的resumeWith方法定义在AbstractCoroutine中： AbstractCoroutine的afterCompletion： 此处没有逻辑执行。 我们注意到在讲解协程启动的时候，创建delegate的continuation时候调用createCoroutineUnintercepted只传了complete，没有传receiver。而在launch启动协程时候，将StandaloneCoroutine作为receiver传给了createCoroutineUnintercepted方法： 默认的挂起函数的create方法是抛异常的，需要SuspendLambda的子类自己去实现： 编译后的SuspendLambda的子类create实现： 此处将receiver传到create中没有用到，所以其实跟单参没有什么区别啊。\n总结 结论：协程在启动过程中会取CoroutineContext中的ContinuationInterceptor，然后执行interceptContinuation。而此时如果是一个Dispatchers.IO，它又是继承自CoroutineDispatcher，所以会执行到了CoroutineDispatcher的interceptContinuation。此时得到的是一个DispatchedContinuation对象，并把当前的CoroutineDispatcher和协程启动过程中创建的StandaloneCoroutine传给了DispatchedContinuation。接着会执行DispatchedContinuation的resumeCancellableWith方法，在该方法里面会判断CoroutineDispatcher.isDispatchNeeded，如果是的话，会调用CoroutineDispatcher的dispatch方法，最终会通过线程池会执行到DispatchedContinuation的run方法，因为它是一个Runnable对象。在run方法里面，会执行continuation的resume方法，而此处的continuation是编译器给我们创建的SuspendLambda的子类，最终会执行它的invokeSuspend方法。执行完后会执行协程启动过程中的StandaloneCoroutine的resumeWith方法。\n时序图: ","date":"2024-11-05T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E7%BA%BF%E7%A8%8B/","title":"协程如何切换线程"},{"content":" 在讲协程的如何切换线程之前，有必要先了解下协程的上下文是什么？它的结构是什么样的？以及我们如何使用它？今天带着该问题来认识它。\nCoroutineContext 协程上下文都是继承自CoroutineContext，它是一个接口，内部方法以及内部类如下：\n它的实现子类有如下：\n比如我们常见的EmptyCoroutineContext，它的内部实现如下：\n可以看到它的get、fold、plus、minusKey几个方法都是默认实现，你可以理解它就是个空壳子的context。\nElement 在讲CoroutineContext内部结构之前，先来认识下Element，它也实现了CoroutineContext接口：\nElement中有一个key的属性，这里可以理解key就是当前Element的唯一标识。实现一个context的时候需要指明它的key是啥，此处就是用该key来标识 get：如果传进来的key和自己的key相等，则返回自己，否则返回null fold：将初始值和当前element返回给lambda，让lambda自己去处理 minusKey：如果传进来的key和自己相同，则返回EmptyCoroutineContext，否则返回自己，其实是删除对应key的context.\n写了3个context，然后用\u0026quot;+\u0026ldquo;拼接：\n自定义context的时候，需要继承自AbstractCoroutineContextElement，它是继承自Element，因为它强制要求需要一个key作为context的标识，一般key的element标识是当前context，看上面的One这个context，它的key拥有的element是One。\n输出日志如下：\nOne()+Two()+Three()得到的是一个CombinedContext，get方法通过One这个key取到了One这个取对应的Context\n日志如下： 可以看到我给One的context拼接了一个EmptyCoroutineContext时候，得到的是它自己，\u0026quot;+\u0026ldquo;是重载了context的plus方法，看下plus方法的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public operator fun plus(context: CoroutineContext): CoroutineContext = //① if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation //② context.fold(this) { acc, element -\u0026gt; //③ val removed = acc.minusKey(element.key) //③.1 if (removed === EmptyCoroutineContext) element else { // make sure interceptor is always last in the context (and thus is fast to get when present) //④ val interceptor = removed[ContinuationInterceptor] //⑤ if (interceptor == null) CombinedContext(removed, element) else { //⑥ val left = removed.minusKey(ContinuationInterceptor) //⑦ if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else //⑧ CombinedContext(CombinedContext(left, element), interceptor) } } } 1.如果传进来的context是EmptyCoroutineContext，则返回自己，所以上面的One()+EmptyCoroutineContext，得到的是One这个context 2.context.fold，会把初始值和context传给闭包，所以acc是当前context，element是传进来的context 3.acc.minuskey(element.key)，如果传进来的context的key和当前context的key相等，则返回传进来的context，所以新的context会把旧的context给覆盖掉了 4.如果传进来的context的key和当前context的key不相等，removed则是当前context，查看当前context中是否有ContinuationInterceptor类型的context，我们的dispatcher都是属于该类型，需要单独处理 5.如果context中没有ContinuationInterceptor类型的context，则初始化出一个CombinedContext的context，所以上面的One()+Two()+Three()是一个CombinedContext的context 6.如果当前context中存在ContinuationInterceptor类型的context，则继续判断当前context是不是ContinuationInterceptor类型的context 7.如果是ContinuationInterceptor类型的context，则把传进来的context和当前的context组合成CombinedContext的context 8.如果当前的context不是一个ContinuationInterceptor类型的context，则把当前当前的context和传进来的context新组合成一个CombinedContext的context，再和前面的ContinuationInterceptor组合成一个新的CombinedContext的context\nCombinedContext 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 internal class CombinedContext( private val left: CoroutineContext, private val element: Element ) : CoroutineContext, Serializable { override fun \u0026lt;E : Element\u0026gt; get(key: Key\u0026lt;E\u0026gt;): E? { var cur = this while (true) { cur.element[key]?.let { return it } val next = cur.left if (next is CombinedContext) { cur = next } else { return next[key] } } } public override fun \u0026lt;R\u0026gt; fold(initial: R, operation: (R, Element) -\u0026gt; R): R = operation(left.fold(initial, operation), element) public override fun minusKey(key: Key\u0026lt;*\u0026gt;): CoroutineContext { //① element[key]?.let { return left } //② val newLeft = left.minusKey(key) return when { //③ newLeft === left -\u0026gt; this //④ newLeft === EmptyCoroutineContext -\u0026gt; element //⑤ else -\u0026gt; CombinedContext(newLeft, element) } } override fun toString(): String = \u0026#34;[\u0026#34; + fold(\u0026#34;\u0026#34;) { acc, element -\u0026gt; if (acc.isEmpty()) element.toString() else \u0026#34;$acc, $element\u0026#34; } + \u0026#34;]\u0026#34; } 它是直接继承自CoroutineContext，有两个比较重要的属性：\nleft：CoroutineContext，它是左边的节点\nelement：Element，当前节点\n其实和链表的结构有点类似，left相当于next节点。\nget：递归节点，直到left节点不是CombinedContext类型的\nfold：先把left和初始值组成一个初始值，然后再把这个初始值和当前节点传给闭包\nminusKey：\n1.如果当前节点中找到了该key，则返回left节点\n2.如果找不到，则继续在left节点中找\n3.如果找不到返回this\n4.如果找到了则返回当前节点\n5.否则继续往左边再找\n整个分析来看，协程中的context如果是多个context拼接的时候如果传进来的是EmptyCoroutineContext，则只保存自己。如果传进来的context的key和当前context的key一样，则会覆盖掉原来的context。如果都不满足，则采用链表的形式插入到原来的context头节点上，如果传进来的是ContinuationInterceptor类型的，则会把该类型放到头节点。\n总结 CoroutineContext是协程重要的对象，它通过重载了plus方法，轻松的将每一个CoroutineContext拼接成一个新的CoroutineContext，一般的CoroutineContext会分为EmptyCoroutineContext，它是直接实现了CoroutineContext接口，可以理解它是没有任何信息的CoroutineContext。而Element是带有key的CoroutineContext，所以如果往CoroutineContext添加一个Element会通过它的key来找到对应的Element，Element下面常见的子类有ContinuationInterceptor，它是我们协程切换线程的CoroutineContext，还有常见的CoroutineExceptionHandler，它是我们协程捕捉异常的CoroutineContext，还有常见的Job，它是我们协程构建结构化的CoroutineContext，还有不常用的CoroutineName，它是用来给协程起名字的CoroutineContext。在通过+(plus)拼接CoroutineContext的时候，如果发现传进来的是EmptyCoroutineContext，则还是返回自己，如果不是EmptyCoroutineContext则会拼接成一个CombinedContext，它是一个链表结构的CoroutineContext，如果在+过程中发现要添加的CoroutineContext已经存在于原有的CoroutineContext中，则会用新的覆盖掉原有的CoroutineContext。但是在CombinedContext中会将ContinuationInterceptor类型的CoroutineContext放到链表的最前面。\n再来一张本次讲解的context类图：\n","date":"2024-11-04T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87/","title":"协程上下文"},{"content":"kotlin中inline，noinline，crossinline区别？ 默认函数中如果没加inline，那就是非内联函数，此时lambda会生成一个新的类，该类是继承自Lambda抽象类，并实现了Function接口，其中invoke方法就是Function接口的方法，invoke中的方法就是lambda代码块的代码。 内联函数(加inline关键字)的lambda如果没加noinline或crossinline，默认会把lambda的代码块给平铺到调用处，所以此时如果在lambda中加return的话，会直接不执行外层函数后续代码。如果是非内联函数的话，由于它是生成一个单独的类，不存在平铺代码，所以return是编译不过去的。 noinline和inline是对立关系，它是将lambda不内联处理，如果你需要对该lambda作为对象来使用的时候，此时需要用到noinline，如果一个内联函数都是noinline的lambda表达式，那么此时as会提示你此处可以去掉inline关键字了，当做普通的高阶函数来处理就行。 默认内联函数是能添加return来作为局部返回，由于存在平铺代码的特性，所以它能阻止调用lambda的外层函数的执行，那如果lambda作为间接调用的时候，此时添加return语句会编译失败，因为间接调用（比如匿名内部类或回调）不能阻止外层函数的调用，是为了避免多线程或回调中意外终止外层函数，所以kotlin编译器此时需要你添加crossinline，举个例子就清楚了： 此处的run闭包，它的调用是在runnable接口中的，此时编译器提示it may contain non-local returns，意思是此时存在间接调用，在间接调用lambda的时候，不允许在lambda中添加return来阻止外层的外层函数的执行。所以此处通过添加crossinline来阻止lambda中添加return 疑惑：crossinline添加后，内联效果还在吗？还是以上面的例子来说明： 假如上面的hello方法我就作为普通的方法，如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 object TestInline1 { @JvmStatic fun main(args: Array\u0026lt;String\u0026gt;) { hello { println(\u0026#34;hello的闭包\u0026#34;) } } fun hello(run: () -\u0026gt; Unit) { val runnable = Runnable { println(\u0026#34;runnable run\u0026#34;) run() } runnable.run() } } 对应的字节码如下： 如果我把它作为内联函数来处理，如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 object TestInline1 { @JvmStatic fun main(args: Array\u0026lt;String\u0026gt;) { hello { println(\u0026#34;hello的闭包\u0026#34;) } } inline fun hello(crossinline run: () -\u0026gt; Unit) { val runnable = Runnable { println(\u0026#34;runnable run\u0026#34;) run() } runnable.run() } } 对应的字节码如下： 可以看出来crossinline还是有内联效果，闭包直接在runnable中平铺开来了。 相关文档：https://juejin.cn/post/6869954460634841101 java lambda和kotlin lambda区别 在java中如果使用匿名内部类的形式，在编译时它是会单独生成一个类，其中类名是「外部类名$index.class」这种形式。如果使用lambda的形式，它不会在编译时单独生成一个类，它是执行了invokedynamic指令，在运行时动态生成lambda的类，其中类名是「外部类名$Lambda$index.class」这种形式。 参考:https://juejin.cn/post/7004642395060961310 kotlin lambda它是在编译时看是否需要生成单独的类，如果是内联的时候就直接平铺代码，如果是非内联的时候才生成单独的类。 协程是怎么挂起的？怎么恢复的？ 首先每一个协程代码块都会被编译成SuspendLambda对象，它也是一个Continuation对象，每次在执行到SuspendLambda的resume时候，都会去执行invokeSuspend方法，而该方法里面会去执行子协程，如果子协程返回COROUTINE_SUSPENDED状态的时候，父协程的resume方法会直接return了。当子协程执行完后，会通知父协程，此时父协程的的invokeSuspend方法再次被执行，而此时的状态机会发生变化，如果此时状态恢复后，会执行父协程中的Continuation，也就是父父协程的执行。 协程中的dispather是怎么指定在哪个线程上执行的？ 首先dispather它是CoroutineContext（上下文）的一部分，在协程启动过程中，会取CoroutineContext中的CoroutineDispathcer部分。此时会构造一个DispathedContinuation对象，并把前面取到的Dispather传到DispathedContinuation中，此时会将DispathedContinuation扔到线程池中，最终会执行DispathedContinuation的run方法，在run里面会执行到SuspendLambda，也就是协程的代码块，最终会执行它的invokeSuspend方法。所以协程代码块中代码要执行在哪个线程是协程上下文的dispather部分指定的线程。 相关文档：https://www.xiangcman.fun/p/%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E7%BA%BF%E7%A8%8B/\nLinkedList特性 LinkedList继承自Deque，它是一个双端队列，允许在队列的两端插入和删除元素。可以作为栈（LIFO）或队列（FIFO）使用。基于链表（双向链表）实现，可以高效地插入和删除元素。 offer：给链表尾部插入元素，返回值表示是否插入成功 peek：取出头部节点，如果没有则返回null poll：取出头部节点，如果没有则返回null，取完后并把头部节点从队列中移除 remove：移除头部节点，如果没有头部节点则抛异常，有的话，则返回 push：给链表头部插入元素，没有返回值 pop：和remove一样的，都是移除头部节点，如果没有头部节点则抛异常，有的话，则返回\n如果想实现队列的话，则使用offer和poll这一对方法；如果想实现栈的话，可以通过offerLast和pollLast来实现，或者通过offerFirst和pollFirst来实现。\nArrayDeque特性 它也是继承自Deque，和LinkedList的特性一样的，只不过ArrayDeque是通过数组实现的双端队列，内部用一个数组来放所有的节点，并且有两个int值用来存放头结点和尾结点的索引。并且ArrayDeque内部的默认节点容量是16个，也可以初始化容量大小。\n区别：如果频繁要插入和删除操作，那么使用LinkedList，如果是查询情况比较多，可以优先使用ArrayDeque。\nPools.Pool 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 class Pools private constructor() { /** * Interface for managing a pool of objects. * * @param T The pooled type. */ interface Pool\u0026lt;T : Any\u0026gt; { /** * @return An instance from the pool if such, null otherwise. */ fun acquire(): T? /** * Release an instance to the pool. * * @param instance The instance to release. * @return Whether the instance was put in the pool. * * @throws IllegalStateException If the instance is already in the pool. */ fun release(instance: T): Boolean } /** * Simple (non-synchronized) pool of objects. * * @param maxPoolSize The maximum pool size * @param T The pooled type. */ open class SimplePool\u0026lt;T : Any\u0026gt;( /** * The max pool size */ @IntRange(from = 1) maxPoolSize: Int ) : Pool\u0026lt;T\u0026gt; { private val pool: Array\u0026lt;Any?\u0026gt; private var poolSize = 0 init { require(maxPoolSize \u0026gt; 0) { \u0026#34;The max pool size must be \u0026gt; 0\u0026#34; } pool = arrayOfNulls(maxPoolSize) } override fun acquire(): T? { if (poolSize \u0026gt; 0) { val lastPooledIndex = poolSize - 1 @Suppress(\u0026#34;UNCHECKED_CAST\u0026#34;) val instance = pool[lastPooledIndex] as T pool[lastPooledIndex] = null poolSize-- return instance } return null } override fun release(instance: T): Boolean { check(!isInPool(instance)) { \u0026#34;Already in the pool!\u0026#34; } if (poolSize \u0026lt; pool.size) { pool[poolSize] = instance poolSize++ return true } return false } private fun isInPool(instance: T): Boolean { for (i in 0 until poolSize) { if (pool[i] === instance) { return true } } return false } } /** * Synchronized pool of objects. * * @param maxPoolSize The maximum pool size * @param T The pooled type. */ open class SynchronizedPool\u0026lt;T : Any\u0026gt;(maxPoolSize: Int) : SimplePool\u0026lt;T\u0026gt;(maxPoolSize) { private val lock = Any() override fun acquire(): T? { synchronized(lock) { return super.acquire() } } override fun release(instance: T): Boolean { synchronized(lock) { return super.release(instance) } } } } 很明显这是一个对象池，SimplePool继承自Pool，并且可以指定对象池的大小。每次要回收的时候调用release，只有当前size小于对象池最大容量的时候才能回收，每次通过acquire来进行获取对象池中的元素。 其中在recyclerview动画篇章中，分析到InfoRecord对象中会使用Pools.SimplePool，InfoRecord存储的是ViewHolder在pre-layout阶段的坐标信息和post-layout阶段的坐标信息，以及ViewHolder的flag信息。因为ViewHolder的这些信息在动画处理过程中会频繁使用，所以此处使用了对象池来管理。\njava中类加载机制 首先通过class的name查看有没有加载过，如果没有加载过，看自己的父类加载器是否存在，如果存在，则通过父类加载的loadClass去加载，如果不存在则说明当前类加载器是BootstrapClassLoader加载器，则通过BootstrapClassLoader去加载，如果还没有找到则通过自己的findClass去加载。整体过程理解为先让父类加载器去加载class，如果找不到则自己去加载。 类加载器分类： BootstrapClassLoader：最顶层的类加载器，它用来加载JAVA_HOME/jre/lib/rt.jar中的类 ExtClassLoader：扩展类加载器，它用来加载JAVA_HOME/jre/lib/ext目录下的所有jar中的类，它的父加载器是BootstrapClassLoader，继承自URLClassLoader AppClassLoader：应用类加载器，它用来加载应用的类，也就是ClassPath，它的父加载器是ExtClassLoader，继承自URLClassLoader 自定义ClassLoader：用户实现，任意路径（如网络、文件），可以通过继承自ClassLoader或者是URLClassLoader 类加载器采用双亲委托模式来加载class，主要是为了系统的class的安全，优先使用系统的class来加载。 双清委托模式的核心代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 protected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded Class\u0026lt;?\u0026gt; c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0) sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } android中类加载机制 android类加载机制也是按照双亲委托模型，但是可以通过自定义类加载器绕过双亲委派，实现类的隔离或复用 类加载器分类： BootClassLoader：系统类加载器，加载框架层的核心类（如 android.、java. 等系统类） PathClassLoader：应用类加载器，加载已安装 APK 中的类（即应用自身的类和 classes.dex），它的父类加载器是BootClassLoader，继承自BaseDexClassLoader，用于加载 /data/app//base.apk 中的代码，无法加载外部存储的dex、jar文件 DexClassLoader：动态加载器，动态加载外部存储的 DEX/JAR 文件或 APK（如插件化、热修复场景），父加载器通常是PathClassLoader，也是继承自BaseDexClassLoader 上面提到android类加载也是通过双亲委托模式来加载类，但是安卓加载类是通过解析dex文件来加载的，所以对于PathClassLoader和DexClassLoader都是通过dex来加载class的，对于BootClassLoader，它仍然通过加载系统核心的DEX文件来实现类的加载，只不过这个过程是由虚拟机在底层直接处理的，不需要通过BaseDexClassLoader的DexPathList和DexFile机制。这种设计可能是为了优化系统启动速度和核心类的访问效率。 BaseDexClassLoader完成了整个dex转换成class的过程，首先理解几个概念，DexPathList，DexFile，Element: DexPathList：被BaseDexClassLoader持有 Element：被DexPathList持有，内部持有一个Element的数组 DexFile：被Element持有 DexPathList通过传入的dexPath，然后通过;或:进行split，得到List： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 //DexPathList.splitPaths private static List\u0026lt;File\u0026gt; splitPaths(String searchPath, boolean directoriesOnly) { List\u0026lt;File\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (searchPath != null) { for (String path : searchPath.split(File.pathSeparator)) { //省略代码 result.add(new File(path)); } } return result; } //DexPathList.makeDexElements private static Element[] makeDexElements(List\u0026lt;File\u0026gt; files, File optimizedDirectory, List\u0026lt;IOException\u0026gt; suppressedExceptions, ClassLoader loader) { Element[] elements = new Element[files.size()]; int elementsPos = 0; for (File file : files) { if (file.isDirectory()) { elements[elementsPos++] = new Element(file); } else if (file.isFile()) { String name = file.getName(); if (name.endsWith(DEX_SUFFIX)) { DexFile dex = loadDexFile(file, optimizedDirectory, loader, elements); elements[elementsPos++] = new Element(dex, null); } else { DexFile dex = loadDexFile(file, optimizedDirectory, loader, elements); if (dex == null) { elements[elementsPos++] = new Element(file); } else { elements[elementsPos++] = new Element(dex, file); } } } else { System.logW(\u0026#34;ClassLoader referenced unknown path: \u0026#34; + file); } } if (elementsPos != elements.length) { elements = Arrays.copyOf(elements, elementsPos); } return elements; } //DexPathList.loadDexFile private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader,Element[] elements) throws IOException { if (optimizedDirectory == null) { return new DexFile(file, loader, elements); } else { String optimizedPath = optimizedPathFor(file, optimizedDirectory); return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements); } } 从上面可以看出来，DexPathList里面会先split出dexPath，然后通过路径生成optimizedPath的路径，通过该路径生成DexFile对象，它就是表示一个dex文件。然后把DexFile塞入到Element数组中，最后该Element数组关联到BaseDexClassLoader中。 5. 接着看下如果通过dex加载到class，该处理是在BaseDexClassLoader中的findClass： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 //BaseDexClassLoader.findClass protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException { List\u0026lt;Throwable\u0026gt; suppressedExceptions = new ArrayList\u0026lt;Throwable\u0026gt;(); Class c = pathList.findClass(name, suppressedExceptions); if (c == null) { ClassNotFoundException cnfe = new ClassNotFoundException( \u0026#34;Didn\u0026#39;t find class \\\u0026#34;\u0026#34; + name + \u0026#34;\\\u0026#34; on path: \u0026#34; + pathList); for (Throwable t : suppressedExceptions) { cnfe.addSuppressed(t); } throw cnfe; } return c; } //DexPathList.findClass public Class\u0026lt;?\u0026gt; findClass(String name, List\u0026lt;Throwable\u0026gt; suppressed) { for (Element element : dexElements) { Class\u0026lt;?\u0026gt; clazz = element.findClass(name, definingContext, suppressed); if (clazz != null) { return clazz; } } if (dexElementsSuppressedExceptions != null) { suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); } return null; } //Element.findClass public Class\u0026lt;?\u0026gt; findClass(String name, ClassLoader definingContext, List\u0026lt;Throwable\u0026gt; suppressed) { return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed) : null; } //DexFile.loadClassBinaryName public Class loadClassBinaryName(String name, ClassLoader loader, List\u0026lt;Throwable\u0026gt; suppressed) { return defineClass(name, loader, mCookie, this, suppressed); } //DexFile.defineClass private static Class defineClass(String name, ClassLoader loader, Object cookie, DexFile dexFile, List\u0026lt;Throwable\u0026gt; suppressed) { Class result = null; try { result = defineClassNative(name, loader, cookie, dexFile); } catch (NoClassDefFoundError e) { if (suppressed != null) { suppressed.add(e); } } catch (ClassNotFoundException e) { if (suppressed != null) { suppressed.add(e); } } return result; } //DexFile中的native方法 private static native Class defineClassNative(String name, ClassLoader loader, Object cookie,DexFile dexFile) throws ClassNotFoundException, NoClassDefFoundError; 从上面可以看到BaseDexClassLoader最终是通过DexPathList-\u0026gt;Element-\u0026gt;DexFile-\u0026gt;native来加载到class android中Choreographer工作内容（android 29） 当某个view发起绘制（requestLayout或invalidate）的时候，会调用到ViewRootImpl的scheduleTraversals，该方法里面会给主线程的looper中的消息队列插入了一条消息屏障，接着给Choreographer插入了一条CALLBACK_TRAVERSAL类型的callback： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void scheduleTraversals() { //如果没有发起绘制，才会往下走 if (!mTraversalScheduled) { mTraversalScheduled = true; //给主线程的looper中的消息队列插入了一条消息屏障 mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); //给Choreographer插入了一条CALLBACK_TRAVERSAL类型的callback mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) { scheduleConsumeBatchedInput(); } notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); } } 最终会走到Choreographer的scheduleFrameLocked，默认会走USE_VSYNC，并且默认该线程的looper是主线程的looper，走到如下逻辑，会走到scheduleVsyncLocked，最终会走到DisplayEventReceiver的native方法nativeScheduleVsync，表示监听底层的vsync信号，当vsync信号来的时候会回调onVsync方法，该方法会给主线程发送一条异步消息到消息队列中： 1 2 3 4 5 6 7 8 9 10 //timestampNanos：VSync脉冲的时间戳 //frame：帧号码，自增 @Override public void onVsync(long timestampNanos, long physicalDisplayId, int frame) { mTimestampNanos = timestampNanos; mFrame = frame; Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS); } 可以看到onVsync中将自己（FrameDisplayEventReceiver）发送到任务队列中，并且执行时间是timestampNanos，说明该任务是要等到vsync信号指定的时间才会执行，它是一个runnable对象，到了执行该任务的时候会执行它的run方法，run方法会执行doFrame，任务队列是执行完上一个任务才会执行下一个任务，所以如果前面的任务一直阻塞着，doFrame其实不会在timestampNanos时间到了的时候，会立马执行的，看下doFrame处理逻辑： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 void doFrame(long frameTimeNanos, int frame) { final long startNanos; synchronized (mLock) { //期望的时间 long intendedFrameTimeNanos = frameTimeNanos; startNanos = System.nanoTime(); //当前时间-期望时间=延迟时间 final long jitterNanos = startNanos - frameTimeNanos; //延迟时间如果大于一帧所需要的时间 if (jitterNanos \u0026gt;= mFrameIntervalNanos) { final long skippedFrames = jitterNanos / mFrameIntervalNanos; //如果延迟执行的时间大于30帧的时间则给出提示 if (skippedFrames \u0026gt;= SKIPPED_FRAME_WARNING_LIMIT) { Log.i(TAG, \u0026#34;Skipped \u0026#34; + skippedFrames + \u0026#34; frames! \u0026#34; + \u0026#34;The application may be doing too much work on its main thread.\u0026#34;); } final long lastFrameOffset = jitterNanos % mFrameIntervalNanos; //重新计算vsync信号来的时间 frameTimeNanos = startNanos - lastFrameOffset; } //如果期望的时间比上一帧的时间还小，则说明上一帧还没结束，所以当前帧不处理，直接监听下一个vsync信号 if (frameTimeNanos \u0026lt; mLastFrameTimeNanos) { scheduleVsyncLocked(); return; } mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos); mFrameScheduled = false; //给上一帧的时间附上标记 mLastFrameTimeNanos = frameTimeNanos; } try { Trace.traceBegin(Trace.TRACE_TAG_VIEW, \u0026#34;Choreographer#doFrame\u0026#34;); AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS); mFrameInfo.markInputHandlingStart(); //处理input类型的callback doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); mFrameInfo.markAnimationsStart(); //处理animation类型的callback doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos); mFrameInfo.markPerformTraversalsStart(); //处理traversal类型的callback doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); //处理commit类型的callback doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); } finally { AnimationUtils.unlockAnimationClock(); Trace.traceEnd(Trace.TRACE_TAG_VIEW); } } doFrame主要是先看当前时间和期望的时间进行比较，得到延迟时间，如果该时间大于一帧所需要的时间（60hz刷新率的设备，那么一帧的时间是1000/60=16ms），并且该时间大于30帧的时间时候给出提示，这个时间跟view绘制的anr时间差不多。如果期望的时间比上一帧的时间还小，则说明上一帧还没结束，所以当前帧不处理，直接监听下一个vsync信号。接着就是处理各种callback（input、animation、traversal、commit）。而开头view发起绘制的时候，会插入一条traversal类型的callback，所以会执行到view的绘制流程。 当view发起绘制的时候，不会立马执行，而是先给Choreographer插入一条traversal类型的callback，同时让Choreographer监听下一个vsync信号的到来，当vsync信号来的时候，会给主线程的消息队列发送一条异步消息，当处理该消息的时候校验是否有掉帧处理，如果有掉30帧的时候，会给出提示，最后处理各种类型的callback。 vsync信号的作用 VSync（垂直同步）在安卓屏幕刷新中的作用主要是协调屏幕刷新与图像渲染，避免画面撕裂并提升显示流畅度。具体作用如下： 防止画面撕裂 当屏幕刷新与图像渲染不同步时，可能出现画面撕裂。VSync通过同步两者的频率，确保屏幕在完整刷新一帧后再显示下一帧，从而避免这一问题。 提升流畅度 VSync确保帧率与屏幕刷新率一致，减少帧率波动，使动画和滚动更加平滑。 优化性能 VSync通过控制渲染节奏，避免GPU过度渲染，减少资源浪费，提升系统效率。 双缓冲与三缓冲 VSync常与双缓冲或三缓冲结合使用。双缓冲通过交替使用前后缓冲区减少等待时间，而三缓冲进一步减少卡顿，提升性能。 减少延迟 虽然VSync可能增加少量延迟，但通过合理使用双缓冲或三缓冲，可以在保证流畅度的同时尽量降低延迟。 总结来说，VSync通过同步屏幕刷新与图像渲染，防止画面撕裂、提升流畅度、优化性能，并减少延迟。 消息队列中的消息屏障 消息屏障主要是不处理屏障后面的同步消息，优先处理异步消息，实现原理是消息屏障本身是一个没有持有handler的消息，在获取消息的时候，如果发现队列头部是一个消息屏障，则不获取后面的同步消息，只获取后面的异步消息，一般作用于优先级比较高的场景，比如view的绘制流程。当处理完异步消息后，需要移除掉该消息屏障。 android中异常处理 首先理解下java中线程异常机制，如果线程中发生异常了，没有进行try-catch默认会抛给defaultUncaughtExceptionHandler的uncaughtException，而android中启动进程后会在RuntimeInit的commonInit方法中给主线程设置上defaultUncaughtExceptionHandler，对应的是KillApplicationHandler，在它的uncaughtException方法中先收集日志，然后kill掉进程。如果有设置线程的uncaughtExceptionHandler，那么此时java异常机制是就不走defaultUncaughtExceptionHandler了，所以不会走KillApplicationHandler，如果没有设置uncaughtExceptionHandler，而通过Thread.uncaughtExceptionHandler.uncaughtException(Exception)的时候，其实是先获取到线程的ThreadGroup，而在ThreadGroup中的uncaughtException中先看parent有没有，如果没有则也是回调到defaultUncaughtExceptionHandler中。\n关于多张bitmap转成webp的原理 首先得理解webp是基于VP8/VP8L/VP9视频编码技术，支持有损压缩、无损压缩、透明度和动画。其内部格式基于RIFF（Resource Interchange File Format）文件结构，类似于WAV或AVI的容器格式。webp文件以RIFF头部开始，整体结构如下：\n1 RIFF {FileSize} WEBP {Chunks...} RIFF：固定 4 字节标识符。 FileSize：4 字节，表示文件总大小（包括 RIFF 头部和 WEBP 标签）。 WEBP：固定 4 字节标识符，表明文件类型。 其中RIFF、FileSize、WEBP这三个归为header部分，chunks归为块部分。其中块可以分为如下部分： VP8/VP8L/VP9 图像数据块： VP8：用于有损压缩图像（类似 JPEG），块标识符为 VP8 （注意末尾空格）。 VP8L：用于无损压缩图像（类似 PNG），块标识符为 VP8L。 VP9：用于更高效的压缩（较少见），块标识符为 VP9 。 VP8X（扩展元数据块）： 标识符为 VP8X，用于存储扩展信息（如宽度、高度、动画标志、Alpha 通道等）。 必须出现在其他块之前（除 RIFF 和 WEBP 外）。 包含以下标志位： 动画（Animation） Alpha 通道（Alpha） EXIF 元数据 XMP 元数据 ICC 颜色配置文件 ANIM（动画控制块）： 标识符为 ANIM，仅用于动画 WebP。 包含背景颜色和循环次数。 ANMF（动画帧块）： 标识符为 ANMF，每个动画帧对应一个 ANMF 块。 包含帧的位置、时间延迟、宽度、高度等。 了解文件结构后，下面来介绍如何将多个bitmap生成webp： 首先将bitmap压缩成webp格式的图片，按照50的压缩比，放到字节输入流中 读取webp的header部分 读取RIFF部分 读取文件大小 读取WEBP部分 读取第一个带有playload的chunk块 由于前面指定了bitmap转webp的时候是有损，因此读取chunk的时候直接去读WP8块，接着读取它的payload信息，playload大小就是chunk大小，4字节。 读取完后，接着就是写入到输出流中，判断如果是第一个bitmap，则创建header部分，其中header也是按照RIFF、FileSize、WEBP三个区域写回，接着写入VP8X数据块，标明宽高、动画、通道、元数据等信息。接着创建ANIM动画控制块，标明背景颜色和循环次数。最后创建每一个bitmap对应的ANMF动画帧块，将指定每一帧的的尺寸、时长playload数据。 kotlin中==和===区别 kotlin中的==：如果是对象类型，比较的是equals方法；如果是基本类型，比较的是值。 kotlin中的===：如果是对象类型，比较的是内存地址，指向的是不是同一个对象；如果是基本类型。比较的还是值。\nkotlin中lazy的原理 Lazy本身是一个接口，会提供一个value属性和isInitialized的方法，注意了在kotlin接口中提供属性，其实对应java中的get**方法，平时写的by lazy{}，去定义一个属性的时候，其实它是一种属性委托的写法，但是lazy它是只读的委托模式，所以在定义属性的时候必须用val来修饰变量。当我们去读取lazy的变量的时候，实际是调用了前面定义的value属性，对应java代码其实是getValue方法，当首次去获取属性的时候，发现_value为空，所以会通过闭包去获取，获取到后会将返回值给到_value，下次再调用getValue的时候，直接返回该_value。\n1 public actual fun \u0026lt;T\u0026gt; lazy(lock: Any?, initializer: () -\u0026gt; T): Lazy\u0026lt;T\u0026gt; = SynchronizedLazyImpl(initializer, lock) 第一个参数lock是可以传入对象锁\n第二个参数是传进来的闭包，是非空\n返回值：实际是一个SynchronizedLazyImpl对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private class SynchronizedLazyImpl\u0026lt;out T\u0026gt;(initializer: () -\u0026gt; T, lock: Any? = null) : Lazy\u0026lt;T\u0026gt;, Serializable { private var initializer: (() -\u0026gt; T)? = initializer //使用Volatile关键字修饰_value变量，在多线程下能达到可见性的效果 @Volatile private var _value: Any? = UNINITIALIZED_VALUE // final field is required to enable safe publication of constructed instance private val lock = lock ?: this//如果传进来的对象锁为空，则当前对象作为锁 override val value: T get() { val _v1 = _value if (_v1 !== UNINITIALIZED_VALUE) { @Suppress(\u0026#34;UNCHECKED_CAST\u0026#34;) return _v1 as T } //通过synchronized来保证创建对象是原子操作 return synchronized(lock) { val _v2 = _value if (_v2 !== UNINITIALIZED_VALUE) { @Suppress(\u0026#34;UNCHECKED_CAST\u0026#34;) (_v2 as T) } else { val typedValue = initializer!!() _value = typedValue initializer = null typedValue } } } } 综上来看，lazy默认是线程安全的，默认使用的对象锁是当前lazy对象，也可以自己传入锁对象。使用Volatile来保证对象的可见性，通过synchronized保证创建对象是原子操作。\nkotlin委托模式 属性委托：允许你把属性的getter、setter逻辑委托给一个独立的对象来管理 通过「var 属性 by 委托类」的形式定义一个属性委托的过程，当使用var的时候，说明该属性能可读和可写，在属性写的时候实际编译器会去调委托类的setValue方法，当属性读的时候实际编译器会去调委托类的getValue方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Delegate { operator fun getValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;): String { return \u0026#34;属性 ${property.name} 被代理了\u0026#34; } operator fun setValue(thisRef: Any?, property: KProperty\u0026lt;*\u0026gt;, value: String) { println(\u0026#34;属性 ${property.name} 赋值为 $value\u0026#34;) } } class Example { var message: String by Delegate() } fun main() { val e = Example() println(e.message) // 访问时调用 getValue() e.message = \u0026#34;Hello\u0026#34; // 赋值时调用 setValue() } 实际对应的字节码： 1 2 3 4 5 6 7 class Example { private val message$delegate = Delegate() // 委托对象变为一个私有属性 var message: String get() = message$delegate.getValue(this, ::message) set(value) = message$delegate.setValue(this, ::message, value) } by Delegate() 其实是 Kotlin 编译器生成的 get() 和 set() 方法。 getValue() 和 setValue() 由 Delegate 这个委托对象实现。 类委托：允许一个类 将实现某个接口的功能委托给另一个对象，减少代码重复。 by 关键字 可以让 Kotlin 自动生成委托方法，避免手写重复代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 interface Printer { fun printMessage() } class RealPrinter : Printer { override fun printMessage() { println(\u0026#34;RealPrinter: 打印内容\u0026#34;) } } class ProxyPrinter(printer: Printer) : Printer by printer fun main() { val realPrinter = RealPrinter() val proxy = ProxyPrinter(realPrinter) proxy.printMessage() // 调用的是 realPrinter 的方法 } 上面的ProxyPrinter被编译器编译为如下： 1 2 3 4 5 6 7 class ProxyPrinter(printer: Printer) : Printer { private val printerDelegate: Printer = printer override fun printMessage() { printerDelegate.printMessage() } } by printer 让 ProxyPrinter 自动实现 Printer 接口的方法，而不需要手动实现。 编译器在字节码层面会自动插入代理方法，提高代码简洁性。 为什么reified必须和inline一起使用？ reified关键字是用来修饰泛型，而泛型在编译后会被擦除掉，所以如果要在运行时获取到泛型的类型，就得用reified关键字，而inline的作用是修饰方法内联，之前讲内联函数的特点是将函数体平铺到调用处。那它两有什么联系呢？先来看一个例子： 此处提示我，使用reified关键字来修饰泛型，因为泛型在编译后，会被擦除掉，所以是获取不到它的类型，只有添加reified才能保证它的类型存在。那添加完reified后提示为什么还要添加inline呢？ 这是因为只有内联函数将函数体进行平铺，然后将泛型通过「真类型」代入到函数体中，看下编译后的代码： 关于viewModel的一些思考 创建：默认都是通过ViewModelProvider的get方法获取到viewModel，里面通过factory（工厂方法模式）的create来创建viewModel，创建完之后会把viewModel保存到ViewModelStore中。ViewModelStore实际是用一个hashMap来存储viewModel，key是viewModel的class name拼上前缀，value就是当前viewModel。android中默认的factory是ViewModelProvider.AndroidViewModelFactory，在它的create方法里面通过前面传进来的viewModel的class反射创建viewModel。 存储：像平时写的activity都是继承自ComponentActivity，它是实现了ViewModelStoreOwner接口，该接口需要持有一个ViewModelStore，ViewModelStore是在ensureViewModelStore方法中创建的： 1 2 3 4 5 6 7 8 9 10 11 12 13 void ensureViewModelStore() { if (mViewModelStore == null) { NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) { // Restore the ViewModelStore from NonConfigurationInstances mViewModelStore = nc.viewModelStore; } if (mViewModelStore == null) { mViewModelStore = new ViewModelStore(); } } } getLastNonConfigurationInstance()方法是获取Activity中的mLastNonConfigurationInstances属性的activity属性，结构如下： 1 2 3 4 5 6 7 static final class NonConfigurationInstances { Object activity; HashMap\u0026lt;String, Object\u0026gt; children; FragmentManagerNonConfig fragments; ArrayMap\u0026lt;String, LoaderManager\u0026gt; loaders; VoiceInteractor voiceInteractor; } 第一次打开activity的时候mLastNonConfigurationInstances属性是空的，因此在ensureViewModelStore中是直接创建了ViewModelStore。那什么时候mLastNonConfigurationInstances不为空呢？我们注意到mLastNonConfigurationInstances是在activity的attach中赋值的，它的上级来源是ActivityClientRecord中的lastNonConfigurationInstances属性，那什么时候给ActivityClientRecord的lastNonConfigurationInstances属性赋值呢？这个可以在aosp中的frameworks/base/core/java/android/app/Activity.java类中的performDestroyActivity方法中找到： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void performDestroyActivity(ActivityClientRecord r, boolean finishing, boolean getNonConfigInstance, String reason) { Class\u0026lt;? extends Activity\u0026gt; activityClass; if (getNonConfigInstance) { try { //通过调用activity的retainNonConfigurationInstances方法来给ActivityClientRecord的lastNonConfigurationInstances属性赋值 r.lastNonConfigurationInstances = r.activity.retainNonConfigurationInstances(); } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException(\u0026#34;Unable to retain activity \u0026#34; + r.intent.getComponent().toShortString() + \u0026#34;: \u0026#34; + e.toString(), e); } } } } 而activity的retainNonConfigurationInstances方法中会组装NonConfigurationInstances中的activity属性，是通过onRetainNonConfigurationInstance方法来收集的： 1 2 3 4 5 6 NonConfigurationInstances retainNonConfigurationInstances() { Object activity = onRetainNonConfigurationInstance(); NonConfigurationInstances nci = new NonConfigurationInstances(); nci.activity = activity;//手机activity属性 return nci; } onRetainNonConfigurationInstance方法的调用是在ComponentActivity中实现了： 1 2 3 4 5 6 7 8 9 @Override @Nullable @SuppressWarnings(\u0026#34;deprecation\u0026#34;) public final Object onRetainNonConfigurationInstance() { ViewModelStore viewModelStore = mViewModelStore; NonConfigurationInstances nci = new NonConfigurationInstances(); nci.viewModelStore = viewModelStore; return nci; } 可以看到最终viewModelStore通过ComponentActivity中的NonConfigurationInstances存储起来了，最终被ActivityClientRecord持有。当横竖屏切换的时候会触发ActivityThread的handleRelaunchActivity，在该方法里面会先将activity的lastNonConfigurationInstances保存到ActivityClientRecord，等到创建activity的时候会把lastNonConfigurationInstances给到activity，所以viewmodelStore此时拿到的还是之前的。 fragment中的viewModel是怎么存储的？ fragment也是实现了viewModelOwner接口，所以它也有自己的viewModelStore，它的viewModelStore是通过FragmentManagerViewModel来管理的，FragmentManagerViewModel的创建是看当前fragment有没有parentFragment，如果有，则通过parentFragment的fragmentManager的getChildNonConfig方法来获取。如果parent为空，则通过activity的viewModelStore来创建。所以fragment的viewModelStore存储也是依赖于activity，因为最终该FragmentManagerViewModel是通过activity的viewModelStore来存储的。 LiveData的一些思考 liveData是基于监听lifecycle生命周期的数据驱动框架，在lifecycle为STARTED才会触发触发数据驱动，并且在lifecycle为DESTROYED的时候自动解绑observer。 比如我在lifecycle的CREATED状态给livedata灌数据，等到lifecycle状态为STARTED的时候就会给livedata的observer给发送数据。 当提前给livedata灌输数据的时候，但是此时还没添加observer，等到添加observer的时候，会自动把数据分发到observer中了。这个就是数据倒灌。主要是因为给livedata发送数据的时候，livedata中的版本号会+1，但是新添加的observer此时的版本号还是-1，所以在注册的时候，会把数据分发给observer。通常数据倒灌的解决方案是： 每次在添加observer的时候，反射将livedata中的版本号给置为0 重写livedata，然后添加一个已经注册的标记(AtomicBoolean)，第一次调用observe的时候才会给该标记置为非空。此时在发送数据的时候判断如果该标记不为空，才会置为true，在observe的地方通过包装一个observer，只有该标记置为true了，才会给到目标observer传递数据。（这种方案只适合添加单observer的场景，如果多observer就不适合了） 继承livedata，用一个map记录observer是否接收过消息，如果接收过了就不能再接收 livedata中的getVersion方法是包内可见的，因此我们可以新建和livedata同样的包名的类，这样就能访问getVersion方法，然后在observe方法中判断如果version\u0026gt;START_VERSION才会能消费事件 livedata中setValue是同步方法，是线程不安全的。postValue在一个线程的时候，如果发送数据比较频繁的时候，只会把最后一个数据发送给observer，因为postValue是通过给主线程的消息队列发送数据，然后发送给observer。在多线程情况下虽然设置数据是加了同步块，但是因为还是给主线程的消息队列发送消息来切换线程，导致前面的数据会被后面的数据给覆盖。 glide缓存 glide缓存分为内存和硬盘两类，其中内存缓存又分为活跃缓存和LRU缓存，硬盘缓存分为解码后按照view尺寸展示的bitmap缓存，另外一部分是原始图片的缓存。 活跃缓存：它的结构是一个hashmap，其中key是按照url、尺寸等信息拼成的，value是一个弱引用对象，其中弱引用中放的才是图片缓存对象。 LRU缓存：它底层是一个LRU策略的缓存，key也是和上面活跃缓存用的是同一个。value存的是解码后的图片缓存。 解码后的硬盘缓存：也是使用的LRU策略的缓存，其中key是按照指定尺寸来构建的，然后从DiskLruCache中获取缓存。 原始图片的硬盘缓存：也是使用的LRU策略的缓存，其中key不是通过指定尺寸来构建的，然后也是从DiskLruCache中获取缓存。 缓存获取步骤： LRU的内存缓存是在什么存储的？ 从上面流程图来看每次从非活跃缓存中获取到图片缓存后，都会放入到活跃缓存中，那什么时候会放到内存的LRU缓存中呢？当view触发onViewDetachedFromWindow的时候，也就是当前view销毁后，会查看当前view绑定的图片被正在使用标记的次数，如果次数为0了，则将当前图片加入到LRU的内存缓存中。 glide为什么要设计两层的内存缓存？ 内存缓存分为活跃的缓存，它是一个map数据结构，value存储的是弱引用包装了缓存数据，另外一层是LRU级别的缓存。活跃数据指的是当前正在使用的资源，比如正在显示的图片，这部分用弱引用来保存，这样当图片不再被使用时，垃圾回收器可以自动回收，避免内存泄漏。而LRU缓存则是最近最少使用的缓存，使用强引用，当内存不足时，会移除最久未使用的资源。 如果只有LRU缓存的时候，正在使用的图片可能是长时间没有被访问的图片，而此时如果只有LRU缓存的时候，可能会把正在使用的图片缓存给移除掉了，这样的话，当再使用该图片的时候，会从磁盘中去获取该图片，这样增大了获取图片的时间。如果只有弱引用缓存的时候，此时图片不被使用了，被GC给回收了，那此时也只能从磁盘中获取，增大了获取图片的时间。如果此时有LRU缓存，能在内存中保留一段时间，降低从磁盘中读取的可能。 kotlin中Sequence和普通集合的区别 Sequence原理是持有了原有集合的iterator，在等到调用toList的时候，才会拿到Sequence的iterator进行遍历，然后添加到新的集合中。中间的操作符都会生成一个新的sequence，然后每遍历一个元素都会去执行一次中间操作符的iterator的next方法，然后将结果给到下一个sequence，最后添加到新的集合中。 优点：相较于普通的集合，它是惰性执行中间操作符，并且中间的操作符只是通过iterator进行迭代每一个元素，而普通的集合是每一个操作符会新生成一个集合，导致内存会增高。Sequence的使用场景是中间操作符比较多的情况下进行使用，不会增加新的集合，并且是惰性遍历元素。 比如下面这个操作：\n1 2 3 4 5 6 7 8 9 10 11 listOf(1, 2, 3, 4, 5) .asSequence() .map { println(\u0026#34;sequence map:$it\u0026#34;) it * 2 } .filter { println(\u0026#34;sequence filter:$it\u0026#34;) it \u0026gt; 5 } .toList() 在调用toList时候，才会执行上面的map和filter方法，并且map和filter遍历元素的时候，是每个元素依次调用到map和filter，中间是通过sequence的iterator进行遍历，不会产生中间的集合。 日志如下：\n1 2 3 4 5 6 7 8 9 10 sequence map:1 sequence filter:2 sequence map:2 sequence filter:4 sequence map:3 sequence filter:6 sequence map:4 sequence filter:8 sequence map:5 sequence filter:10 再来看下普通集合的操作：\n1 2 3 4 5 6 7 listOf(1, 2, 3, 4, 5).map { println(\u0026#34;list map:$it\u0026#34;) it * 2 }.filter { println(\u0026#34;list filter:$it\u0026#34;) it \u0026gt; 5 } 上面的map和filter是分开执行的，不会等到最后才执行，所以没有惰性，map和filter都会产生新的集合，并且在遍历元素的时候，每一个操作符是先遍历完每一个元素，然后才执行下一个操作符的遍历。 日志如下：\n1 2 3 4 5 6 7 8 9 10 list map:1 list map:2 list map:3 list map:4 list map:5 list filter:2 list filter:4 list filter:6 list filter:8 list filter:10 kotlin中Sequence和集合的Stream区别 Stream是java1.8之后出的语法，和Sequence一样支持流式和惰性的特点，它在遍历元素的时候也是每个元素都会按顺序经过中间的操作符，不像普通的集合那样每个元素必须先执行完一个操作符，然后才进行下一个操作符。但是Stream只能一次性消费，消费完后，就不能再使用该stream。而Sequence可以多次使用。同时Stream的parallelStream方法支持并发处理，遍历元素的时候，不是按照元素会顺序执行每一个操作符，当数据量大的时候可以考虑使用parallelStream。\n","date":"2024-11-04T00:00:00Z","permalink":"https://example.com/p/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/","title":"笔记整理"},{"content":"协程创建 demo 1 2 3 4 5 6 7 8 9 10 11 12 suspend { Log.d(TAG, \u0026#34;suspend block:\u0026#34;) \u0026#34;123\u0026#34; }.createCoroutine(object : Continuation\u0026lt;String\u0026gt; { override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result\u0026lt;String\u0026gt;) { val value = result.getOrNull() Log.d(TAG, \u0026#34;resumeWith:$value\u0026#34;) } }).resume(Unit) Log.d(TAG, \u0026#34;onCreate\u0026#34;) 上面日志先打印suspend中的代码块，然后执行Continuation的resumeWith，最后执行主线程的代码。\ncreateCoroutine 是挂起函数的扩展方法，方法参数是Continuation类型，对应上面的匿名内部类。创建了一个SafeContinuation对象，它也是一个Continuation类型，并传递两个参数。\nresume resume方法会调用resumeWith，看下SafeContinuation的resumeWith方法： 此处提醒下，kotlin的源码需要到对应的** Jvm类下找，要不然方法只是一个申明。此处的result是构造SafeContinuation传递进来的COROUTINE_SUSPENDED，因此会执行delegate.resumeWith(result)，此处的delegate是createCoroutineUnintercepted(completion).intercepted()创建的。\ncreateCoroutineUnintercepted 它是挂起函数的扩展方法：\n判断当前挂起函数是不是BaseContinuationImpl类型，如果是则调用create方法。\n此时可以打开字节码，看下上面的(suspend () -\u0026gt; T)是什么对象？\n可以看到createCoroutine方法传入了两个参数，我们都知道扩展函数最终编译出来的方法第一个参数是被扩展对象，所以此处的CoroutineActivity$onCreate$1就是(suspend () -\u0026gt; T)，CoroutineActivity$onCreate$2对应的是例子中的Continuation匿名内部类。我们注意下，此时传入CoroutineActivity$onCreate$1中的Continuation参数是null。\n而SuspendLambda的继承关系如下：\n所以会调用挂起函数的create方法：\n父类中要求子类必须重写该方法，我们看CoroutineActivity$onCreate$1的create方法：\n此时重新new了一个CoroutineActivity$onCreate$1，并把completion传入其中，而此处的completion就是上面的CoroutineActivity$onCreate$2，它是一个Continuation。而开端在分析createCoroutine的时候，创建CoroutineActivity$onCreate$1传入的Continuation是null。\n不太明白，为什么不在createCoroutine时候直接直接把CoroutineActivity$onCreate$2传入到CoroutineActivity$onCreate$1中，而非要通过create方法再创建一个CoroutineActivity$onCreate$1。\n我们再来看intercepted方法。\nintercepted 是Continueation的扩展方法，当然了，刚刚create创建的CoroutineActivity$onCreate$1是一个suspendLambda对象，所以它也是ContinueationImpl，所以会走ContinueationImpl的intercepted方法：\n此处看context中有没有ContinuationInterceptor类型的Element，如果没有则返回自己，我们只要知道先返回自己。因为这个涉及到context的结构，后面再讲。\n小节： ①、createCoroutine创建了一个SafeContinuation，并把CoroutineActivity$onCreate$1和一个标志位COROUTINE_SUSPENDED传入其中。CoroutineActivity$onCreate$1继承自SuspendLambda，并且是一个Function接口的实例。SuspendLambda继承自ContinuationImpl，ContinuationImpl继承自BaseContinuationImpl，BaseContinuationImpl继承自Continuation，CoroutineActivity$onCreate$1继承自SuspendLambda，也就是上面的协成要执行的闭包。CoroutineActivity$onCreate$1持有了CoroutineActivity$onCreate$2，它实现了Continuation。CoroutineActivity$onCreate$1重写了create方法，返回了一个新的CoroutineActivity$onCreate$1对象。 ②、resume方法中会调用到SafeContinuation的resumeWith方法，最终会触发CoroutineActivity$onCreate$1的resumeWith方法。\n协程执行 CoroutineActivity$onCreate$1继承自SuspendLambda，最终会继承自BaseContinuationImpl，来看下它的resumeWith：\nresumeWith中首先调用invokeSuspend方法，如果invokeSuspend方法返回COROUTINE_SUSPENDED，则resumeWith直接不往下执行。否则看comppletion是不是BaseContinuationImpl，是的话，则继续轮训，直到comppletion不是BaseContinuationImpl，则执行它的resumeWith方法。此处的completion实际是CoroutineActivity$onCreate$2，所以会执行它的resumeWith方法。我们看下CoroutineActivity$onCreate$1的invokeSuspend方法：\n它的返回值不是COROUTINE_SUSPENDED，所有上面的invokeSuspend方法还会继续往下执行。所以最终会执行了CoroutineActivity$onCreate$2，也就是例子中的匿名内部类的resumeWith方法。\n此时我们再分析例子中日志的打印：\n可以看到执行SafeContinuation的resumeWith的时候是一个while(true)，传入的this.resume是一个COROUTINE_SUSPENDED标志位，所以会把CoroutineActivity$onCreate$1的resumeWith执行完后，才跳出while循环。因此日志最后输出协成外的代码。\n总结 过程 协程分为创建和执行，在创建过程中首先会创建一个SuspendLambda的子类，但是该子类它的completion(Continuation)是空的，然后在createCoroutineUnintercepted方法中会调用到该SuspendLambda的子类的create方法，在create方法里面会再次创建一个SuspendLambda的子类，此时SuspendLambda的子类中completion(Continuation)是非空的，指向了createCoroutine方法传入的Continuation内部类。接着来到了执行阶段，执行是调用了SuspendLambda的子类的resume方法，它会执行resumeWith方法。在resumeWith中会调用到invokeSuspend方法，而invokeSuspend中的代码实际是suspend代码块中的代码，所以suspend代码块中的代码最先执行。执行完invokeSuspend后会执行completion的resumeWith方法，所以createCoroutine方法传入的Continuation内部类的resumeWith被执行。而为什么主线程在最后才执行呢？这是因为在创建协程的时候实际包装了一个SafeContinuation对象，在它的resumeWith里面会启动while(true)循环，等到执行完deletate(也就是SuspendLambda的子类)的resumeWith后才会退出while(true)循环，所以最后才会执行主线程后面的代码。\n类图 最后输出此次的类图结构，以作回顾：\n","date":"2024-11-02T00:00:00Z","image":"https://example.com/p/android-%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%88%B0%E6%89%A7%E8%A1%8C/cover_hu17536845123992820283.jpg","permalink":"https://example.com/p/android-%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%88%B0%E6%89%A7%E8%A1%8C/","title":"Android 协程启动到执行"},{"content":"Bytecode-viewer 一款查看class文件的工具\n使用： 目录定位到该jar包下面，然后使用如下命令：\njava -jar Bytecode-Viewer-2.12.jar\nsh脚本执行文件： Bytecode-Viewer.sh\n脚本文件：\nBytecode-Viewer-2.12.jar\n来源:https://github.com/Konloch/bytecode-viewer\nRectangle窗口大小调整 Rectangle是一个在mac上动态调整应用窗口的工具，比如我想在屏幕上同时展示多个应用，这个工具使用上非常好用。 Rectangle下载 Alfred工具 Alfred是一款在mac上全局搜索的工具，能指定搜索文件、文件夹、应用的一款工具。 建议你在设置中将要搜索的文件类型给勾选住： 关于更多使用看官网，我的快捷键是双击command： 动画差值器 在线预览：https://inloop.github.io/interpolator/\n","date":"2024-11-02T00:00:00Z","permalink":"https://example.com/p/%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/","title":"工具整理"},{"content":"类图 Context创建 Activity继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，当activity创建的之前，会先创建contextimpl ActivityThread.performLaunchActivity\n接着会调用contextimpl的setOuterContext，传入的是activity。\n结论：contextImpl中的outerContext指向了activity。\nContext传递 attach调用了attachBaseContext，并把contextimpl传进去了：\n该方法是ContextWrapper中的方法，并指向了mBase变量。Activity中getBaseContext和getApplicationContext区别：\ngetBaseContext指向了刚刚attach方法传进来的contextimpl。\n指向了mBase.getApplicationContext：\nmPackageInfo是在创建contextimpl的时候传入的，它是loadedApk对象，它的getApplication方法是获取应用的Application对象：\n结论：getBaseContext获取的是contextimpl对象，getApplicationContext获取的是Application对象。\n主题设置 回到performLaunchActivity，给activity设置主题：\n将theme的resid传进来，最终会把resid这个theme追加到mTheme上。这里牵扯到资源加载，后面再说。\nLayoutInflater中的context LayoutInflater.from(context)： 此处的context一般是activity，看activity.getSystemService方法，activity是继承自ContextThemeWrapper，所以会调用ContextThemeWrapper的getSystemService：\n如果name是LAYOUT_INFLATER_SERVICE，则通过LayoutInflater.from(getBaseContext()).cloneInContext(this)来创建，上面分析过activity中的getBaseContext()是指向了contextImpl对象，所以兜兜转转，最终调用了contextImpl中的getSystemService来获取LayoutInflater对象。\n那如果from传进来的不是Activity，而是application会怎么样呢？application它是继承自ContextWrapper：\nbase是contextimpl，最终调用的是contextimpl的getSystemService，activity亦是如此：\n从SYSTEM_SERVICE_FETCHERS中获取：\n最终是在此处添加了一个PhoneLayoutInflater对象，并把contextimpl.getOuterContext传进去了，此处传进去的是Activity或者是application对象。 如果from中传入的是activity，在contextThemeWrapper的getSystemService方法中获取到PhoneLayoutInflater后，又调用了cloneInContext，将当前的context传入其中： 此处为什么要通过cloneInContext构造一个新的PhoneLayoutInflater呢？ 因为layoutinflater解析xml是强依赖于context，所以为了确保当前activity创建的layoutinflater使用的是当前context，所以将当前的context传入其中构造一个新的layoutinflater。比如在from的时候传入的是view的context，而view的context是有可能不是activity类型的context，比如是一个contextThemewrapper类型的，那么是有可能PhoneLayoutInflater的origin context是一个activity，而newContext传入的是contextThemeWrapper。所以此处用cloneInContext是为了保证当前的context是即将要展示的theme样式。关于分析可以看下面的layoutinflater.inflate。\nlayoutinflater.inflate: 此过程调用createViewFromTag来创建view：\n此处看view有没有theme属性，有的话，则构造一个contextthemeWrapper出来，举个例子：\n此处定义了一个theme属性，那么给该view的构造器传入的context就是一个contextThemeWrapper对象。所以view的context不一定是activity的context，如果设置了theme属性，那么就是一个contextThemeWrapper的context。\n再来看一个例子，创建创建layoutinflater的时候指定contextThemeWrapper对象： 在from方法里面，传入一个contextthemewrapper对象，并携带一个style。根据上面分析from方法时，contextthemewrapper是通过LayoutInflater.from(getBaseContext()).cloneInContext(this)。此处的getBaseContext()又是activity，又因为activity.getSystemService，调用base.getSystemService，所以最终又回到了contextimpl.getSystemService。而在创建PhoneLayoutInflater的时候，又通过contextimpl.getOuterContext传入到PhoneLayoutInflater构造器中，但是在contextthemewrapper中最后又调了PhoneLayoutInflater的cloneInContext：\n所以此种情况下，最终给view传的context也是一个contextthemewrapper的context。\nAttr部分 从主题中获取属性：\n最终这些属性是通过context的obtainStyledAttributes获取属性值。常见的方法是：\nAttributeSet表示所有的属性集，它是在inflate过程中解析到view的属性集。 attrs表示的是要从哪个属性集中取到属性。 例如：\nattrs文件中定义一个declare-styleable属性集，aapt工具会生成对应的R.class，但是此时是一个R.jar文件：\n该文件在app/build/intermediates/compile_and_runtime_not_namespaced_r_class_jar/debug/R.jar，反编译该jar文件：\n最终所有的资源类型都会生成一个R$**.class的类，而R.class其实是一个空壳：\n看刚才定义的declare-styleable生成如下：\n并且会在R$attr.class下面也会生成一个两个int值：\n可以看出来生出来一个R.styleable.TestView的数组和两个int值，分别是R.styleable.TestView_attr1和R.styleable.TestView_attr2，它两分别代表TestView数组的索引，而对应的值是定义在resource.arsc文件中：\n所以最终得出结论是：通过context.obtainStyledAttributes传入attrbuteset和attrs数组，得到了typearray，然后通过typearray的索引得到所有的属性：\ndefStyleAttr、defStyleRes 新增一个不在declare-styleable数组中的attr11，见R文件：\n在R.styleable类中没有attr11的定义，它在R.attr类中定义了：\n在上面属性中attr7和attr11是引用类型的，他们可以指向另外一个引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public class TestView1 extends View { public TestView1(Context context) { this(context, null); } public TestView1(Context context, @Nullable AttributeSet attrs) { this(context, attrs, R.attr.attr11); } public TestView1(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { this(context, attrs, defStyleAttr, R.style.DefStyleRes); } public TestView1(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context, attrs, defStyleAttr, defStyleRes); TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.gui, defStyleAttr, defStyleRes); log(\u0026#34;TypedArray length：\u0026#34; + ta.length()); for (int i = 0; i \u0026lt; ta.length(); i++) { int attrIndex = ta.getIndex(i); switch (attrIndex) { case R.styleable.gui_attr1: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr2: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr3: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr4: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr5: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr6: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr7: log(ta.getString(attrIndex)); break; default: break; } } ta.recycle(); } private void log(String msg) { Log.v(getClass().getSimpleName(), \u0026#34;\u0026#34; + msg); } } TestView1中defStyleAttr传入R.attr.attr11，defStyleRes传入R.style.DefStyleRes。 布局文件如下：\n其中theme中引用了attr11的引用，而themestyle中引用了attr1-attr4，DefStyleRes中也引用了attr1-attr4。日志如下：\nR.styleable.gui总共长度是7，attr1用的xml中定义的，attr2是布局中定义的style中的属性，attr3和attr4取的是theme中attr11定义的attr3和attr4，由于attr5没有在attr11中的style中定义，所以取的是theme中的attr5属性。 优先级：布局中的attr\u0026gt;布局中的style中的attr\u0026gt;defStyleAttr中的attr\u0026gt;theme中的attr 此时无论怎么在DefStyleRes中定义属性，都不会在该style里面的attr取值，因为此时定义了defStyleAttr 此时如果去掉defStyleAttr，则会在DefStyleRes中取值：\n结果如下：\n总结：defStyleAttr定义了后，defStyleRes中的attr就不起作用了。\n参考：https://blog.csdn.net/GracefulGuigui/article/details/104069265\n","date":"2024-10-25T00:00:00Z","permalink":"https://example.com/p/android-context%E6%80%BB%E7%BB%93/","title":"Android context总结"}]