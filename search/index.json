[{"content":"Recyclerview系列 缓存相关\nRecyclerView 缓存机制 | 如何复用表项？ RecyclerView 缓存机制 | 回收些什么？ RecyclerView 缓存机制 | 回收到哪去？ RecyclerView缓存机制 | scrap view 的生命周期 RecyclerView 面试题 | 滚动时表项是如何被填充或回收的？ RecyclerView 面试题 | 哪些情况下表项会被回收到缓存池？ RecyclerView 刷新列表数据的 notifyDataSetChanged() 为什么是昂贵的? 掌握这17张图，没人比你更懂RecyclerView的预加载 【动画图解】这个值取对了，ViewPager2才能纵享丝滑 动画相关\nRecyclerView 动画原理 | 换个姿势看源码（pre-layout） RecyclerView 动画原理 | pre-layout，post-layout 与 scrap 缓存的关系） RecyclerView 动画原理 | 如何存储并应用动画属性值？） 优化相关\n浅谈RecyclerView的性能优化） RecyclerView 性能优化 | 把加载表项耗时减半 (一) RecyclerView性能优化之异步预加载 Kotlin系列 ","date":"2025-01-22T00:00:00Z","permalink":"https://example.com/p/%E9%AB%98%E8%B4%A8%E9%87%8F%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/","title":"高质量文章汇总"},{"content":"上一篇(RecyclerView性能优化)理论知识讲过recyclerview有哪些优化点，该篇主要结合理论知识来实践下优化手段。\nxml布局替换为动态创建 一个简单的textview先通过xml创建，通过traceview观察耗时 这次三次创建viewholder的耗时，其中第一次由于需要类加载到jvm中，所以会耗时长一些，后面的话，基本在5ms左右。 通过new的形式创建viewholder： 第一次耗时在6ms，第二次耗时在4ms，基本比xml的形式要少个1ms 注意：这里演示的只是一个简单的textview，如果平时开发的布局是比较复杂，并且嵌套层级比较深的话，这种差距会更加明显。 通过perfetto观察create过程： 基本数据和traceview保持一致。 recyclerview.setHasFixSize(true) 用了sethasfixsize(true)的时候，会通过consumePendingUpdateOperations触发recyclerview的layout过程，没有走从根view到recyclerview的measure、layout过程，实际sethasfixsize(true)会给choreographer发送一条callback_animal的消息： 其实我们的属性动画也是这么做的，给choreographer发送一条animal的消息。sethasfixsize(true)在表项尺寸不发生变化的时候使用，减少不必要的measure过程。\nsethasstableids(true)和重写getItemId： 调用notifydatasetChange后，不会走oncreateviewholder： 从trace分析： detach过程调用的是scrap的缓存，并且此时不会回调ondetachfromwindow过程，并且都加入到了attach的scrap缓存中，在fill阶段通过重写的getItemId拿到了viewholder： 至于为什么会onbind，是因为notify过后的item的状态变成了invalid状态，所以会重新走onbind过程。\nrecyclerpool减少oncreateviewholder次数： tablayout+viewpager2，子页面是fragment，每个fragment中的rv用的viewholder是同种类型，我们将recyclerpool设置在activity中，然后传给子fragment，设置recyclerpool需要在setadapter之前。 我们在第一个页面滑动的时候，会有viewholder放到了recyclerpool中，此时我们滑动到第二个fragment的时候会用到recycerlpool中的viewholder。 从debug看，给另外一个recyclerview设置recyclerpool时候，已经存在一个viewholder，所以猜测该fragment会使用到viewholder，日志验证： 从日志来看，第一个viewholder只有bind过程，没有create。\n","date":"2025-01-17T00:00:00Z","permalink":"https://example.com/p/recyclerview%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/","title":"RecyclerView优化实践"},{"content":" 说起预加载，其实之前面试的时候被问到的，然后最近看到一篇关于预加载的文章，然后颇有感受，因此才有该篇文章。 在recyclerview的onAttachedToWindow有这么一句：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * On L+, with RenderThread, the UI thread has idle time after it has passed a frame off to * RenderThread but before the next frame begins. We schedule prefetch work in this window. */ static final boolean ALLOW_THREAD_GAP_WORK = Build.VERSION.SDK_INT \u0026gt;= 21; @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); //省略代码 if (ALLOW_THREAD_GAP_WORK) { // Register with gap worker mGapWorker = GapWorker.sGapWorker.get(); if (mGapWorker == null) { mGapWorker = new GapWorker(); // break 60 fps assumption if data from display appears valid // NOTE: we only do this query once, statically, because it\u0026#39;s very expensive (\u0026gt; 1ms) Display display = ViewCompat.getDisplay(this); float refreshRate = 60.0f; if (!isInEditMode() \u0026amp;\u0026amp; display != null) { float displayRefreshRate = display.getRefreshRate(); if (displayRefreshRate \u0026gt;= 30.0f) { refreshRate = displayRefreshRate; } } mGapWorker.mFrameIntervalNs = (long) (1000000000 / refreshRate); GapWorker.sGapWorker.set(mGapWorker); } mGapWorker.add(this); } } 可以看到有一个静态变量，ALLOW_THREAD_GAP_WORK是大于等于21（Android5.0）才会为true，这是因为在5.0之后，引进了RenderThread线程，专门用来渲染ui线程绘制好的数据，渲染完后，会提交到事先申请的bufferqueue中，然后当vsync-sf信号来的时候，sufaceflinger会去对应app的bufferqueue中取出前面提交的buffer数据，然后进行合成layer，最终屏幕（hwc）收到该请求后，进行图层进行合成，最终送到屏幕硬件上显示。这就是一针从创建到消费的过程。 由于ui线程把绘制好的数据绘制好后，会通知renderthread线程进行渲染，直到下一针来的时候才开始工作，此时会有主线程空闲的时候，recyclerview正是利用此空闲时间来进行预加载，而如果在下一针来临的时候，预加载还没有完成，那么此时会放弃此次的预加载，了解原理后，开始分析过程： 预加载的处理类是GapWorker类，一个线程对应一个GapWorker，它是存储在ThreadLocal中。GapWorker是一个runnable类，它如何要工作的话，是通过GapWorker.postFromTraversal工作的：\n1 2 3 4 5 6 7 8 9 10 11 12 void postFromTraversal(RecyclerView recyclerView, int prefetchDx, int prefetchDy) { if (recyclerView.isAttachedToWindow()) { if (RecyclerView.DEBUG \u0026amp;\u0026amp; !mRecyclerViews.contains(recyclerView)) { throw new IllegalStateException(\u0026#34;attempting to post unregistered view!\u0026#34;); } if (mPostTimeNs == 0) { mPostTimeNs = recyclerView.getNanoTime(); recyclerView.post(this); } } recyclerView.mPrefetchRegistry.setPrefetchVector(prefetchDx, prefetchDy); } 可以看出来实际是通过recyclerview.post，然后传的是自己，因此会直接run方法。预加载时机在源码里面有两处调用了：\nRecyclerview被拖动时： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Override public boolean onTouchEvent(MotionEvent e) { ... switch (action) { ... case MotionEvent.ACTION_MOVE: { ... if (mScrollState == SCROLL_STATE_DRAGGING) { ... // 处于拖动状态并且存在有效的拖动距离时 if (mGapWorker != null \u0026amp;\u0026amp; (dx != 0 || dy != 0)) { mGapWorker.postFromTraversal(this, dx, dy); } } } break; ... } ... return true; } Recyclerview惯性滑动时： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class ViewFlinger implements Runnable { ... @Override public void run() { ... if (!smoothScrollerPending \u0026amp;\u0026amp; doneScrolling) { ... } else { ... if (mGapWorker != null) { mGapWorker.postFromTraversal(RecyclerView.this, consumedX, consumedY); } } } ... } 看下GapWorker的run方法如何实现的预加载：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Override public void run() { try { TraceCompat.beginSection(RecyclerView.TRACE_PREFETCH_TAG); if (mRecyclerViews.isEmpty()) { // abort - no work to do return; } // Query most recent vsync so we can predict next one. Note that drawing time not yet // valid in animation/input callbacks, so query it here to be safe. final int size = mRecyclerViews.size(); long latestFrameVsyncMs = 0; for (int i = 0; i \u0026lt; size; i++) { RecyclerView view = mRecyclerViews.get(i); if (view.getWindowVisibility() == View.VISIBLE) { latestFrameVsyncMs = Math.max(view.getDrawingTime(), latestFrameVsyncMs); } } if (latestFrameVsyncMs == 0) { // abort - either no views visible, or couldn\u0026#39;t get last vsync for estimating next return; } long nextFrameNs = TimeUnit.MILLISECONDS.toNanos(latestFrameVsyncMs) + mFrameIntervalNs; prefetch(nextFrameNs); // TODO: consider rescheduling self, if there\u0026#39;s more work to do } finally { mPostTimeNs = 0; TraceCompat.endSection(); } } 在调用prefetch前传入nextFrameNs，该值表示预估的下一个vsync来临的时间，首先获取上一针的绘制起始时间，也就是latestFrameVsyncMs，而mFrameIntervalNs是通过刷新率算出来的一针需要的时间，比如60hz的手机，一秒是60帧，那么mFrameIntervalNs的值是一针需要16ms，mFrameIntervalNs的单位是纳秒，这个时间在开篇的onAttachedToWindow方法中计算的，所以可以看出来，nextFrameNs时间就是预加载最后的期限时间，超过这个时间就会放弃该预加载，上面提到的上一针时间是用过recyclerview的getDrawingTime获取的，它是获取的attachInfo的mDrawingTime时间，而mDrawingTime是在viewRootImpl中draw方法给赋值的：\n1 2 3 4 5 6 private boolean draw(boolean fullRedrawNeeded, boolean forceDraw) { //省略代码 mAttachInfo.mDrawingTime = mChoreographer.getFrameTimeNanos() / TimeUtils.NANOS_PER_MS; //省略代码 } 可以看出来，它是通过Choreographer的getFrameTimeNanos方法来获取的：\n1 2 3 4 5 @UnsupportedAppUsage public long getFrameTimeNanos() { //省略代码 return USE_FRAME_TIME ? mLastFrameTimeNanos : System.nanoTime(); } mLastFrameTimeNanos是在doFrame中将参数frameTimeNanos给赋值的，而frameTimeNanos参数表示的就是当前vsnyc信号来临的时间。所以最终结论就是通过遍历recyclerview的drawingtime，来获取最近一次的vsync时间，并加上当前设备一针所需要的时间，从而得到下一个vsync信号来临的时间，也就是预加载要完成的最晚时间。继续跟进GapWorker的prefetch方法：\n1 2 3 4 void prefetch(long deadlineNs) { buildTaskList(); flushTasksWithDeadline(deadlineNs); } buildTaskList，它是用来构建预加载的task列表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private void buildTaskList() { // Update PrefetchRegistry in each view final int viewCount = mRecyclerViews.size(); int totalTaskCount = 0; for (int i = 0; i \u0026lt; viewCount; i++) { RecyclerView view = mRecyclerViews.get(i); if (view.getWindowVisibility() == View.VISIBLE) { //收集要预加载的view的position view.mPrefetchRegistry.collectPrefetchPositionsFromView(view, false); totalTaskCount += view.mPrefetchRegistry.mCount; } } //省略代码 } 首先是调用了view.mPrefetchRegistry.collectPrefetchPositionsFromView(view, false)来收集预加载的view：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void collectPrefetchPositionsFromView(RecyclerView view, boolean nested) { mCount = 0; if (mPrefetchArray != null) { Arrays.fill(mPrefetchArray, -1); } final RecyclerView.LayoutManager layout = view.mLayout; if (view.mAdapter != null \u0026amp;\u0026amp; layout != null \u0026amp;\u0026amp; layout.isItemPrefetchEnabled()) { //省略代码 if (!view.hasPendingAdapterUpdates()) { layout.collectAdjacentPrefetchPositions(mPrefetchDx, mPrefetchDy, view.mState, this); } //省略代码 } } 可以看出来调用了layoutmanager的collectAdjacentPrefetchPositions的方法，把需要预加载的水平和竖直方向的偏移量传入其中，看下LinearLayoutManager的该方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Override public void collectAdjacentPrefetchPositions(int dx, int dy, RecyclerView.State state, LayoutPrefetchRegistry layoutPrefetchRegistry) { int delta = (mOrientation == HORIZONTAL) ? dx : dy; if (getChildCount() == 0 || delta == 0) { // can\u0026#39;t support this scroll, so don\u0026#39;t bother prefetching return; } ensureLayoutState(); final int layoutDirection = delta \u0026gt; 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START; final int absDelta = Math.abs(delta); updateLayoutState(layoutDirection, absDelta, true, state); collectPrefetchPositionsForLayoutState(state, mLayoutState, layoutPrefetchRegistry); } 通过方法来判断偏移量，然后把方向标识传入到updateLayoutState中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private void updateLayoutState(int layoutDirection, int requiredSpace, boolean canUseExistingSpace, RecyclerView.State state) { //省略代码 if (layoutToEnd) { //获取可见的最后一个表项 final View child = getChildClosestToEnd(); //判断是否是reverse的 mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD : LayoutState.ITEM_DIRECTION_TAIL; //获取预加载的position mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection; mLayoutState.mOffset = mOrientationHelper.getDecoratedEnd(child); //获取要预加载的表项与recyclerview底部的距离 scrollingOffset = mOrientationHelper.getDecoratedEnd(child) - mOrientationHelper.getEndAfterPadding(); } else { //省略代码 } //省略代码 mLayoutState.mScrollingOffset = scrollingOffset; } 此处只保留从上到下的滑动，先是获取页面滚动的最后一个表项，然后判断是不是reverseLayout，如果不是则取LayoutState.ITEM_DIRECTION_TAIL(该值等于1)，预加载的position等于最后一个表项的position+1，接着算出预加载的表项离recyclerview底部的距离。它是通过mOrientationHelper.getDecoratedEnd(child)- mOrientationHelper.getEndAfterPadding()得到的。 mOrientationHelper.getDecoratedEnd(child)它是在OrientationHelper中定义的createVerticalHelper方法中实现的：\n1 2 3 4 5 6 @Override public int getDecoratedEnd(View view) { final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) view.getLayoutParams(); return mLayoutManager.getDecoratedBottom(view) + params.bottomMargin; } 1 2 3 public int getDecoratedBottom(@NonNull View child) { return child.getBottom() + getBottomDecorationHeight(child); } getDecoratedBottom是获取child的bottom+child的底部间距高度，所以getDecoratedEnd是获取child的bottom+child的底部间距高度+下间距。 mOrientationHelper.getEndAfterPadding()也是在OrientationHelper中定义的createVerticalHelper方法中实现的：\n1 2 3 4 @Override public int getEndAfterPadding() { return mLayoutManager.getHeight() - mLayoutManager.getPaddingBottom(); } getEndAfterPadding是recyclerview的高度-recyclerview的下内边距。所以scrollingOffset是即将要预加载的表项离recyclerview底部的间距。接着看下collectPrefetchPositionsForLayoutState方法：\n1 2 3 4 5 6 7 void collectPrefetchPositionsForLayoutState(RecyclerView.State state, LayoutState layoutState, LayoutPrefetchRegistry layoutPrefetchRegistry) { final int pos = layoutState.mCurrentPosition; if (pos \u0026gt;= 0 \u0026amp;\u0026amp; pos \u0026lt; state.getItemCount()) { layoutPrefetchRegistry.addPosition(pos, Math.max(0, layoutState.mScrollingOffset)); } } 将刚才算的预加载的postion和偏移量传入到addPosition中，该方法是在GapWorker中实现的：\n1 2 3 4 5 6 7 8 @Override public void addPosition(int layoutPosition, int pixelDistance) { //省略代码 final int storagePosition = mCount * 2; mPrefetchArray[storagePosition] = layoutPosition; mPrefetchArray[storagePosition + 1] = pixelDistance; mCount++; } 将position和偏移量成对保存在mPrefetchArray数组中。构建完数组中，接着就是将数组的数据存到task中。这块逻辑在buildTaskList中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private void buildTaskList() { for (int i = 0; i \u0026lt; viewCount; i++) { RecyclerView view = mRecyclerViews.get(i); if (view.getWindowVisibility() != View.VISIBLE) { // Invisible view, don\u0026#39;t bother prefetching continue; } LayoutPrefetchRegistryImpl prefetchRegistry = view.mPrefetchRegistry; final int viewVelocity = Math.abs(prefetchRegistry.mPrefetchDx) + Math.abs(prefetchRegistry.mPrefetchDy); for (int j = 0; j \u0026lt; prefetchRegistry.mCount * 2; j += 2) { final Task task; if (totalTaskIndex \u0026gt;= mTasks.size()) { task = new Task(); mTasks.add(task); } else { task = mTasks.get(totalTaskIndex); } final int distanceToItem = prefetchRegistry.mPrefetchArray[j + 1]; task.immediate = distanceToItem \u0026lt;= viewVelocity; task.viewVelocity = viewVelocity; task.distanceToItem = distanceToItem; task.view = view; task.position = prefetchRegistry.mPrefetchArray[j]; totalTaskIndex++; } } } task信息由由以下组成： immediate：表示是否立即执行，判断依据预加载的表项离recyclerview底部距离是否小于滑动的速度 viewVelocity：滑动的速度 distanceToItem：预加载的表项离recyclerview底部距离 view：recyclerview position：预加载表项的位置 从上面可以看出来从mPrefetchArray数组中取值是每两个值取出的，和上面build过程对应。所有的完事后，在buildTaskList中就是对task进行排序：\n1 2 3 4 5 private void buildTaskList() { ... // 3.对任务列表进行优先级排序 Collections.sort(mTasks, sTaskComparator); } 上面就是整个buildTaskList的逻辑，接着就是根据构建的task来创建viewholder，该逻辑是在flushTasksWithDeadline方法中：\n1 2 3 4 5 6 7 8 9 10 private void flushTasksWithDeadline(long deadlineNs) { for (int i = 0; i \u0026lt; mTasks.size(); i++) { final Task task = mTasks.get(i); if (task.view == null) { break; // done with populated tasks } flushTaskWithDeadline(task, deadlineNs); task.clear(); } } flushTaskWithDeadline:\n1 2 3 4 5 6 private void flushTaskWithDeadline(Task task, long deadlineNs) { long taskDeadlineNs = task.immediate ? RecyclerView.FOREVER_NS : deadlineNs; RecyclerView.ViewHolder holder = prefetchPositionWithDeadline(task.view, task.position, taskDeadlineNs); //省略代码 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private RecyclerView.ViewHolder prefetchPositionWithDeadline(RecyclerView view, int position, long deadlineNs) { RecyclerView.Recycler recycler = view.mRecycler; RecyclerView.ViewHolder holder; holder = recycler.tryGetViewHolderForPositionByDeadline( position, false, deadlineNs); if (holder != null) { if (holder.isBound() \u0026amp;\u0026amp; !holder.isInvalid()) { //如果holder已经绑定过并且是可用的，加入到cacheview缓存中 recycler.recycleView(holder.itemView); } else { //否则加入到RecycledViewPool中 recycler.addViewHolderToRecycledViewPool(holder, false); } } return holder; } 上面通过tryGetViewHolderForPositionByDeadline获取viewholder，和正常获取viewholder的区别是传入了deadlineNs，直接看该方法是如何放弃超时的viewholder：\n1 2 3 4 5 6 7 8 9 10 ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) { if (holder == null) { long start = getNanoTime(); if (deadlineNs != FOREVER_NS \u0026amp;\u0026amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) { return null; } } } 如果deadlineNs不是FOREVER_NS，普通调用该方法传入的deadlineNs是FOREVER_NS，所以是通过该值区分是不是预加载调用的，接着通过willCreateInTime返回值判断要不要放弃：\n1 2 3 4 boolean willCreateInTime(int viewType, long approxCurrentNs, long deadlineNs) { long expectedDurationNs = getScrapDataForType(viewType).mCreateRunningAverageNs; return expectedDurationNs == 0 || (approxCurrentNs + expectedDurationNs \u0026lt; deadlineNs); } expectedDurationNs取的是对应viewholder的平均创建时间，其实也不叫平均时间：\n1 2 3 4 5 6 7 8 9 10 11 void factorInCreateTime(int viewType, long createTimeNs) { ScrapData scrapData = getScrapDataForType(viewType); scrapData.mCreateRunningAverageNs = runningAverage( scrapData.mCreateRunningAverageNs, createTimeNs); } long runningAverage(long oldAverage, long newValue) { if (oldAverage == 0) { return newValue; } return (oldAverage / 4 * 3) + (newValue / 4); } 每次将之前的创建viewholder时间占3分之4，当前创建的时间占1分之4。所以willCreateInTime的返回值是如果当前时间+平均创建viewholder时间小于最晚约定时间则不会放弃，否则直接放弃。如果不放弃接着会判断bind过程有没有超过约定时间：\n1 2 3 4 5 6 7 8 9 10 11 12 13 private boolean tryBindViewHolderByDeadline(@NonNull ViewHolder holder, int offsetPosition, int position, long deadlineNs) { final int viewType = holder.getItemViewType(); long startBindNs = getNanoTime(); if (deadlineNs != FOREVER_NS \u0026amp;\u0026amp; !mRecyclerPool.willBindInTime(viewType, startBindNs, deadlineNs)) { return false; } mAdapter.bindViewHolder(holder, offsetPosition); long endBindNs = getNanoTime(); mRecyclerPool.factorInBindTime(holder.getItemViewType(), endBindNs - startBindNs); return true; } bind过程是通过willBindInTime方法来判断有没有超过约定时间的，整个逻辑很清晰。\n前面分析过如果holder是bind过的，则会加入到cacheview缓存中，否则加入到RecycledViewPool中，正常滑动的时候离屏的viewholder也是添加到cacheview缓存中的，那两者在缓存中又是怎么区分的呢？直接看recycler的recycleViewHolderInternal方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void recycleViewHolderInternal(ViewHolder holder) { //省略代码 //默认插入cacheview缓存的索引是末尾 int targetCacheIndex = cachedViewSize; if (ALLOW_THREAD_GAP_WORK \u0026amp;\u0026amp; cachedViewSize \u0026gt; 0 \u0026amp;\u0026amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) {//如果是正常离屏的viewholder //默认指向最后一个元素 int cacheIndex = cachedViewSize - 1; while (cacheIndex \u0026gt;= 0) { int cachedPos = mCachedViews.get(cacheIndex).mPosition; //如果当前表项不是预拉取的表项则退出 if (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) { break; } cacheIndex--; } targetCacheIndex = cacheIndex + 1; } mCachedViews.add(targetCacheIndex, holder); //省略代码 } 默认插入cacheview缓存的索引是在末尾，在插入正常离屏的viewholder时候如果遇到预拉取的viewholder，则往前找直到最后一个离屏的viewholder，然后插入到它后面。所以不难看出，预拉取的会在后面，离屏的会在前面。这样的好处是预加载的viewholder由于在后面使用的机会会很大，放在集合的后面删除的概率要小。\n参考：掌握这17张图，没人比你更懂RecyclerView的预加载\n","date":"2025-01-17T00:00:00Z","permalink":"https://example.com/p/recyclerview%E7%9A%84%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/","title":"RecyclerView的预加载实现"},{"content":" 关于RecyclerView的优化，其实无非两点，尽可能的最大化使用viewholder的缓存，如果不能使用缓存，将构建和绑定viewholder的过程耗时降低到最低。\n缓存 这里再总结下RecyclerView的缓存知识：\n分类 scrap缓存：用于缓存页面暂时分离的viewholder，分为changeScrap和attachScrap，changeScrap用于缓存要update的viewholder，attachscrap缓存非update的viewholder。 不作用于页面滑动，开发干预不了该缓存。它缓存的个数是一屏的viewholder。 cacheview缓存：是一个arraylist的结构，在滑动的时候，滑出屏幕的viewholder会保存到该缓存中，默认保存的数量是2个，当超过2个的时候，会先移除集合中第一个viewholder，并把该viewholder进行重置。 然后加入到recyclerpool缓存中，最后把新的viewholder加入到cacheview缓存尾部，整个过程，cacheview缓存相当于是一个队列，先进先出的规则。它是根据position来取的，不需要重新bind ViewCacheExtension：mViewCacheExtension又称拓展缓存，为开发者预留的缓存池，开发者可以自己拓展回收池，一般不会用到。 最后就是recyclerpool缓存，它是在cacheview满了的时候，加入到该缓存中的，它是根据viewtype缓存的。在它里面的viewholder都被重置过了的，所以从它里面取出来的viewholder都需要重新bind。 缓存回收 在不滚动情况下： 会把页面上可见的viewholder缓存到scrap中，如果viewholder中有flag_update标记的时候，则把它添加到changeScrap中，否则加入到attachScrap中。 在滚动情况下： 会把滑出recyclerview的viewholder先添加到cacheView缓存中，如果cacheView缓存满了话，会把集合开始的位置viewholder给放到RecycledViewPool中，RecycledViewPool会按照每种viewtype的viewholder为5的容量进行回收，如果超过5个的时候，就不会往里面存了。\n缓存复用 如果是在pre-layout阶段，会去changeScrap缓存中通过position查找viewholder，如果通过position找不到，则通过id去查找，从changeScrap缓存中取出的。 在pre-layout和post-layout阶段会先从attachScrap缓存中通过position查找viweholder，如果没找到则会从cacheview缓存中通过position查找viewholder，如果没找到再通过id从attchScrap和cacheview中找viewholder，如果还没找到，则从ViewCacheExtension中找，如果还没找到则从RecycledViewPool中找，如果都没找到，则创建viewholder，由于changeScrap不参与post-layout阶段，所以在post-layout阶段会走创建表项和绑定表项，attachScrap由于是精准匹配，所以无需创建和绑定，cacheview缓存也是精准匹配，RecycledViewPool中的viewholder由于都重置了，所以需要走绑定。\n缓存说明 scrap缓存只会在非滑动场景下进行保存，并且它保存的数量是一屏的数据，该缓存开发无法干预，cacheview缓存的是可以直接用的viewholder，无需bind和create，但是默认容量很小，可以动态设置，RecycledViewPool里面的viewholder都是重置过的，需要重新bind，按viewtype进行存储，每种viewtype的容量默认是5，也是可以设置大小。而ViewCacheExtension缓存虽然是扩展缓存，但是很少去用，所以可优化的缓存只有cacheview和RecycledViewPool\n如何最大化使用缓存？ 多使用scrap缓存来局部刷新 前面分析过使用notifyDataSetChange的时候会使可见的viewholder和缓存中的viewholder都失效了，导致所有的viewhodler都会先从pool缓存中找一遍，如果有的话，就需要重新bind，如果找不到则先走创建，然后走bind过程，所以局部刷新使用notifyItemChange和notifyItemRemove，如果只是刷新viewholder中的某一个子view，则使用payload的形式。 使用diffutils来实现局部刷新，无需关心刷新的索引，只需要提供变化的数据源 合理使用pool缓存，如果一屏展示的viewholder比较多，则可以适当增加pool缓存的最大数量，减少频繁创建viewholder 合理设置cacheview的缓存，如果recyclerview需要经常来回滑动，则可以适当增加cacheview的缓存数量 重写adapter的getItemId并且给recyclerview设置setHasStableIds为true来给每一个viewholder增加唯一索引，这样在缓存查找的时候能增大复用。 如果两个recyclerview的viewholder有部分相同或者基本相同的情况下，给这两个recyclerview设置同一个RecycledViewPool来增加viewholder的复用度，注意此时给recyclerview设置pool的时候，需要在设置adapter之前 如果同一个recyclerview需要切换视图的时候，并且视图的样式是不同的adapter的时候，此时可以考虑用swapadapter来切换adapter，swapadapter是把attachScrap给清空，并把cacheview中的缓存加入到RecycledViewPool中，而setAdapter是清空所有的缓存。由于swapadapter是复用了RecycledViewPool中的缓存，因此要求前后的viewholder是同一种类型，否则会出现异常。 构建过程如何降低到最低？ 所谓构建就是指viewholder的create过程，该阶段主要是通过解析xml，来创建view，该阶段涉及到文件读取的io操作，以及反射生成view。一般我们可以通过动态创建view的形式来消除io操作和反射生成view。或者将xml的层级降到最低，减少inflate的时间。 提前解析xml，然后存放到缓存池中，等到使用的时候直接从池子中取。 绑定过程如何降低到最低？ 给视图设置监听器的时候，不要通过直接创建listener的形式，通过外界传入进来，然后在外界处理逻辑 绑定视图的时候不要做计算逻辑，将计算逻辑前置化，绑定应该是一个纯展示的过程 其它 如果item的大小是固定的，则使用setHasFixedSize(true)，这样可以避免在更新、添加、删除表项的时候重新requestLayout，而该过程会等到下一个vsync信号来的时候，走绘制流程，然后才是测量，使用该方法后，会给Choreographer发送一条animtion的消息，在下一个vsync来的时候，直接进行recyclerview的dispatchLayout。 开启recyclerview的预加载，recyclerview的预加载默认是开启的，如果要关闭通过layout.setItemPrefetchEnabled(false)来关闭，如果是自定义layoutmanager，则通过重写collectAdjacentPrefetchPositions来实现预加载 recyclerview会加载屏内可见的viewholder，如果viewholder对应的itemview高度或宽度很大的时候，可能加载的屏外viewholder很少，此时重写layoutmanager的calculateExtraLayoutSpace来实现屏外的viewholder加载，关于这块可以看viewpager2如何实现的屏外viewholder的加载。 参考： RecyclerView 性能优化 | 把加载表项耗时减半 (一) 浅谈RecyclerView的性能优化 RecyclerView性能优化之异步预加载 RecyclerView的预加载 【动画图解】这个值取对了，ViewPager2才能纵享丝滑 ","date":"2025-01-13T00:00:00Z","permalink":"https://example.com/p/recyclerview%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","title":"RecyclerView性能优化"},{"content":"大家有没有想过，scrap缓存存在的意义是什么？为什么存了后，又把它里面的viewholder又给删了？\n在上一篇(RecyclerView源码走读)中我们分析过更新和删除表项的过程，下面来总结下scrap缓存的过程：\n更新表项:页面上有表项0到9，总共有10个表项，然后更新表项0，在dispatchLayout1阶段（pre-layout），先把页面上的表项0到9存到scrap缓存中，由于表项0是更新的所以会把表项0放到changeScrap缓存中，把表项1到9存到attachScrap缓存中。同时会把这10个表项从页面上分离（child的parent置空，并把viewgroup中对应的child给置空），接着从scrap缓存中取出viewholder，由于存在更新表项，所以会去创建表项10的viewholder到recyclerview上。此时recyclerview中有11个表项了，同时把他们从scrap缓存中移除。 在dispatchLayout2阶段（post-layout）阶段，会把这11个表项加入到scrap缓存中，表项0还是放到changeScrap中，表项1到10加入到attachScrap缓存中。接着把他们从页面上分离。然后在fill中，从scrap缓存中获取viewholder，由于changeScrap不会在dispatchLayout2阶段生效，所以会创建了表项0，其余的表项正常从attachScrap缓存中获取。接着把所有的表项添加到recyclerview中，并把scrap中的viewholder缓存移除掉。但是表项10不会添加到recyclerview中，因为到表项9的时候，剩余空间就不够了，所以recyclerview中只有0到9的表项。注意：此时还有表项0个表项10分别存在于changeScrap和attachScrap中。\n上面更新表项经历了两次的布局，分别是dispatchLayout1和dispatchLayout2，在这两个步骤中，先加入到scrap缓存中，然后再从scrap缓存中移除。从现象来看，dispatchLayout1中会生成11个表项，分别是0到10，然后在dispatchLayout2先移除所有的表项，然后添加0到9的表项，而在dispatchLayout2中表项0是重新生成的，因为它要实现更新。而调用两次的布局是为了实现动画而这么做，先生成11个表项，来把他们的位置都记录下来，然后第二次布局的时候把10个表项的位置也记录下来，然后最后根据存储的位置信息做动画。下面来分析下动画如何实现的：\n在dispatchLayoutStep1将页面上可见的表项加入到ViewInfoStore中： 1 2 3 4 5 6 7 8 9 void addToPreLayout(RecyclerView.ViewHolder holder, RecyclerView.ItemAnimator.ItemHolderInfo info) { InfoRecord record = mLayoutHolderMap.get(holder); if (record == null) { record = InfoRecord.obtain(); mLayoutHolderMap.put(holder, record); } record.preInfo = info; record.flags |= FLAG_PRE; } 将viewholder和infoRecord绑定好关系，然后给该record添加上FLAG_PRE标记。注意：此处的InforRecord使用了对象池。 前面分析过在fill完之后，页面上会多出一个表项10，此时也会添加到ViewInfoStore中： 可以看到在onLayoutChildren之后会调用addToAppearedInPreLayoutHolders，此时只有表项10会调用addToAppearedInPreLayoutHolders：\n1 2 3 4 5 6 7 8 9 void addToAppearedInPreLayoutHolders(RecyclerView.ViewHolder holder, RecyclerView.ItemAnimator.ItemHolderInfo info) { InfoRecord record = mLayoutHolderMap.get(holder); if (record == null) { record = InfoRecord.obtain(); mLayoutHolderMap.put(holder, record); } record.flags |= FLAG_APPEAR; record.preInfo = info; } 所以只有表项10添加了FLAG_APPEAR标记。\n在dispatchLayoutStep2走完后，页面上可见的表项就只剩0到9了，在dispatchLayoutStep3中将变化的viewholder调用animateChange，而其他的viewholder调用了addToPostLayout，在该例子中表项0会调用animateChange，表项1到9会调用addToPostLayout：\nanimateChange：当有viewholder发生变化的时候，会触发该方法，该方法会触发mItemAnimator的animateChange方法：\n1 2 3 4 5 6 7 8 private void animateChange(@NonNull ViewHolder oldHolder, @NonNull ViewHolder newHolder, @NonNull ItemHolderInfo preInfo, @NonNull ItemHolderInfo postInfo, boolean oldHolderDisappearing, boolean newHolderDisappearing) { //省略代码 if (mItemAnimator.animateChange(oldHolder, newHolder, preInfo, postInfo)) { postAnimationRunner(); } } 调用了mItemAnimator的animateChange方法，并把改变之前的holder、itemholderinfo和改变之后的holder、itemholderinfo传进去了，默认的itemAnimator是DefaultItemAnimator，也是一个SimpleItemAnimator:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Override public boolean animateChange(@NonNull RecyclerView.ViewHolder oldHolder, @NonNull RecyclerView.ViewHolder newHolder, @NonNull ItemHolderInfo preInfo, @NonNull ItemHolderInfo postInfo) { if (DEBUG) { Log.d(TAG, \u0026#34;CHANGED: \u0026#34; + oldHolder + \u0026#34; with view \u0026#34; + oldHolder.itemView); } final int fromLeft = preInfo.left; final int fromTop = preInfo.top; final int toLeft, toTop; if (newHolder.shouldIgnore()) { toLeft = preInfo.left; toTop = preInfo.top; } else { toLeft = postInfo.left; toTop = postInfo.top; } return animateChange(oldHolder, newHolder, fromLeft, fromTop, toLeft, toTop); } fromLeft、fromTop是老的holder的坐标，toLeft、toTop是新的holder的坐标，最后调用了另外一个animateChange：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Override public boolean animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, int fromX, int fromY, int toX, int toY) { if (oldHolder == newHolder) { // Don\u0026#39;t know how to run change animations when the same view holder is re-used. // run a move animation to handle position changes. return animateMove(oldHolder, fromX, fromY, toX, toY); } final float prevTranslationX = oldHolder.itemView.getTranslationX(); final float prevTranslationY = oldHolder.itemView.getTranslationY(); final float prevAlpha = oldHolder.itemView.getAlpha(); resetAnimation(oldHolder); int deltaX = (int) (toX - fromX - prevTranslationX); int deltaY = (int) (toY - fromY - prevTranslationY); // recover prev translation state after ending animation oldHolder.itemView.setTranslationX(prevTranslationX); oldHolder.itemView.setTranslationY(prevTranslationY); oldHolder.itemView.setAlpha(prevAlpha); if (newHolder != null) { // carry over translation values resetAnimation(newHolder); newHolder.itemView.setTranslationX(-deltaX); newHolder.itemView.setTranslationY(-deltaY); newHolder.itemView.setAlpha(0); } mPendingChanges.add(new ChangeInfo(oldHolder, newHolder, fromX, fromY, toX, toY)); return true; } 如果新老holder是同一个，则调用animateMove，前面分析过oldHolder和newHolder不是同一个，所以先把newHolder的translationX和translationX设置到目标位置，其实此时的deltaX和deltaY为0，因为目标的viewholder位置也在原来表项0的位置，接着把透明度设置为0，最后创建了ChangeInfo，放入到mPendingChanges中。当animateChange返回true后，会调用postAnimationRunner方法：\n1 2 3 4 5 6 void postAnimationRunner() { if (!mPostedAnimatorRunner \u0026amp;\u0026amp; mIsAttached) { ViewCompat.postOnAnimation(this, mItemAnimatorRunner); mPostedAnimatorRunner = true; } } ViewCompat.postOnAnimation(this, mItemAnimatorRunner)是给Choreographer中添加一条CALLBACK_ANIMATION类型的事件，等到下一个vsync信号来的时候，就会执行mItemAnimatorRunner：\n1 2 3 4 5 6 7 8 9 private Runnable mItemAnimatorRunner = new Runnable() { @Override public void run() { if (mItemAnimator != null) { mItemAnimator.runPendingAnimations(); } mPostedAnimatorRunner = false; } }; 最终会执行DefaultItemAnimator的runPendingAnimations方法，该方法会执行changesPending的逻辑，最终会执行animateChangeImpl：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 void animateChangeImpl(final ChangeInfo changeInfo) { final RecyclerView.ViewHolder holder = changeInfo.oldHolder; final View view = holder == null ? null : holder.itemView; final RecyclerView.ViewHolder newHolder = changeInfo.newHolder; final View newView = newHolder != null ? newHolder.itemView : null; if (view != null) {//改变之前的view final ViewPropertyAnimator oldViewAnim = view.animate().setDuration( getChangeDuration()); mChangeAnimations.add(changeInfo.oldHolder); oldViewAnim.translationX(changeInfo.toX - changeInfo.fromX); oldViewAnim.translationY(changeInfo.toY - changeInfo.fromY); oldViewAnim.alpha(0).setListener(new AnimatorListenerAdapter() { @Override public void onAnimationStart(Animator animator) { dispatchChangeStarting(changeInfo.oldHolder, true); } @Override public void onAnimationEnd(Animator animator) { oldViewAnim.setListener(null); view.setAlpha(1); view.setTranslationX(0); view.setTranslationY(0); dispatchChangeFinished(changeInfo.oldHolder, true); mChangeAnimations.remove(changeInfo.oldHolder); dispatchFinishedWhenDone(); } }).start(); } if (newView != null) {//改变之后的view final ViewPropertyAnimator newViewAnimation = newView.animate(); mChangeAnimations.add(changeInfo.newHolder); newViewAnimation.translationX(0).translationY(0).setDuration(getChangeDuration()) .alpha(1).setListener(new AnimatorListenerAdapter() { @Override public void onAnimationStart(Animator animator) { dispatchChangeStarting(changeInfo.newHolder, false); } @Override public void onAnimationEnd(Animator animator) { newViewAnimation.setListener(null); newView.setAlpha(1); newView.setTranslationX(0); newView.setTranslationY(0); dispatchChangeFinished(changeInfo.newHolder, false); mChangeAnimations.remove(changeInfo.newHolder); dispatchFinishedWhenDone(); } }).start(); } } 该方法里面通过view的animate方法给view做动画，改变之前的view位置不会发生变化，只会发生alpha的动画，而改变之后的view会做从0到1的透明度动画。所以最终页面上会出现闪的一下，这个是做更新操作。 上面分析的是表项0会调用animateChange，表项1到9会执行addToPostLayout：\n1 2 3 4 5 6 7 8 9 void addToPostLayout(RecyclerView.ViewHolder holder, RecyclerView.ItemAnimator.ItemHolderInfo info) { InfoRecord record = mLayoutHolderMap.get(holder); if (record == null) { record = InfoRecord.obtain(); mLayoutHolderMap.put(holder, record); } record.postInfo = info; record.flags |= FLAG_POST; } 在dispatchLayout1的时候，表项1到9会添加上FLAG_PRE标记，接着在此处又添加上FLAG_POST标记，表项10添加了FLAG_APPEAR标记。所有的标记添加完后，最终会执行ViewInfoStore的process：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void process(ProcessCallback callback) { for (int index = mLayoutHolderMap.size() - 1; index \u0026gt;= 0; index--) { final RecyclerView.ViewHolder viewHolder = mLayoutHolderMap.keyAt(index); final InfoRecord record = mLayoutHolderMap.removeAt(index); if ((record.flags \u0026amp; FLAG_PRE_AND_POST) == FLAG_PRE_AND_POST) { // Persistent in both passes. Animate persistence callback.processPersistent(viewHolder, record.preInfo, record.postInfo); } else if ((record.flags \u0026amp; FLAG_APPEAR) != 0) { // Scrap view. RecyclerView will handle removing/recycling this. } InfoRecord.recycle(record); } } 这里省略了无关紧要的代码，表项1到9会调用callback.processPersistent回调，表项10不做相关更新：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Override public void processPersistent(ViewHolder viewHolder, @NonNull ItemHolderInfo preInfo, @NonNull ItemHolderInfo postInfo) { viewHolder.setIsRecyclable(false); if (mDataSetHasChangedAfterLayout) { // since it was rebound, use change instead as we\u0026#39;ll be mapping them from // stable ids. If stable ids were false, we would not be running any // animations if (mItemAnimator.animateChange(viewHolder, viewHolder, preInfo, postInfo)) { postAnimationRunner(); } } else if (mItemAnimator.animatePersistence(viewHolder, preInfo, postInfo)) { postAnimationRunner(); } } 由于mDataSetHasChangedAfterLayout是在setAdapter中设置的，所以会走mItemAnimator.animateChange逻辑，在上面分析过，如果两个viewholder是同一个，则调用animateMove方法，而位置信息又不发生变化，所以animateChange返回false，因此也不会触发postAnimationRunner。\nrecyclerview中只要被添加到页面上的viewholder，并且是scrap缓存中的，最终都会从scrap缓存中移除。而在上面的例子中，分析dispatchLayout2的时候总共有11个表项，分别是原来的表项0（存在于changeScrap缓存中），dispatchLayout1创建的表项10（存在于attachScrap中）。在dispatchLayout3做完动画后，会清空掉scrap缓存，也就是调用了mLayout.removeAndRecycleScrapInt方法：\n1 2 3 4 5 void removeAndRecycleScrapInt(Recycler recycler) { //省略代码 recycler.clearScrap(); //省略代码 } 最终会调用clearScrap来清空scrap缓存。\n关于删除表项的动画处理，可以看这里:RecyclerView 动画原理 | 如何存储并应用动画属性值？\n","date":"2025-01-09T00:00:00Z","permalink":"https://example.com/p/recyclerview%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86/","title":"RecyclerView动画原理"},{"content":"初始化过程 当我们app收到choregrapher的vsync信号的时候，choregrapher中会给主线程的messageQueue发送一条消息， 告诉app需要绘制了，而此时发送是通过给主线程的messageQueue设置一个callback（runnable），所以会触发handler的dispatchmessage-\u0026gt;handleCallback，接着就是触发FrameDisplayEventReceiver（runnable）的doframe方法，该方法会计算丢帧数，以及执行callbackqueue数组中的callbackqueue，也就执行到了我们的performTraversal方法，该方法里面会执行到measure，最后执行到recyclerview的onMeause，recyclerview的onMeasure中会判断自己的测量模式，如果是精确的模式，则不测量子item。\ntrace图如下： 接着走到recyclerview的onlayout，在onlayout里面触发dispatchlayout，该方法里面会判断state的step，默认是STEP_START，因此会触发dispatchLayoutStep1和dispatchLayoutStep2，在dispatchLayoutStep1中如果有动画要处理，则会触发layoutManager的onlayoutChildren\n有动画的条件是： 有表项新增或移除、有更改的时候。默认是没有动画要处理，紧接着来到了dispatchLayout2，该方法主要是触发了layoutManager.onLayoutChildren。 调用链如下： linearlayoutmanager.fill-\u0026gt;layoutmanager.layoutChunk-\u0026gt;layoutstate.next-\u0026gt;recycler.getviewforposition-\u0026gt;recycler.tryGeyViewHolderForPostionByDeadline-\u0026gt;adapter.createViewHolder-\u0026gt;adapter.bindViewHolder到这里一个holder的创建于bind过程就结束了，紧接着在layoutchunk中触发layoutmanager.addView和layoutmanager.measureChildWithMargin，到这里表项才会被加入到recyclerview中，但是此时不会刷新recyclerview。 上面说到的layoutchunk会在一个while循环中多次执行，直到recyclerview的空间没有了才不会执行，而layoutchunk又会走recycler.next去从缓存中拿viewholder，而此时缓存中没有viewholder，因此会走createviewholder和bindviewholder，所以一开始create和bind次数是一屏能展示多少个表项的次数。 接着在dispatchlayout中会调用dispatchlayoutstep3，该方法里面主要是执行scrap缓存的释放，以及动画的执行\n到这里，测量和layout已经梳理完了，最后就剩draw了： draw里面基本没干什么，还是沿用了viewgroup的drawchild方法，绿色表示非系统方法，因此可以看出来recyclerview是重写了该方法： 总结： 初始化分为onmeasure阶段：如果recyclerview设置了固定宽高，则直接跳过测量，调用到mLayout中，如果不是固定宽高，则会走dispatchLayoutStep1，dispatchLayoutStep2。其中dispatchLayoutStep1是预布局处理，如果有动画要处理才会在该阶段调用到layout的onLayoutChildren。在dispatchLayoutStep2中处理表项的测量。 在onlayout阶段：会判断step还是不是start状态，如果是的话，则再次执行dispatchLayoutStep1和dispatchLayoutStep2。最后调用dispatchLayoutStep3用来做动画执行并释放相关资源。 在draw阶段基本什么都没做，dispatchDraw本身会调用到drawChild，recyclerview只是重写了该方法。\n滑动过程 滑动过程中会调用到scrollByInternal-\u0026gt;layoutmanager.scrollBy-\u0026gt;fill-\u0026gt;layoutchunck。 layoutchunck里面会从缓存中取数据，如果有则命中，没有则走create和bind，接着划出屏幕的表项会先加入到cache缓存中，如果cache缓存满了，则重置该表项，加入到recyclerpool中，下次所以取的时候从recyclerpool根据viewtype取需要重新bind，不需要create，所以在滑动过程中create的次数是cache的大小次数，等到recyclerpool中有缓存的时候就不需要create了。\n在fill过程中，会找到划出屏幕的表项，然后先调用recycleByLayoutState，接着调用到了Linearlayoutmanager.recycleChildren，接着会触发recyclerview.removeAndRecycleViewAt方法，接着就触发了adapter.onViewDetachedFromWindow(viewHolder)，接着就把viewholder缓存到cache和recyclerpool中，对应的方法是recycler.recycleView-\u0026gt;recycleViewHolderInternal,其中cache缓存中默认是2个，如果大于2的话，会把最前面的那个给放到recyclerpool中，接着再把新的viewholder放进来。\n在fiil过程中，会通过LayoutState.next从缓存中获取viewholder，获取的时候会先判断是不是preLayout状态，如果是则从changeScrap缓存中获取，从changeScrap中获取缓存先通过position获取，如果用position获取不到，则再用id去获取（必须adapter设置setHasStableIds为true，并且adapter重写了getItemId）。如果没获取到则从attacheScrap和cache中获取，如果从attach和cache中找不到，则继续通过id从attachScrap中获取，如果还没获取到则从viewcacheExtension中去获取，如果还获取不到则再从recyclerpool中去获取，如果还获取不到则通过create来创建viewholder，接着走bind逻辑。\n所以整个缓存获取顺序： changeScrap(preLayout状态，先通过position获取，没获取到再通过id获取)-\u0026gt;attacheScrap-\u0026gt;cache-\u0026gt;attachScrap(id方式获取)-\u0026gt;viewcacheExtension-\u0026gt;recyclerpool-\u0026gt;createholder-\u0026gt;bindholder 这就是layoutstate.next获取viewholder整个逻辑，上面哪些会触发createholder和bindholder 如果从几个缓存中都拿不到viewholder，则会走createholder的逻辑。\n什么情况下会调用onBindViewHolder？ 不是bound状态 bound标志位：是在bindViewHolder的时候设置的，因此不是bound表示没有bind过。没有bind过有：1，createholder；2，从recyclerpool取的viewholder。 needsUpdate：该状态表示什么？什么时候才会是needUpdate()呢？ 在viewRangeUpdate设置的。猜测是在viewholder发生变化的时候设置的，验证猜想： recyclerview.processAdapterUpdatesAndSetAnimationFlags-\u0026gt;AdapterHelper.preProcess-\u0026gt;applyUpdate-\u0026gt;postponeAndUpdateViewHolders -\u0026gt;markViewHoldersUpdated-\u0026gt;viewRangeUpdate，所以在dispatchLayout1过程中给flag设置了update状态\nisInvalid：表示什么状态？什么时候赋值的？ markKnownViewsInvalid会对所有页面上可见的viewholder设置为FLAG_INVALID，并且把cache缓存中的viewholder设置为FLAG_INVALID，它是在notifydataSetChange时候调用 在holder缓存获取的时候，如果发现holder的viewtype和adapter中重写的viewtype不一致会重置，会给viewholder添加该标志位 从缓存（attachScrap、cacheview）中获取viewholder的时候，如果发现type和holder的type不一致，则会校验不通过。或者设置了stableids为true的时候，如果adapter中的id和holder的id一致，则也通过。 所以结论就是，需要bound的条件：没有bound过（createholder的holder还没有bound过）；needupdate的，holder发生更新了。invalid，从attachscrap、cache获取后， 如果type不一致也需要重新bound，或者是调用了notifydataSetChange后，所有的viewholder都会添加nvalid标志位，此时也需要bind。\n更新表项 notifyItemChange(0)：更新表项第0的位置\n首先是进入页面创建了10个表项，然后更新后日志如下： 首先给我创建了索引为10的表项，也就是屏幕上不可见的，接着又创建了表项0，通过traceview分析： 整体看经历了rv的layout过程，分别对应了dispatchLayoutStep1、dispatchLayoutStep2、dispatchLayoutStep3。\ndispatchLayoutStep1 detachAndScrapAttachedViews 共经历了10次scrapOrRecycleView： 它是反向遍历页面上的view，然后添加到srap缓存中： 从scrapOrRecycleView的调用栈来看，是走了else部分，也就是往scrap缓存中加入viewholder。由于viewHolder的isInvalid为false，所以会走else。 scrap缓存分两种，attachScrap和changeScrap。不是update的会放到attachScrap中，所以我们更新第0个的时候会放到changeScrap中，在detach的时候由于是反向加入到scrap缓存中的，因此我们看第10个的trace调用： 从这里看第0个表项在detach的时候会加入到changeScrap中。 结论：在dispatchLayout1中，先将页面上可见的viewholder从页面上分离，然后将update的viewholder放入到changeScrap中，把非update的viewholder放入到attachScrap中。\nfill fill阶段发生了layoutChunk11次，而我们刚开始列表是初始化了10个表项，那么说明dispatchLayout1阶段添加了一个新的viewholder，关于这块我们可以给出结论，如果viewhodler被设置了remove或者update标记的时候，则会给列表添加一个新的viewholder。关于这块可以看：https://juejin.cn/post/6890288761783975950 在fill的while循环中会判断remainingSpace时候大于0，而每次layoutChunk过程中会将remainingSpace减小，而layoutChunkResult.mIgnoreConsumed就是判断是否要减小，意思是如果不忽略才会减小，那什么时候会忽略呢？ layoutChunk中判断viewholder如果是remove或者是change时候，才会忽略减小。所以我们会有11次的layoutChunk，而最后一次的layoutChunk会走createViewHolder，也就对应了上面的日志先添加了position=10的viewholder。从trace上看下： 结论： dispatchLayout1过程中，将第0个放入到changeScrap中，1-9放入到了attacheScrap中，并且创建了索引为10的viewhodler。\n注意： 在dispatchLayout1过程中，如果viewholder经过了addView之后，则会把它从changescrap或者是attachscrap缓存中移除，所以在dispatchlayout2过程中change和attach的缓存为空的。 其实在dispatchLayout2过程中添加viewholder的view时候也是要从scrap缓存中移除。\ndispatchLayoutStep2 detachAndScrapAttachedViews 由于在dispatchLayout1过程中创建了position=10的viewholder，因此会有11次，这11个里面第0个还是添加到了changeScrap中，1-10是添加到attachScrap中。\nfill 为什么此过程只有10次layoutChunck呢？这块其实还是回到remainingSpace的计算说起： 所以在dispatchLayout2过程中当添加到索引等于9的时候remainingSpace就为0了，所以索引等于10的时候添加不上，因此只会有10次layoutChunck。\nlayoutChunck 我们可以看到第0个走了createViewholder和bindViewholder： 是由于第0个viewholder被添加到了changeScrap缓存中，而1-9的viewholder添加到了attachScrap中，而changeScrap只会在pre-layout过程中才会生效： 所以可以看到上面日志中会走了position=0的createViewHolder和bindViewHolder。\n总结: 更新表项的时候，会经历dispatchLayout1，dispatchLayout2，其中在dispatchLayout1（pre-layout阶段）会先把可见的表项给回收到scrap缓存中，回收后，会把可见的表项从recyclerview中分离，其中需要变化的表项会加入到 changeScrap中（第1个表项），不变化的加入到attachScrap中（第2个到第10个表项）。接着在fill阶段会从scrap缓存中取表项，由于有表项更新，所以此时会去创建不可见的表项（第11个表项），最后会添加到recyclerview上。 在dispatchLayout2（post-layout阶段）同样会把dispatchLayout1添加进来的表项给添加到changeScrap（第1个表项）和attachScrap（第2个到第11个表项）缓存中，注意此时的表项会是11个表项。在fill阶段会去创建表项0， 因为post-layout阶段不会去取changeScrap中的viewholder，所以表项0会经历创建。\n删除表项 notifyItemRemove(0)\ndispatchLayout1 detachAndScrapAttachedViews 调用了10次scrapOrRecycleView 第0个调用scrapView添加到attachScrap缓存中 1-9的表项也是添加到attachScrap缓存中，这个可以从trace中看到。 fill 和update过程一样，在dispatchlayout1有11次layoutChunk，delete和update的viewholder不作为消费remainingSpace。 接着调用layoutstate.next获取viewholder，此时只有索引等于10的时候会去创建viewholder。注意了：此时创建完viewholder后，bind过程传的position=9： 在bind过程中会传入postion=10，而此时的mPostponedList中有一个op是remove类型的，所以postion会减一，因此它的postion是9： dispatchLayout2 detachAndScrapAttachedViews 此处scrapOrRecyclerview发生了11次，因为在dispatchLayout1创建了一个新的viewholder，11个viewholder都加入到了attachScrap缓存中。 fill layoutChunk调用了10次： 在第一个viewholder获取的时候获取到原来的第二个表项了，原来的第一个表项的position被置为-1了，所以我们0-9的表项都不会重新创建viewholder。也就对应上面的日志。 疑问： 此处的position赋值貌似都重新赋值了，因此我们看下是哪里重新赋值了： 当调用notifyItemRemove(0)的时候，在dispatchlayout1过程中会触发offsetPositionRecordsForRemove方法，该方法会通过remove的itemCount数重新给每一个页面上的viewhodler重新给赋上position的值，所以会看到上面的attachScrap缓存中最后一个viewholder的postion=-1了。 scrap缓存 在fill之前会把页面上的viewholder先detach掉，最终会调用到viewgroup的detachViewFromParent方法，removeView也会调用该方法，只不过viewholder的detach不会立马requestLayout。接着就是调用scrapView。 scrap缓存分两种，一种是attach、另外一种是change，如果viewholder是发生了变化（notifyItemChange），则会加入到change中，否则加入到attach中。接着在layoutChunk过程中，会从scrap缓存中找viewholder。 在dispatchLayout3过程中，会调用layout.removeAndRecycleScrapInt方法： 里面会调用recycler.clearScrap： 会清空scrap缓存。 总结：scrap缓存在每次layoutChild之前会先把页面的viewholder先放到scrap缓存中，在dispatchLayout3的时候，会把该缓存清空掉。\nAdapter.onViewAttachedToWindow 刚进入屏幕会触发onViewAttachedToWindow，从0-9都打印了。 从trace来看，初次每个viewholder都会经历onViewAttachedToWindow方法。\n下面看看什么时候不会调用onViewAttachedToWindow方法？ 每次在layoutChunk的时候，从缓存中去拿viewholder，如果从scrap缓存中拿到了，则不触发childHelper的addView，也就不会触发adapter.onViewAttachedToWindow；如果当前view的parent是当前recyclerview的时候，也不触发childhelper的addview。如果都不满足则触发adapter.onViewAttachedToWindow。\n滑动的时候是否触发？ 滑动过程中表项从不可见到可见会触发onViewAttachedToWindow，因为它不是从scrap缓存中获取到的，它是从cache缓存或者是recyclerpool中获取的。onViewAttachedToWindow触发不一定会触发oncreateViewHolder，也不一定会触发onBindViewholder。如果cache缓存和pool缓存中都没有该viewholder，则会触发oncreateViewHolder和onBindViewholder。如cache中有，则只触发onViewAttachedToWindow。如果从pool中拿到缓存，则会触发onBindViewholder和onViewAttachedToWindow。\n更新列表是否会触发？ 拿上面更新表项0来看，由于在dispatchLayout1(pre-layout)过程中会创建表项10，所以会经历表项10的oncreate和onbind，并且把它添加到rv中，所以会有一次的表项10的onViewAttachedToWindow，接着会在dispatchLayout2过程中会创建表项0（因为表项0存在了changeScrap缓存中），所以会走表项0的onViewAttachedToWindow。\nAdapter.onViewDetachedFromWindow 滑动过程中，划出屏幕的表项会调用onViewDetachedFromWindow。\nfindViewHolderForAdapterPosition和findViewHolderForLayoutPosition区别： 结论：正常情况下adapterPostion和layoutPosition是相等的，当有add、remove、move的时候两者是不一样的。adapterPostion会算上要改变的表项，比如上面我要删除第一个表项，那么拿到的表项就是第二个。而layoutPostion是页面最终呈现的表项，上面例子中等到post完后，才会真正的删除掉。所以post（绘制后）后layoutposition获取到的是原来的第二个表项。\nnotifydatasetChange问题 先是把页面上所有的都detach掉，然后又走了所有的viewholder的onbind过程，从索引为5的viewholder走了oncreateviewholder。下面看下trace： layout过程只走了dispatchLayout2，在里面走到了linearlayoutManager.onLayoutChildren，里面会触发fill。在fill之前会走detach逻辑，里面会反向遍历可见的子view，并调用scrapOrRecylerview： 每一个子view回收都走了removeViewAt: 此处由于所有的viewholder都是invalid状态了，因为在notifyDatasetChange在调用requestLayout之前把页面上的子view都设置成invalid状态了： 所以在fill之前都会调用removeViewAt，而该方法会触发onViewDetachedFromWindow，因此可以看到前面日志中先反向打印了9-\u0026gt;0的onViewDetachedFromWindow。接着会调用recycler.recycleViewHolderInternal，该方法是把viewholder加入到cache或者是recyclerpool中： 如果存在invalid状态，则会把viewholder加入到pool缓存中，trace验证下： 而pool缓存是5个，因此先把9-\u0026gt;5存到poo中时，发现pool满了，则把9给移除掉，因此最后只剩下5个viewholder在pool中。接着在layoutChunk阶段，会从缓存中拿viewholder的时候，只有pool中5个viewhold的缓存，取完一个remove掉一个，当索引为5的时候，pool中已经拿完了，因此5-9会去创建viewholder。\n参考：\nRecyclerView 缓存机制 | 如何复用表项？ RecyclerView 缓存机制 | 回收些什么？ RecyclerView 缓存机制 | 回收到哪去？ RecyclerView缓存机制 | scrap view 的生命周期 ","date":"2025-01-02T00:00:00Z","permalink":"https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/","title":"RecyclerView源码走读"},{"content":"suspendCoroutine 在android中无处不在获取view的宽高，而获取宽高是需要在view绘制完后才能获取，所以这是一个时机问题，通常通过view.post来获取，那么用协程如何形如同步获取宽高呢？下面来试试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 GlobalScope.launch { val wh = getViewWh(view) Log.d(TAG, \u0026#34;width:${wh.first}\u0026#34;) Log.d(TAG, \u0026#34;height:${wh.second}\u0026#34;) } Log.d(TAG, \u0026#34;outer coroutine\u0026#34;) private suspend fun getViewWh(view: View) = suspendCoroutine\u0026lt;Pair\u0026lt;Int, Int\u0026gt;\u0026gt; { continuation -\u0026gt; view.post { val width = view.width val height = view.height continuation.resume(Pair(width, height)) } } 日志如下：\n1 2 3 11:00:57.708 D outer coroutine 11:00:57.810 D width:1080 11:00:57.810 D height:2206 使用了suspendCoroutine方法，方法的返回值，是suspendCoroutine指定的泛型。 可以看到日志正常获取，下面来看看字节码是如何实现的： launch启动的时候，内部的协程代码块编译结果是SuspendCoroutineActivity$onCreate$1： 调用了SuspendCoroutineActivity的静态方法access$getViewWh：\n静态方法是直接调用了成员方法getViewWh，它是本次的重要实现：\n传进来的Continuation对应了SuspendCoroutineActivity$onCreate$1，它是传给了SafeContinuation，此处注意到调用了continuation的intercepted方法，它是continuation的扩展方法，它是在continuationImpl中实现了，它实际是看context中是否有dispatcher，这块在协程切换线程中讲过，它实际是生成了一个CoroutineDispatcher。\n接着看又调用了SuspendCoroutineActivity$getViewWh$2$1这个suspendLambda，并把SafeContinuation传进去了： 此处的Runnable就对应了post中的代码块，最终在run方法中调用了continuation的resumeWith方法，并把宽高回调出去了。此处的continuation是SafeContinuation，看下它的resumeWith方法： 此处的result默认值是UNDECIDED： 由于默认值是UNDECIDED，在上面getViewWh中先调用了safeContinuation的getOrThrow方法： 所以会给result设置上了COROUTINE_SUSPENDED标记，所以在第一个suspendLambda的invokeSuspend方法中能被挂起，等到执行safeContinuation的resumeWith的时候，第一个suspendLambda就恢复了。最终获取到结果，整个流程就结束。\nsuspendCoroutine的回调中还有一个resumeWithException方法，用于返回失败的结果，如果返回失败的时候，需要捕捉异常。\nsuspendCancellableCoroutine 它和suspendCoroutine区别是回调中是一个CancellableContinuationImpl，它提供了cancel方法，当cancel的时候，程序不会崩溃。它会把cancel的结果分发到delegate中，此处的delegate其实就是对应了GlobalScope.launch启动时的suspendLambda，最后它会分发到父job中。看下CancellableContinuationImpl的cancel方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public override fun cancel(cause: Throwable?): Boolean { _state.loop { state -\u0026gt; if (state !is NotCompleted) return false // false if already complete or cancelling // Active -- update to final state val update = CancelledContinuation(this, cause, handled = state is CancelHandler || state is Segment\u0026lt;*\u0026gt;) if (!_state.compareAndSet(state, update)) return@loop // retry on cas failure // Invoke cancel handler if it was present when (state) { is CancelHandler -\u0026gt; callCancelHandler(state, cause) is Segment\u0026lt;*\u0026gt; -\u0026gt; callSegmentOnCancellation(state, cause) } // Complete state update detachChildIfNonResuable() dispatchResume(resumeMode) // no need for additional cancellation checks return true } } 此处会构造出CancelledContinuation，它是CompletedExceptionally对象，这个其实就是协程异常的扩展类，最终把该对象设置到CancellableContinuationImpl的state上。 一路跟到DispatchedTask的dispatch方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 internal fun \u0026lt;T\u0026gt; DispatchedTask\u0026lt;T\u0026gt;.dispatch(mode: Int) { assert { mode != MODE_UNINITIALIZED } // invalid mode value for this method val delegate = this.delegate val undispatched = mode == MODE_UNDISPATCHED if (!undispatched \u0026amp;\u0026amp; delegate is DispatchedContinuation\u0026lt;*\u0026gt; \u0026amp;\u0026amp; mode.isCancellableMode == resumeMode.isCancellableMode) { // dispatch directly using this instance\u0026#39;s Runnable implementation val dispatcher = delegate.dispatcher val context = delegate.context if (dispatcher.isDispatchNeeded(context)) { dispatcher.dispatch(context, this) } else { resumeUnconfined() } } else { // delegate is coming from 3rd-party interceptor implementation (and does not support cancellation) // or undispatched mode was requested resume(delegate, undispatched) } } 此处会走dispatcher.dispatch逻辑，因为上面的GlobalScope.launch其实创建的dispatcher是一个Dispatcher.Default类型的。DispatchedTask是一个runnable接口，看下它的run方法： 最终也是通过continuation的resumeWithException方法回调出去，然后交给了父job去处理，此时的exception是一个CancellationException，其实上面的suspendCoroutine也可以通过resumeWithException回调一个CancellationException，程序也不会崩溃。\n参考：https://juejin.cn/post/7121517604644061192\n","date":"2024-12-30T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/","title":"协程如何优雅的处理异步回调"},{"content":"案例一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private fun demo1() { val handler = CoroutineExceptionHandler { coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;onCreate: CoroutineExceptionHandler:${throwable.message}\u0026#34;) } GlobalScope.launch(handler) { Log.d(TAG, \u0026#34;onCreate: parentJob start\u0026#34;) withContext(Dispatchers.IO) { throw RuntimeException(\u0026#34;runtime exception\u0026#34;) delay(1000) Log.d(TAG, \u0026#34;onCreate: withContext end\u0026#34;) } Log.d(TAG, \u0026#34;onCreate: parentJob end\u0026#34;) } } 先上日志：\n1 2 com.example.coroutinescopedemo D onCreate: parentJob start com.example.coroutinescopedemo D onCreate: CoroutineExceptionHandler:withContext runtime exception 异常能被launch指定的handler所捕捉。 分析： launch启动的协程用到的coroutineScope是一个StandaloneCoroutine，withContext启动的协程对应的coroutineScope是一个DispatchedCoroutine。 在withContext中发生异常的时候，首先会回调到DispatchedCoroutine的resumeWith，最终会走到finalizeFinishingState方法，该方法里面会判断是否存在异常，如果有异常会调用cancelParent方法：\n可以看到如果isScopedCoroutine为true的时候，cancelParent直接返回true，如果返回true，那么就不触发自己的上面的handleJobException，也就是把异常继续往上抛了。例子中也就是launch对应的StandaloneCoroutine。而在StandaloneCoroutine中不会去cancelParent，所以会把异常交给了handleJobException了，所以上面的launch中传入的CoroutineExceptionHandler能捕获到该异常。\n总结：如果子job中在处理异常的时候，cancelParent中如果isScopedCoroutine为true的时候，则不触发自己的handleJobException，也就是把异常交给了父job，如果父job不处理该异常，则会程序崩溃。\n案例二 上面代码如果把withContext中的异常通过try-catch住，父job就收不到该异常了： 子携程把异常catch住后，父协程的handler捕捉不到异常，并且父协程的invokeOnCompletion收不到异常，并且父协程之后的代码也能正常执行。\n案例三 子协程给context传递coroutineExceptionHandler： 子协程抛了异常，然后子协程也传了CoroutineExceptionHandler，但是子协程的CoroutineExceptionHandler不起作用，还是把异常传给了父协程。并且父协程的invokeOnCompletion收到了异常回调，而且发现父协程的invokeSuspend方法也没走完，所以onCreate: parentJob end没有输出。\n分析：前面已经分析过withContext开启的协程对应的coroutineScope是一个DispatchedCoroutine重写了isScopedCoroutine=true，如果它为true，cancelParent方法则返回true，那么它自己的handleJobException就不会触发，所以就不会走到自己的CoroutineExceptionHandler回调了。\n案例四 当子协程抛的是CancellationException，父协程捕捉不到该异常： 此处handler没有捕捉到异常，并且程序也没崩溃，这是因为在子协程把异常回调给父协程后，父协程对应的scope，也就是StandaloneCoroutine在cancelParent中判断是CancelationException，它直接返回true，所以不会调用handleJobException方法，而向外抛异常的正是该方法。所以当子协程抛出CancellationException时候不会使父协程崩溃。\n案例五 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 private fun demo2() { val handler = CoroutineExceptionHandler { coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;handler:${throwable.message}\u0026#34;) } val job = Job() val coroutineScope = CoroutineScope(job + handler) val job1 = coroutineScope.launch { delay(100) Log.d(TAG, \u0026#34;job1 end\u0026#34;) throw RuntimeException(\u0026#34;runtime exception\u0026#34;) } job1.invokeOnCompletion { Log.d(TAG, \u0026#34;job1 invokeOnCompletion:${it?.message}\u0026#34;) } val job2 = coroutineScope.launch { delay(200) Log.d(TAG, \u0026#34;job2 end\u0026#34;) } job2.invokeOnCompletion { Log.d(TAG, \u0026#34;job2 invokeOnCompletion:${it?.message}\u0026#34;) } val job3 = coroutineScope.launch { delay(300) Log.d(TAG, \u0026#34;job3 end\u0026#34;) } job3.invokeOnCompletion { Log.d(TAG, \u0026#34;job3 invokeOnCompletion:${it?.javaClass?.simpleName}\u0026#34;) Log.d(TAG, \u0026#34;job3 invokeOnCompletion:${it?.message}\u0026#34;) } } 日志如下：\n1 2 3 4 5 6 com.example.coroutinescopedemo D job1 end com.example.coroutinescopedemo D handler:runtime exception com.example.coroutinescopedemo D job2 invokeOnCompletion:Parent job is Cancelling com.example.coroutinescopedemo D job1 invokeOnCompletion:runtime exception com.example.coroutinescopedemo D job3 invokeOnCompletion:JobCancellationException com.example.coroutinescopedemo D job3 invokeOnCompletion:Parent job is Cancelling 数据结构:父协程的job启动了三个子协程，在job1中抛出异常，job2和job3收到了JobCancellationException。其中父job是一个JobImpl对象，在每个子协程启动过程中都会创建一个ChildHandleNode对象，其中job指向了父Job，也就是JobImpl，childJob指向了当前子job，也就是StandaloneCoroutine，最后在子Job中通过parentHandle指向了父job，state指向了InvokeOnCompletion(是通过invokeOnCompletion添加的)。父job中通过state指向了一个NodeList，每一个next节点指向了三个子job。\n异常处理:当第一个job发生异常后，会通知自己的state中的InvokeOnComplete接口，所以job1中收到了runtime exception的信息，它是原始的失败信息。接着会调用到job1的cancelParent逻辑，该方法中会调用到parentHandle的childCancelled逻辑，它是一个ChildHandleNode对象，在它的childCancelled方法中，会触发父job的childCancelled方法，最终会来到父job的cancelImpl方法。该方法里面会去取消子job，是通过遍历state节点，调用里面的每一个ChildHandleNode的invoke方法，在invoke里面会调用到childJob的parentCancelled方法，里面会给每一个job的state设置上JobCancellationException，当让第一个job由于已经有exception了，也就是原始exception，所以job2和job3会设置上JobCancellationException异常。接着子协程会递归调用notifyHandlers通知子协程发生异常了，直到没有子协程为止。 当所有的子协程处理完异常后，会调用到自己的CoroutineExceptionHandler的回调。当回调完后，会给自己的state添加异常，防止在resumeWith中往下执行逻辑。其中给state添加异常是通过Finishing.addExceptionLocked添加异常信息。\n子协程invokeOnCompletion接口回调执行时机？ 在异常处理阶段，父协程会调用到ChildHandleNode中的invoke方法，继而会触发childJob的parentCancelled方法，最终会在notifyHandlers中触发invokeOnCompletion的回调？\n子协程的job为什么在添加完异常后resumeWith不会被执行？ 在协程job中在执行resumeWith的时候，调用到tryMakeCompleting时，会判断state，如果不是Incomplete状态，则直接返回，不会往下执行。\n父协程在cancelImpl的时候除了取消子协程还做了什么？ 在取消完子协程的时候，给第一个child添加了ChildCompletion回调，该回调执行的时候会执行到continueCompleting，最终会回到自己处理异常的逻辑。\n案例六 把案例五中的Job()换成SupervisorJob()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 private fun demo3() { val handler = CoroutineExceptionHandler { coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;handler:${throwable.message}\u0026#34;) } val coroutineScope = CoroutineScope(SupervisorJob() + handler) val job1 = coroutineScope.launch { delay(100) Log.d(TAG, \u0026#34;job1 end\u0026#34;) throw RuntimeException(\u0026#34;runtime exception\u0026#34;) } job1.invokeOnCompletion { Log.d(TAG, \u0026#34;job1 invokeOnCompletion:${it?.message}\u0026#34;) } val job2 = coroutineScope.launch { delay(200) Log.d(TAG, \u0026#34;job2 end\u0026#34;) } job2.invokeOnCompletion { Log.d(TAG, \u0026#34;job2 invokeOnCompletion:${it?.message}\u0026#34;) } val job3 = coroutineScope.launch { delay(300) Log.d(TAG, \u0026#34;job3 end\u0026#34;) } job3.invokeOnCompletion { Log.d(TAG, \u0026#34;job3 invokeOnCompletion:${it?.javaClass?.simpleName}\u0026#34;) Log.d(TAG, \u0026#34;job3 invokeOnCompletion:${it?.message}\u0026#34;) } } 只是换了个job，job1还是一样收到了原始异常，job2和job3正常执行，并能执行完。按照上面分析，当job1发生异常的时候，会调用到cancelParent，它会分发到父job的childCancelled方法，而SupervisorJob重写了该方法直接返回false。所以异常不会分发到子协程中，当job1的cancelParent返回false的时候，会执行到handleJobException，而job1使用的context中的CoroutineExceptionHandler是使用的父job中指定的CoroutineExceptionHandler。因为context是plus叠加的方式。所以最后handler中收到了异常。\n以下的案例来自于https://juejin.cn/post/7049537608262615070\n案例七 结果：try-catch竟然捕获不住，程序直接抛异常了\n此处try-catch的位置不在子协程的SuspendInvoke位置，它是在主协程的launch位置，其实它是在invokeSuspend中调用内部launch的时候加了try-catch，对应的class代码如下：\n从字节码来看，只是启动子协程的时候给try-catch，从原理上分析，当子协程发生异常后，会调用父协程的cancelChild，在父job里面会调用到cancelParent，而父job(shi 也就是JobImpl)，它的parentHandle是空，所以cancelParent的方法返回false，因此会调用到handleJobException，而父job没有传handler，因此程序会崩溃。 上面的案例，其实可以理解为launch启动的协程中再启动一个lanuch协程，然后try-catch捕捉位置在外层lauch上，此时是捕捉不到异常的\n案例八 结果：此处不会发生异常，异常被exceptionHandler捕捉 因此当父job接收到异常后，会将异常传递到handleJobException方法中，而父job是有handler的，所以将异常回调到了handler中，程序不会崩溃。\n案例九 结果：程序崩溃了，不会被子协程的handler捕捉到异常\n因为当子协程异常的时候，会把异常抛给了父job，而父job又没有处理该异常，所以程序崩溃了\n案例十 结果：程序不会崩溃，异常被try catch捕获住，而不是被exceptionHandler捕获住。\n前面分析过当子协程发生异常后，会把异常分发给到父job，在父job中需要等子job都处理完异常了，才会往下走，该处逻辑主要体现在子job中添加了一个ChildCompletion节点到state中，在invoke中会执行到parent.continueCompletion方法： 此处的parent实际是coroutineScope启动的协程对应的job，它是ScopeCoroutine，看下它的continueCompleting实现： 最终会把结果回调给到了传递进来的continuation，也就是最外层launch启动的时候的SuspendLambda，最终会调用它的invokeSuspend方法： 所以最终被try-catch捕捉到异常。\n案例十一 结果：程序被内层launch指定的exceptionHandler捕捉了 supervisorScope用到的job是SupervisorCoroutine，它重写了childCancel方法，并返回false，所以当子job发生异常的时候，不会抛给父job，并执行自己的handleJobException方法，所以被自己的handler捕获到。\n案例十二 此时被外层launch的handler所捕捉，原因是异常抛给了父job。\n案例十三 此时被内层launch的handler所捕捉，原因是supervisorScope启动的协程不会往上抛，交给了子协程自己处理。\n","date":"2024-12-17T00:00:00Z","image":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AD%90%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/cover_hu17536845123992820283.jpg","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AD%90%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"协程中子协程异常处理"},{"content":"invokeOnCompletion监听协程状态 在了解协程的异常处理之前，先来熟悉下协程之间job是如何绑定关系，还是通过一个例子来熟悉他们之间的关系：\n1 2 3 4 5 6 7 8 private fun demo(){ val job = GlobalScope.launch { Log.d(TAG, \u0026#34;demo: launch代码\u0026#34;) } job.invokeOnCompletion { Log.d(TAG, \u0026#34;demo: invokeOnCompletion\u0026#34;) } } 执行结果：\n1 2 CoroutineJobActivity com.example.coroutinescopedemo D demo: launch代码 CoroutineJobActivity com.example.coroutinescopedemo D demo: invokeOnCompletion 可以看出来invokeOnCompletion是job执行完毕的回调。\n通过launch创建协程内部会构造一个StandaloneCoroutine，它就是一个job，并且launch返回的就是该job： StandaloneCoroutine继承自AbstractCoroutine： 因此parentHandle为NonDisposableHandle，然后方法结束。 此时执行完launch后，继续执行了job的invokeOnCompletion方法，它是一个抽象方法，实现方法在jobSupport类： 我们看下makeNode方法实现： 从调用链上看onCancelling传进来的是false，并且此时的handler还不是一个JobNode节点，所以会创建了一个InvokeOnCompletion对象，并把外面传进来的ComppletionHandler传到InvokeOnCompletion中，看下InvokeOnCompletion对象：\n1 2 3 4 5 private class InvokeOnCompletion( private val handler: CompletionHandler ) : JobNode() { override fun invoke(cause: Throwable?) = handler.invoke(cause) } InvokeOnCompletion是一个JobNode节点：\n1 2 3 4 5 6 7 8 9 10 internal abstract class JobNode : CompletionHandlerBase(), DisposableHandle, Incomplete { /** * Initialized by [JobSupport.makeNode]. */ lateinit var job: JobSupport override val isActive: Boolean get() = true override val list: NodeList? get() = null override fun dispose() = job.removeNode(this) override fun toString() = \u0026#34;$classSimpleName@$hexAddress[job@${job.hexAddress}]\u0026#34; } JobNode实现了CompletionHandlerBase抽象类：\n1 2 3 internal actual abstract class CompletionHandlerBase actual constructor() : LockFreeLinkedListNode(), CompletionHandler { actual abstract override fun invoke(cause: Throwable?) } 它也是实现了CompletionHandler接口，CompletionHandler是一个闭包，从上面继承以及JobNode实现来看，在它的invoke实现里面，会触发传进来的CompletionHandler的invoke实现，从实现来看其实这就是个静态代理的模式。\n结论： makeNode内部会返回一个InvokeOnCompletion对象，它是一个JobNode节点。\n回到上面的invokeOnComletion的实现，创建了InvokeOnCompletion后，会走到loopOnState的函数，它是遍历state，它的初始状态是一个Empty状态，并且state.isActive=true。所以最终把刚才创建的InvokeOnCompletion设置到了state上，并且返回了该InvokeOnCompletion。\n结论： 当调用了job的invokeOnCompletion方法后，会把外界创建好的CompletionHandler传给了InvokeCompletion，InvokeCompletion是一个JobNode，在它的invoke实现中，会回调到外界的CompletionHandler中。并且把创建的InvokeCompletion设置到当前job的state上了。\n协程体执行完job的执行： 在之前分析协程体其实是一个SuspendLambda，在它的invokeSuspend调用完后，会执行它的continuation的resumeWith方法，在上面例子中其实是StandaloneCoroutine，它是一个job，所以看下它的resumeWith实现：\n1 2 3 4 5 public final override fun resumeWith(result: Result\u0026lt;T\u0026gt;) { val state = makeCompletingOnce(result.toState()) if (state === COMPLETING_WAITING_CHILDREN) return afterResume(state) } 将协程体的结果传到了makeCompletingOnce方法中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 internal fun makeCompletingOnce(proposedUpdate: Any?): Any? { loopOnState { state -\u0026gt; val finalState = tryMakeCompleting(state, proposedUpdate) when { finalState === COMPLETING_ALREADY -\u0026gt; throw IllegalStateException( \u0026#34;Job $this is already complete or completing, \u0026#34; + \u0026#34;but is being completed with $proposedUpdate\u0026#34;, proposedUpdate.exceptionOrNull ) finalState === COMPLETING_RETRY -\u0026gt; return@loopOnState else -\u0026gt; return finalState // COMPLETING_WAITING_CHILDREN or final state } } } 轮训获取state，并调用了tryMakeCompleting方法： 从上面的分析知道state它是一个JobNode，它是一个InvokeCompletion，它不是一个ChildHandleNode，并且proposedUpdate不是CompletedExceptionally，所以会执行tryFinalizeSimpleState： 内部调用了completeStateFinalization方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private fun completeStateFinalization(state: Incomplete, update: Any?) { /* * Now the job in THE FINAL state. We need to properly handle the resulting state. * Order of various invocations here is important. * * 1) Unregister from parent job. */ parentHandle?.let { it.dispose() // volatile read parentHandle _after_ state was updated parentHandle = NonDisposableHandle // release it just in case, to aid GC } val cause = (update as? CompletedExceptionally)?.cause /* * 2) Invoke completion handlers: .join(), callbacks etc. * It\u0026#39;s important to invoke them only AFTER exception handling and everything else, see #208 */ if (state is JobNode) { // SINGLE/SINGLE+ state -- one completion handler (common case) try { state.invoke(cause) } catch (ex: Throwable) { handleOnCompletionException(CompletionHandlerException(\u0026#34;Exception in completion handler $state for $this\u0026#34;, ex)) } } else { state.list?.notifyCompletion(cause) } } 该方法中判断state是否是JobNode，如果是的话，会调用invoke方法。在上面分析过state是一个InvokeOnCompletion对象，在它的invoke里面会回调到传进来的CompletionHandler的invoke中，所以在上面例子中打印了job执行完成的日志。\ninvokeOnCompletion监听job的异常 还是通过一个例子来分析下：\n1 2 3 4 5 6 7 8 9 10 11 12 private fun demo3(){ val exceptionHandler =CoroutineExceptionHandler{ coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;demo3: CoroutineExceptionHandler--异常信息：${throwable?.message}\u0026#34;) } val job = GlobalScope.launch(exceptionHandler) { Log.d(TAG, \u0026#34;demo3: launch代码\u0026#34;) throw RuntimeException(\u0026#34;协程体里面发生异常了\u0026#34;) } job.invokeOnCompletion { Log.d(TAG, \u0026#34;demo3: invokeOnCompletion--异常信息：${it?.message}\u0026#34;) } } 此处用了一个CoroutineExceptionHandler方法，来创建CoroutineExceptionHandler对象来拦截异常的，这块先不用管，我们看下日志：\n1 2 3 com.example.coroutinescopedemo D demo3: launch代码 com.example.coroutinescopedemo D demo3: CoroutineExceptionHandler--异常信息：协程体里面发生异常了 com.example.coroutinescopedemo D demo3: invokeOnCompletion--异常信息：协程体里面发生异常了 可以看出来，invokeOnCompletion中也能收到异常的消息。 但是异常和正常收数据可能不太一样，主要区别是在resumeWith之后的处理不太一样： 如果是非异常的话，会走tryFinalizeSimpleState；如果是异常的时候会走tryMakeCompletingSlowPath，在该方法里面会触发finalizeFinishingState方法，该方法有个很重要逻辑： 由于cancelParent返回false，所以会触发handleJobException，StandaloneCoroutine重写了该方法： handleCoroutineException： 如果context中CoroutineExceptionHandler不为空，则异常不会往上抛了，所以此例中定义了context的CoroutineExceptionHandler程序不会崩溃。 回到上面再来看invokeOnCompletion的CompletionHandler触发时机，它是在finalizeFinishingState中触发，接着会调用到completeStateFinalization，最终在里面触发了invokeOnCompletion传进来的CompletionHandler。\n协程异常try住：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private fun demo4() { val exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable -\u0026gt; Log.d(TAG, \u0026#34;demo4: CoroutineExceptionHandler--异常信息：${throwable?.message}\u0026#34;) } val job = GlobalScope.launch(exceptionHandler) { try { Log.d(TAG, \u0026#34;demo4: launch代码\u0026#34;) throw RuntimeException(\u0026#34;协程体里面发生异常了\u0026#34;) } catch (e: Exception) { Log.d(TAG, \u0026#34;demo4: catch中代码\u0026#34;) } } job.invokeOnCompletion { Log.d(TAG, \u0026#34;demo4: invokeOnCompletion--异常信息：${it?.message}\u0026#34;) } } 日志如下：\n1 2 3 com.example.coroutinescopedemo D demo4: launch代码 com.example.coroutinescopedemo D demo4: catch中代码 com.example.coroutinescopedemo D demo4: invokeOnCompletion--异常信息：null 从日志中看，此处的CoroutineExceptionHandler不回调，并且invokeOnCompletion收不到异常信息。 我们通过字节码可以看到原因： 此处的异常catch住后，给到JobSupport就不是异常了，所以按照成功的处理方式一样。\n","date":"2024-12-16T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"协程的异常处理"},{"content":"首先看一个例子： 日志如下： 字节码如下： launch部分启动的协程的invokeSuspend逻辑里面，只有label0的逻辑，和withContext不同的是会有挂起部分的判断，所以是同步执行的。\nasync的异步执行： 日志如下： 可以看到async2是先执行的，因为它没有进行delay，等到两个async执行完了后，才会执行launch里面的代码。 字节码如下： 编译后的代码： label=0的时候，通过async启动了两个协程，我们这里叫async1和async2，并且在里面通过await挂起了launch启动的协程。 分析：async1调用await后，由于状态是COROUTINE_SUSPENDED，所以第一次invokeSuspend方法结束，此时label=1。等到await逻辑执行完后，又会第二次执行invokeSuspend方法，此时由于lable=1，会执行async2的await方法，此时返回COROUTINE_SUSPENDED，所以invokeSuspend第二次结束，此时label=2。等到async2的await执行完后，第三次执行invokeSuspend方法，由于此时label=2，所以此时切回到自己的线程，执行launch部分的代码逻辑。\n","date":"2024-11-28T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/","title":"协程的同步执行原理"},{"content":"先来一个例子： 日志如下： 可以看到上面先是执行了withContext中的代码，然后执行了launch中的代码，注意到launch中也是在单独线程中执行的，其中launch中使用的Dispatcher是Dispatchers.Default类型的。前面分析过launch调度情况，最后会执行到continuation的resumeWith，然后调用它的invokeSuspend方法： 可以看到先执行withContext，因为withContext启动的时候，默认的状态是COROUTINE_SUSPENDED，所以退出了，返回了var2，此时的label=1了。当执行完withContext的时候，会通知传给withContext的continuation，也就是上面的CoroutineDispatchersActivity$demo2$1这个SuspendLambda。所以会再次执行它的invokeSuspend方法，此时lable=1，所以最后返回了Unit.INSTANCE，整个invokeSuspend结束，这就是挂起的原因。 至于为什么在CoroutineDispatchersActivity$demo2$1中遇到了返回值为COROUTINE_SUSPENDED时候，不会继续执行了呢？看下BaseContinuationImpl中的resumeWith逻辑： 在BaseContinuationImpl中的resumeWith中，如果invokeSuspend返回值是COROUTINE_SUSPENDED，则直接return了，不往上层的continuation调用了。\n至于再次执行CoroutineDispatchersActivity$demo2$1的invokeSuspend方法是在什么时候，可以追溯到withContext中： 执行了block的startCoroutineCancellable： 此处很熟悉啊，这不又启动了一个协程吗？协程套协程啊。好吧，我们直接看completion的回调，在协程挂起函数执行完后，会执行complete的resumeWith方法，此处是DispatchedCoroutine对象，继承自ScopeCoroutine： 它是先取continuation中context的ContinuationInterceptor，也就是上面launch启动的dispatchers，对应的是Dispatchers.Default，最终执行Dispatchers的resumeCancellableWith方法，在该方法里面最终会在协程指定的线程中执行协程代码块。所以在上面日志中能看到withContext执行完后，launch之后的代码能回到指定的线程中执行。\nwithcontext执行完了后会执行外面协程的resumeWith，所以launch的invokeSuspend再次执行。再次执行的时候会回到自己的线程。真相大白了！\n","date":"2024-11-15T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E6%8C%82%E8%B5%B7%E5%8E%9F%E7%90%86/","title":"协程挂起原理"},{"content":"在上一节介绍过Dispatchers.IO，它是一个CoroutineDispatcher对象，CoroutineDispatcher的执行是在DispatchedContinuation中的resumeCancellableWith方法，如果CoroutineDispatcher的isDispatchNeeded返回true，则会执行CoroutineDispatcher的dispatch方法。否则直接执行该runnable。\nDispatchers.Main 在安卓平台下，它其实是一个HandlerContext对象： 看下它的isDispatchNeeded和dispatch方法： 此时invokeImmediately默认是false，因此isDispatchNeeded返回true。所以会执行它的dispatch方法。在dispatch方法中将runnable给到了主线程的消息队列中，然后等主线程从消息队列中取该runnable。所以在上一节例子中它是晚于onCreate方法执行的。\nDispatchers.Main.immediate 它是HandlerContext中的immediate变量: 可以看到它是新创建了一个HandlerContext，并且invokeImmediately是true。在上一节的例子中，它的isDispatchNeeded返回false。所以它是直接执行SuspendLambda的resumeWith方法，因此上一节例子中它是要早于Dispatchs.Main执行的。\nDispatchers.IO 看下它的CoroutineDispatcher，对应的子类是DefaultIoScheduler，CoroutineDispatcher的isDispatchNeeded方法默认返回true，所以会执行它的dispatch方法： 在dispatch方法中调用了default的dispatch方法，default实际是一个LimitedDispatcher方法，看下它的dispatch方法： 在上面2处，判断当前runningWokers的数量，如果大于parallelism的时候，则不创建Worker，此处的parallelism的大小是64。从此处也能看出来Dispatchers.IO的线程数量不会超过64个。 最终该方法里面会通过DefaultScheduler.dispatchWithContext来创建CoroutineScheduler，来看下创建线程池的几个参数： 核心线程数： 最小2个，最大是cpu的核数 最大线程数： 最大线程数取值(1 shl BLOCKING_SHIFT) - 2：最终得到的值是2^21-2 = 2097150。 非核心线程空闲时间是60s。\n结论：Dispatchers.IO创建的最大的线程个数为:Math.max(64,cpu核数)\nDispatchers.Default 它是由DefaultScheduler构建的线程池，它所创建的最大的线程个数为:Math.max(2,cpu核数)\nDispatchers.IO和Dispatchers.Default都是由DefaultScheduler构建的，而DefaultScheduler其实是一个单例，因此不难看出它两是共用一个线程池的，只不过当Dispatchers.IO时候，最大线程个数控制在Math.min(64,cpu核数)，最多不会超过64个，Dispatchers.Default控制在cpu核数个数上。Dispatchers.Default常用作cpu密集型的任务，比如图片模糊处理、繁杂的计算型可以用这种类型的线程池。Dispatchers.IO由于它的线程数量多，并且它不能消耗cpu资源，因此常用作io处理，文件读写等操作上。 关于这点，可以看这篇文章：dispatcher拆解\n","date":"2024-11-13T00:00:00Z","image":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/cover_hu17536845123992820283.jpg","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/","title":"协程中的线程"},{"content":"在讲解如何切换线程之前，有必要先了解下CoroutineScope。协程作用域，它里面持有CoroutineContext，用来管理它的作用域范围内的所有协程。\nCoroutineScope(协程作用域) CoroutineScope组成 可见它只是一个接口，里面定义了一个coroutineContext。前面介绍过coroutineContext是协程的上下文，它里面是由Element拼接而成的，而Element主要分为如下几种：\nCoroutineDispatcher：它是线程分发器。其中Dispatcher.IO和Dispatcher.Main、Dispatchers.Main.immediate都是继承自于它 Job：它是用来取消协程、父协程与子协程取得联系的桥梁。常见的有SupervisorJob CoroutineName：用来给协程起名字的作用 CoroutineExceptionHandler：它是用来捕捉协程异常的回调器 所以完整的CoroutineContext组成部分如下： job+dispatchers+CoroutineName+CoroutineExceptionHandler\nCoroutineScope分类 目前kotlin已经内置了各种CoroutineScope，下面来说下他们的区别\nGlobalScope 上面用到的GlobalScope就是一个协程作用域： 可以看出来它是一个单例的scope，生命周期和app保持一致，并且它的context是一个EmptyCoroutineContext。平时开发时候不会去用它\nrunBlocking 是一个阻塞式的协程作用域，会阻塞协程外面的线程，内部是通过java的LockSupport.park阻塞住线程来实现的。 MainScope 它是一个指定协程分发在主线程中，并且使用到的Job是SupervisorJob，它的作用是当子协程出错的时候，不影响到父协程中的其他子协程 它是一个ContextScope，继承自CoroutineScope，并且它的context是由SupervisorJob()和Dispatchers.Main组成的一个context。我们一般自定义CoroutineScope的时候也是定义一个ContextScope，他的构造方法需要传入一个CoroutineContext。 CoroutineScope顶级方法 它也是一个ContextScope，它的上下文先看传进来的context中的job是否为空，如果为空，则初始化一个job。如果不为空，则使用传进来的context。\ncoroutineScope顶级方法 它是一个suspend方法，它是通过闭包的形式返回一个CoroutineScope，对应的字节码如下： 会将ScopeCoroutine给到block，也就是闭包中的CoroutineScope，接着会调用UndispatchedKt.startUndispatchedOrReturn: 最终调用了block.invoke方法，写个demo看下效果： 日志如下： 从日志可以看出来，它是先等到coroutineScope里面delay执行完了，才执行外面的逻辑。在字节码层面，它会把coroutineScope外面的代码编译成SuspendLambda，它也是个Continuation，等到执行完了coroutineScope内部的代码，才会回调到coroutineScope外面的SuspendLambda中来： 上面分析过UndispatchedKt.startUndispatchedOrReturn中调用了block的invoke方法，此处的block正对应了CoroutineDispatchersActivity$demo7$1这个SuspendLambda对象： 在demo7中将CoroutineDispatchersActivity$demo7$1这个continuation传递到coroutineScope中，而它的invoke方法如下： 创建了CoroutineDispatchersActivity$demo7$1后，继而调用了invokeSuspend方法，而invokeSuspend里面是要等到coroutineScope闭包中的delay挂起结束后，才会再次回到invokeSuspend方法，最后才会输出「demo7: coroutineScope outside」的日志，这也是协程挂起的调用顺序。\nsupervisorScope顶级方法 它和上面的coroutineScope顶级方法差不多，也是先调用完闭包中的逻辑，然后才执行supervisorScope外面的代码。看下它的实现就知道区别了： 他所使用的CoroutineScope是一个SupervisorCoroutine，它和上面用到的ScopeCoroutine区别是重写了childCancelled方法，并返回false，此方法是子协程发生异常后，该不该取消其它的子协程，下面来验证下： 在supervisorScope闭包中launch1发生异常了，由于supervisorScope不会去处理异常，将异常交给了launch1处理，所以launch2中的代码能继续执行。而在coroutineScope中，当launch1发生异常的时候，会将异常交给了coroutineScope，最终导致launch2的协程无法继续执行。\nJob Job实现了CoroutineContext.Element，可以用来取消、启动一个协程，并且和父协程绑定了关系： 它下面有几个关键的子类： 从图上可以看出来前面分析的coroutineScope和supervisorScope两个顶级方法所使用的作用域ScopeCoroutine最终也是一个Job。\n线程例子 先看一个例子： 分别指定了四种线程的用法，日志如下： 第一次： 第二次： Dispatchers.Main.immediate：指定的主线程会最先执行 Dispatchers.Main：指定的主线程会晚于协程外面的主线程 Dispatchers.IO和Dispatchers.Default：指定的线程没有先后之分\nCoroutineScope.lanuch lanuch方法是协程作用域的扩展方法，比如上面例子中的GlobalScope它就是继承自CoroutineScope:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public fun CoroutineScope.launch( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -\u0026gt; Unit ): Job { //① val newContext = newCoroutineContext(context) //② val coroutine = if (start.isLazy) LazyStandaloneCoroutine(newContext, block) else StandaloneCoroutine(newContext, active = true) //③ coroutine.start(start, coroutine, block) //④ return coroutine } 参数： context：launc传进来的context，比如上面例子中传进来的Dispatchers.Main、Dispatchers.IO这些都是CoroutineContext。如果没传就用EmptyCoroutineContext。 start：CoroutineStart的枚举类，表示启动模式，默认是DEFAULT block：协程代码块，是一个CoroutineScope的扩展挂起函数 将外界传进来的context和当前CoroutineScope的context进行合并处理 默认是DEFAULT模式，所以会初始化一个StandaloneCoroutine，会把newContext作为自己的parentContext，它既是一个Continuation，也是一个CoroutineScope 调用StandaloneCoroutine的start方法，并把启动模式，StandaloneCoroutine，协程挂起函数传进去了 StandaloneCoroutine作为lauch的返回值 StandaloneCoroutine它是一个Job类型，也是继承自AbstractCoroutine，看下它的start方法： 这里调用了start变量的invoke方法，因为CoroutineStart重写了invoke方法，所以能直接这么调，相当于是一个闭包的调用方式，这里调用了三参的invoke： 第一个参数：挂起函数闭包，也就是协程要执行的代码块 第二个参数：start方法传进来的StandaloneCoroutine 第三个参数：start方法传进来的this，也是StandaloneCoroutine CoroutineStart是DEFAULT类型，所以会调用挂起函数的startCoroutineCancellable方法： 在上面分析createCoroutine时候也是通过createCoroutineUnintercepted(receiver, completion).intercepted()，创建了delegate，最终是一个Continuation，也是一个suspendLambda。我们直接看ContinuationImpl的intercepted方法： intercepted方法里面取context变量中的key为ContinuationInterceptor的context，而context最终是completion的context，completion是前面start方法传进来的StandaloneCoroutine，它是继承自AbstractCoroutine： parentContext是launch方法传进来的context+CoroutineScope自己的context拼接的一个context this：AbstractCoroutine实现了job接口，job也是一个CoroutineContext 在上面例子中lauch方法是通过GlobalScope启动的，它的context是一个EmptyCoroutineContext，所以传给AbstractCoroutine的parentContext其实就是launch方法传进去的context，也就是Dispatchers.io、Dispatchers.main等。 回到ContinuationImpl的intercepted方法，取context的ContinuationInterceptor,然后调用interceptContinuation方法，看下Dispatchers.io，它最终继承自CoroutineDispatcher： 结论： 如果lauch传的是Dispatchers.io，则lauch先创建DispatchedContinuation，然后调用resumeCancellableWith方法： 如果dispatcher.isDispatchNeeded（默认是true），才会进入到dispatch逻辑，看下dispatchers.io： 调用了default.dispatch方法，diefault是由UnlimitedIoScheduler.limitedParallelism创建的LimitedDispatcher，最终会执行到UnlimitedIoScheduler.dispatch方法： DefaultScheduler的dispatchWithContext方法如下： coroutineScheduler创建如下： 最终会执行到CoroutineScheduler的dispatch方法，里面的代码就不细看了，是线程池部分执行block，关于这部分后面可以深究下，而block是在DispatchedContinuation中resumeCancellableWith方法里面把this给到了dispatcher的dispatch方法，说明DispatchedContinuation实现了Runnable接口，直接看它的run方法，该方法定义在它的父类DispatchedTask中： 此处执行了delegate的resume方法，resume方法执行了resumeWith，注意此处的delegate是DispatchedContinuation中传进来的continuation，它是createCoroutineUnintercepted(receiver, completion).intercepted()创建的delegate，是一个continuation对象，也是suspendlambda，在上面创建协程分析过baseContinuationImpl的resumeWith方法，里面会执行协程的invokeSuspend方法，也就是我们的协程执行代码。执行完了后会执行complete的resumeWith，而通过lauch创建的协程，此处的complete是launch方法构造的StandaloneCoroutine对象，它的resumeWith方法定义在AbstractCoroutine中： AbstractCoroutine的afterCompletion： 此处没有逻辑执行。 我们注意到在讲解协程启动的时候，创建delegate的continuation时候调用createCoroutineUnintercepted只传了complete，没有传receiver。而在launch启动协程时候，将StandaloneCoroutine作为receiver传给了createCoroutineUnintercepted方法： 默认的挂起函数的create方法是抛异常的，需要SuspendLambda的子类自己去实现： 编译后的SuspendLambda的子类create实现： 此处将receiver传到create中没有用到，所以其实跟单参没有什么区别啊。\n总结 结论：协程在启动过程中会取CoroutineContext中的ContinuationInterceptor，然后执行interceptContinuation。而此时如果是一个Dispatchers.IO，它又是继承自CoroutineDispatcher，所以会执行到了CoroutineDispatcher的interceptContinuation。此时得到的是一个DispatchedContinuation对象，并把当前的CoroutineDispatcher和协程启动过程中创建的StandaloneCoroutine传给了。接着会执行DispatchedContinuation的resumeCancellableWith方法，在该方法里面会判断CoroutineDispatcher.isDispatchNeeded，如果是的话，会调用CoroutineDispatcher的dispatch方法，最终会通过线程池会执行到DispatchedContinuation的run方法，因为它是一个Runnable对象。在run方法里面，会执行continuation的resume方法，而此处的continuation是编译器给我们创建的SuspendLambda的子类，最终会执行它的invokeSuspend方法。执行完后会执行协程启动过程中的StandaloneCoroutine的resumeWith方法。 时序图: ","date":"2024-11-05T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E7%BA%BF%E7%A8%8B/","title":"协程如何切换线程"},{"content":" 在讲协程的如何切换线程之前，有必要先了解下协程的上下文是什么？它的结构是什么样的？以及我们如何使用它？今天带着该问题来认识它。\nCoroutineContext 协程上下文都是继承自CoroutineContext，它是一个接口，内部方法以及内部类如下：\n它的实现子类有如下：\n比如我们常见的EmptyCoroutineContext，它的内部实现如下：\n可以看到它的get、fold、plus、minusKey几个方法都是默认实现，你可以理解它就是个空壳子的context。\nElement 在讲CoroutineContext内部结构之前，先来认识下Element，它也实现了CoroutineContext接口：\nElement中有一个key的属性，这里可以理解key就是当前Element的唯一标识。实现一个context的时候需要指明它的key是啥，此处就是用该key来标识 get：如果传进来的key和自己的key相等，则返回自己，否则返回null fold：将初始值和当前element返回给lambda，让lambda自己去处理 minusKey：如果传进来的key和自己相同，则返回EmptyCoroutineContext，否则返回自己，其实是删除对应key的context.\n写了3个context，然后用\u0026quot;+\u0026ldquo;拼接：\n自定义context的时候，需要继承自AbstractCoroutineContextElement，它是继承自Element，因为它强制要求需要一个key作为context的标识，一般key的element标识是当前context，看上面的One这个context，它的key拥有的element是One。\n输出日志如下：\nOne()+Two()+Three()得到的是一个CombinedContext，get方法通过One这个key取到了One这个取对应的Context\n日志如下： 可以看到我给One的context拼接了一个EmptyCoroutineContext时候，得到的是它自己，\u0026quot;+\u0026ldquo;是重载了context的plus方法，看下plus方法的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public operator fun plus(context: CoroutineContext): CoroutineContext = //① if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation //② context.fold(this) { acc, element -\u0026gt; //③ val removed = acc.minusKey(element.key) //③.1 if (removed === EmptyCoroutineContext) element else { // make sure interceptor is always last in the context (and thus is fast to get when present) //④ val interceptor = removed[ContinuationInterceptor] //⑤ if (interceptor == null) CombinedContext(removed, element) else { //⑥ val left = removed.minusKey(ContinuationInterceptor) //⑦ if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else //⑧ CombinedContext(CombinedContext(left, element), interceptor) } } } 1.如果传进来的context是EmptyCoroutineContext，则返回自己，所以上面的One()+EmptyCoroutineContext，得到的是One这个context 2.context.fold，会把初始值和context传给闭包，所以acc是当前context，element是传进来的context 3.acc.minuskey(element.key)，如果传进来的context的key和当前context的key相等，则返回传进来的context，所以新的context会把旧的context给覆盖掉了 4.如果传进来的context的key和当前context的key不相等，removed则是当前context，查看当前context中是否有ContinuationInterceptor类型的context，我们的dispatcher都是属于该类型，需要单独处理 5.如果context中没有ContinuationInterceptor类型的context，则初始化出一个CombinedContext的context，所以上面的One()+Two()+Three()是一个CombinedContext的context 6.如果当前context中存在ContinuationInterceptor类型的context，则继续判断当前context是不是ContinuationInterceptor类型的context 7.如果是ContinuationInterceptor类型的context，则把传进来的context和当前的context组合成CombinedContext的context 8.如果当前的context不是一个ContinuationInterceptor类型的context，则把当前当前的context和传进来的context新组合成一个CombinedContext的context，再和前面的ContinuationInterceptor组合成一个新的CombinedContext的context\nCombinedContext 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 internal class CombinedContext( private val left: CoroutineContext, private val element: Element ) : CoroutineContext, Serializable { override fun \u0026lt;E : Element\u0026gt; get(key: Key\u0026lt;E\u0026gt;): E? { var cur = this while (true) { cur.element[key]?.let { return it } val next = cur.left if (next is CombinedContext) { cur = next } else { return next[key] } } } public override fun \u0026lt;R\u0026gt; fold(initial: R, operation: (R, Element) -\u0026gt; R): R = operation(left.fold(initial, operation), element) public override fun minusKey(key: Key\u0026lt;*\u0026gt;): CoroutineContext { //① element[key]?.let { return left } //② val newLeft = left.minusKey(key) return when { //③ newLeft === left -\u0026gt; this //④ newLeft === EmptyCoroutineContext -\u0026gt; element //⑤ else -\u0026gt; CombinedContext(newLeft, element) } } override fun toString(): String = \u0026#34;[\u0026#34; + fold(\u0026#34;\u0026#34;) { acc, element -\u0026gt; if (acc.isEmpty()) element.toString() else \u0026#34;$acc, $element\u0026#34; } + \u0026#34;]\u0026#34; } 它是直接继承自CoroutineContext，有两个比较重要的属性：\nleft：CoroutineContext，它是左边的节点\nelement：Element，当前节点\n其实和链表的结构有点类似，left相当于next节点。\nget：递归节点，直到left节点不是CombinedContext类型的\nfold：先把left和初始值组成一个初始值，然后再把这个初始值和当前节点传给闭包\nminusKey：\n1.如果当前节点中找到了该key，则返回left节点\n2.如果找不到，则继续在left节点中找\n3.如果找不到返回this\n4.如果找到了则返回当前节点\n5.否则继续往左边再找\n整个分析来看，协程中的context如果是多个context拼接的时候如果传进来的是EmptyCoroutineContext，则只保存自己。如果传进来的context的key和当前context的key一样，则会覆盖掉原来的context。如果都不满足，则采用链表的形式插入到原来的context头节点上，如果传进来的是ContinuationInterceptor类型的，则会把该类型放到头节点。\n类图 再来一张本次讲解的context类图：\n","date":"2024-11-04T00:00:00Z","permalink":"https://example.com/p/%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87/","title":"协程上下文"},{"content":"kotlin中inline，noinline，crossinline区别？ 默认函数中如果没加inline，那就是非内联函数，此时lambda会生成一个新的类，该类是继承自Lambda抽象类，并实现了Function接口，其中invoke方法就是Function接口的方法，invoke中的方法就是lambda代码块的代码。 内联函数(加inline关键字)的lambda如果没加noinline或crossinline，默认会把lambda的代码块给平铺到调用处，所以此时如果在lambda中加return的话，会直接不执行外层函数后续代码。如果是非内联函数的话，由于它是生成一个单独的类，不存在平铺代码，所以return是编译不过去的。 noinline和inline是对立关系，它是将lambda不内联处理，如果你需要对该lambda作为对象来使用的时候，此时需要用到noinline，如果一个内联函数都是noinline的lambda表达式，那么此时as会提示你此处可以去掉inline关键字了，当做普通的高阶函数来处理就行。 crossinline算是在内联和非内联之间做智能化选择，如果你将lambda表达式当做变量来使用，此时编译器不会内联该lambda，比如： 1 2 3 4 5 6 7 8 9 10 11 inline fun hello4(run1: () -\u0026gt; Unit, crossinline run: () -\u0026gt; Unit) { run1() hello5 { run() } println(\u0026#34;hello4后续代码\u0026#34;) } fun hello5(run: () -\u0026gt; Unit) { run() println(\u0026#34;hello5后续代码\u0026#34;) } 上面我将hello4中的run表达式传给了hello5，而hello5不是一个内联函数，所以此时会把lambda作为一个变量传到hello5中： 如果改成如下方式：\n1 2 3 4 5 6 7 8 9 10 11 inline fun hello4(run1: () -\u0026gt; Unit, crossinline run: () -\u0026gt; Unit) { run1() hello5 { run() } println(\u0026#34;hello4后续代码\u0026#34;) } inline fun hello5(run: () -\u0026gt; Unit) { run() println(\u0026#34;hello5后续代码\u0026#34;) } 相关文档：https://juejin.cn/post/6869954460634841101\njava lambda和kotlin lambda区别 在java中如果使用匿名内部类的形式，在编译时它是会单独生成一个类，其中类名是「外部类名$index.class」这种形式。如果使用lambda的形式，它不会在编译时单独生成一个类，它是执行了invokedynamic指令，在运行时动态生成lambda的类，其中类名是「外部类名$Lambda$index.class」这种形式。 参考:https://juejin.cn/post/7004642395060961310 kotlin lambda它是在编译时看是否需要生成单独的类，如果是内联的时候就直接平铺代码，如果是非内联的时候才生成单独的类。 协程是怎么挂起的？怎么恢复的？ 首先每一个协程代码块都会被编译成SuspendLambda对象，它也是一个Continuation对象，每次在执行到SuspendLambda的resume时候，都会去执行invokeSuspend方法，而该方法里面会去执行子协程，如果子协程返回SUSPEND_COROUTINE状态的时候，父协程的resume方法会直接return了。当子协程执行完后，会通知父协程，此时父协程的的invokeSuspend方法再次被执行，而此时的状态机会发生变化，如果此时状态恢复后，会执行父协程中的Continuation，也就是父父协程的执行。 协程中的dispather是怎么指定在哪个线程上执行的？ 首先dispather它是CoroutineContext（上下文）的一部分，在协程启动过程中，会取CoroutineContext中的CoroutineDispathcer部分。此时会构造一个DispathedContinuation对象，并把前面取到的Dispather传到DispathedContinuation中，此时会将DispathedContinuation扔到线程池中，最终会执行DispathedContinuation的run方法，在run里面会执行到SuspendLambda，也就是协程的代码块，最终会执行它的invokeSuspend方法。所以协程代码块中代码要执行在哪个线程是协程上下文的dispather部分指定的线程。 相关文档：https://www.xiangcman.fun/p/%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E7%BA%BF%E7%A8%8B/\nLinkedList特性 LinkedList继承自Deque，它是一个双端队列，允许在队列的两端插入和删除元素。可以作为栈（LIFO）或队列（FIFO）使用。基于链表（双向链表）实现，可以高效地插入和删除元素。 offer：给链表尾部插入元素，返回值表示是否插入成功 peek：取出头部节点，如果没有则返回null poll：取出头部节点，如果没有则返回null，取完后并把头部节点从队列中移除 remove：移除头部节点，如果没有头部节点则抛异常，有的话，则返回 push：给链表头部插入元素，没有返回值 pop：和remove一样的，都是移除头部节点，如果没有头部节点则抛异常，有的话，则返回\n如果想实现队列的话，则使用offer和poll这一对方法；如果想实现栈的话，可以通过offerLast和pollLast来实现，或者通过offerFirst和pollFirst来实现。\nArrayDeque特性 它也是继承自Deque，和LinkedList的特性一样的，只不过ArrayDeque是通过数组实现的双端队列，内部用一个数组来放所有的节点，并且有两个int值用来存放头结点和尾结点的索引。并且ArrayDeque内部的默认节点容量是16个，也可以初始化容量大小。\n区别：如果频繁要插入和删除操作，那么使用LinkedList，如果是查询情况比较多，可以优先使用ArrayDeque。\nPools.Pool 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 class Pools private constructor() { /** * Interface for managing a pool of objects. * * @param T The pooled type. */ interface Pool\u0026lt;T : Any\u0026gt; { /** * @return An instance from the pool if such, null otherwise. */ fun acquire(): T? /** * Release an instance to the pool. * * @param instance The instance to release. * @return Whether the instance was put in the pool. * * @throws IllegalStateException If the instance is already in the pool. */ fun release(instance: T): Boolean } /** * Simple (non-synchronized) pool of objects. * * @param maxPoolSize The maximum pool size * @param T The pooled type. */ open class SimplePool\u0026lt;T : Any\u0026gt;( /** * The max pool size */ @IntRange(from = 1) maxPoolSize: Int ) : Pool\u0026lt;T\u0026gt; { private val pool: Array\u0026lt;Any?\u0026gt; private var poolSize = 0 init { require(maxPoolSize \u0026gt; 0) { \u0026#34;The max pool size must be \u0026gt; 0\u0026#34; } pool = arrayOfNulls(maxPoolSize) } override fun acquire(): T? { if (poolSize \u0026gt; 0) { val lastPooledIndex = poolSize - 1 @Suppress(\u0026#34;UNCHECKED_CAST\u0026#34;) val instance = pool[lastPooledIndex] as T pool[lastPooledIndex] = null poolSize-- return instance } return null } override fun release(instance: T): Boolean { check(!isInPool(instance)) { \u0026#34;Already in the pool!\u0026#34; } if (poolSize \u0026lt; pool.size) { pool[poolSize] = instance poolSize++ return true } return false } private fun isInPool(instance: T): Boolean { for (i in 0 until poolSize) { if (pool[i] === instance) { return true } } return false } } /** * Synchronized pool of objects. * * @param maxPoolSize The maximum pool size * @param T The pooled type. */ open class SynchronizedPool\u0026lt;T : Any\u0026gt;(maxPoolSize: Int) : SimplePool\u0026lt;T\u0026gt;(maxPoolSize) { private val lock = Any() override fun acquire(): T? { synchronized(lock) { return super.acquire() } } override fun release(instance: T): Boolean { synchronized(lock) { return super.release(instance) } } } } 很明显这是一个对象池，SimplePool继承自Pool，并且可以指定对象池的大小。每次要回收的时候调用release，只有当前size小于对象池最大容量的时候才能回收，每次通过acquire来进行获取对象池中的元素。 其中在recyclerview动画篇章中，分析到InfoRecord对象中会使用Pools.SimplePool，InfoRecord存储的是ViewHolder在pre-layout阶段的坐标信息和post-layout阶段的坐标信息，以及ViewHolder的flag信息。因为ViewHolder的这些信息在动画处理过程中会频繁使用，所以此处使用了对象池来管理。\n","date":"2024-11-04T00:00:00Z","permalink":"https://example.com/p/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/","title":"笔记整理"},{"content":"协程创建 demo 1 2 3 4 5 6 7 8 9 10 11 12 suspend { Log.d(TAG, \u0026#34;suspend block:\u0026#34;) \u0026#34;123\u0026#34; }.createCoroutine(object : Continuation\u0026lt;String\u0026gt; { override val context: CoroutineContext get() = EmptyCoroutineContext override fun resumeWith(result: Result\u0026lt;String\u0026gt;) { val value = result.getOrNull() Log.d(TAG, \u0026#34;resumeWith:$value\u0026#34;) } }).resume(Unit) Log.d(TAG, \u0026#34;onCreate\u0026#34;) 上面日志先打印suspend中的代码块，然后执行Continuation的resumeWith，最后执行主线程的代码。\ncreateCoroutine 是挂起函数的扩展方法，方法参数是Continuation类型，对应上面的匿名内部类。创建了一个SafeContinuation对象，它也是一个Continuation类型，并传递两个参数。\nresume resume方法会调用resumeWith，看下SafeContinuation的resumeWith方法： 此处提醒下，kotlin的源码需要到对应的** Jvm类下找，要不然方法只是一个申明。此处的result是构造SafeContinuation传递进来的COROUTINE_SUSPENDED，因此会执行delegate.resumeWith(result)，此处的delegate是createCoroutineUnintercepted(completion).intercepted()创建的。\ncreateCoroutineUnintercepted 它是挂起函数的扩展方法：\n判断当前挂起函数是不是BaseContinuationImpl类型，如果是则调用create方法。\n此时可以打开字节码，看下上面的(suspend () -\u0026gt; T)是什么对象？\n可以看到createCoroutine方法传入了两个参数，我们都知道扩展函数最终编译出来的方法第一个参数是被扩展对象，所以此处的CoroutineActivity$onCreate$1就是(suspend () -\u0026gt; T)，CoroutineActivity$onCreate$2对应的是例子中的Continuation匿名内部类。我们注意下，此时传入CoroutineActivity$onCreate$1中的Continuation参数是null。\n而SuspendLambda的继承关系如下：\n所以会调用挂起函数的create方法：\n父类中要求子类必须重写该方法，我们看CoroutineActivity$onCreate$1的create方法：\n此时重新new了一个CoroutineActivity$onCreate$1，并把completion传入其中，而此处的completion就是上面的CoroutineActivity$onCreate$2，它是一个Continuation。而开端在分析createCoroutine的时候，创建CoroutineActivity$onCreate$1传入的Continuation是null。\n不太明白，为什么不在createCoroutine时候直接直接把CoroutineActivity$onCreate$2传入到CoroutineActivity$onCreate$1中，而非要通过create方法再创建一个CoroutineActivity$onCreate$1。\n我们再来看intercepted方法。\nintercepted 是Continueation的扩展方法，当然了，刚刚create创建的CoroutineActivity$onCreate$1是一个suspendLambda对象，所以它也是ContinueationImpl，所以会走ContinueationImpl的intercepted方法：\n此处看context中有没有ContinuationInterceptor类型的Element，如果没有则返回自己，我们只要知道先返回自己。因为这个涉及到context的结构，后面再讲。\n小节： ①、createCoroutine创建了一个SafeContinuation，并把CoroutineActivity$onCreate$1和一个标志位COROUTINE_SUSPENDED传入其中。CoroutineActivity$onCreate$1继承自SuspendLambda，并且是一个Function接口的实例。SuspendLambda继承自ContinuationImpl，ContinuationImpl继承自BaseContinuationImpl，BaseContinuationImpl继承自Continuation，CoroutineActivity$onCreate$1继承自SuspendLambda，也就是上面的协成要执行的闭包。CoroutineActivity$onCreate$1持有了CoroutineActivity$onCreate$2，它实现了Continuation。CoroutineActivity$onCreate$1重写了create方法，返回了一个新的CoroutineActivity$onCreate$1对象。 ②、resume方法中会调用到SafeContinuation的resumeWith方法，最终会触发CoroutineActivity$onCreate$1的resumeWith方法。\n协程执行 CoroutineActivity$onCreate$1继承自SuspendLambda，最终会继承自BaseContinuationImpl，来看下它的resumeWith：\nresumeWith中首先调用invokeSuspend方法，如果invokeSuspend方法返回COROUTINE_SUSPENDED，则resumeWith直接不往下执行。否则看comppletion是不是BaseContinuationImpl，是的话，则继续轮训，直到comppletion不是BaseContinuationImpl，则执行它的resumeWith方法。此处的completion实际是CoroutineActivity$onCreate$2，所以会执行它的resumeWith方法。我们看下CoroutineActivity$onCreate$1的invokeSuspend方法：\n它的返回值不是COROUTINE_SUSPENDED，所有上面的invokeSuspend方法还会继续往下执行。所以最终会执行了CoroutineActivity$onCreate$2，也就是例子中的匿名内部类的resumeWith方法。\n此时我们再分析例子中日志的打印：\n可以看到执行SafeContinuation的resumeWith的时候是一个while(true)，传入的this.resume是一个COROUTINE_SUSPENDED标志位，所以会把CoroutineActivity$onCreate$1的resumeWith执行完后，才跳出while循环。因此日志最后输出协成外的代码。\n类图总结 最后输出此次的类图结构，以作回顾：\n","date":"2024-11-02T00:00:00Z","image":"https://example.com/p/android-%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%88%B0%E6%89%A7%E8%A1%8C/cover_hu17536845123992820283.jpg","permalink":"https://example.com/p/android-%E5%8D%8F%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%88%B0%E6%89%A7%E8%A1%8C/","title":"Android 协程启动到执行"},{"content":"Bytecode-viewer 一款查看class文件的工具\n使用： 目录定位到该jar包下面，然后使用如下命令：\njava -jar Bytecode-Viewer-2.12.jar\nsh脚本执行文件： Bytecode-Viewer.sh\n脚本文件：\nBytecode-Viewer-2.12.jar\n来源:https://github.com/Konloch/bytecode-viewer\n动画差值器 在线预览：https://inloop.github.io/interpolator/\n","date":"2024-11-02T00:00:00Z","permalink":"https://example.com/p/%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/","title":"工具整理"},{"content":"类图 Context创建 Activity继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，当activity创建的之前，会先创建contextimpl ActivityThread.performLaunchActivity\n接着会调用contextimpl的setOuterContext，传入的是activity。\n结论：contextImpl中的outerContext指向了activity。\nContext传递 attach调用了attachBaseContext，并把contextimpl传进去了：\n该方法是ContextWrapper中的方法，并指向了mBase变量。Activity中getBaseContext和getApplicationContext区别：\ngetBaseContext指向了刚刚attach方法传进来的contextimpl。\n指向了mBase.getApplicationContext：\nmPackageInfo是在创建contextimpl的时候传入的，它是loadedApk对象，它的getApplication方法是获取应用的Application对象：\n结论：getBaseContext获取的是contextimpl对象，getApplicationContext获取的是Application对象。\n主题设置 回到performLaunchActivity，给activity设置主题：\n将theme的resid传进来，最终会把resid这个theme追加到mTheme上。这里牵扯到资源加载，后面再说。\nLayoutInflater中的context LayoutInflater.from(context)： 此处的context一般是activity，看activity.getSystemService方法，如果传入的不是activity，比如是ContextThemeWrapper，Application会怎么样：\n通过base调用getSystemService，而base其实也是activity。Application是继承自ContextWrapper：\nbase是contextimpl，最终调用的是contextimpl的getSystemService，activity亦是如此：\n从SYSTEM_SERVICE_FETCHERS中获取：\n最终是在此处添加了一个PhoneLayoutInflater对象，并把contextimpl.getOuterContext传进去了，此处传进去的是Activity对象。\nlayoutinflater.inflate: 此过程调用createViewFromTag来创建view：\n此处看view有没有theme属性，有的话，则构造一个contextthemeWrapper出来，举个例子：\n此处定义了一个theme属性，那么给该view的构造器传入的context就是一个contextThemeWrapper对象。\n在from方法里面，传入一个contextthemewrapper对象，并携带一个style。根据上面分析from方法时，contextthemewrapper是通过base.getSystemService。此处的base又是activity，又因为activity.getSystemService，调用base.getSystemService，所以最终又回到了contextimpl.getSystemService。而在创建PhoneLayoutInflater的时候，又通过contextimpl.getOuterContext传入到PhoneLayoutInflater构造器中，但是在contextthemewrapper中最后又调了PhoneLayoutInflater的cloneInContext：\n所以此种情况下，最终给view传的context也是一个contextthemewrapper的context。\nAttr部分 从主题中获取属性：\n最终这些属性是通过context的obtainStyledAttributes获取属性值。常见的方法是：\nAttributeSet表示所有的属性集，它是在inflate过程中解析到view的属性集。 attrs表示的是要从哪个属性集中取到属性。 例如：\nattrs文件中定义一个declare-styleable属性集，aapt工具会生成对应的R.class，但是此时是一个R.jar文件：\n该文件在app/build/intermediates/compile_and_runtime_not_namespaced_r_class_jar/debug/R.jar，反编译该jar文件：\n最终所有的资源类型都会生成一个R$**.class的类，而R.class其实是一个空壳：\n看刚才定义的declare-styleable生成如下：\n并且会在R$attr.class下面也会生成一个两个int值：\n可以看出来生出来一个R.styleable.TestView的数组和两个int值，分别是R.styleable.TestView_attr1和R.styleable.TestView_attr2，它两分别代表TestView数组的索引，而对应的值是定义在resource.arsc文件中：\n所以最终得出结论是：通过context.obtainStyledAttributes传入attrbuteset和attrs数组，得到了typearray，然后通过typearray的索引得到所有的属性：\ndefStyleAttr、defStyleRes 新增一个不在declare-styleable数组中的attr11，见R文件：\n在R.styleable类中没有attr11的定义，它在R.attr类中定义了：\n在上面属性中attr7和attr11是引用类型的，他们可以指向另外一个引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public class TestView1 extends View { public TestView1(Context context) { this(context, null); } public TestView1(Context context, @Nullable AttributeSet attrs) { this(context, attrs, R.attr.attr11); } public TestView1(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { this(context, attrs, defStyleAttr, R.style.DefStyleRes); } public TestView1(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context, attrs, defStyleAttr, defStyleRes); TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.gui, defStyleAttr, defStyleRes); log(\u0026#34;TypedArray length：\u0026#34; + ta.length()); for (int i = 0; i \u0026lt; ta.length(); i++) { int attrIndex = ta.getIndex(i); switch (attrIndex) { case R.styleable.gui_attr1: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr2: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr3: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr4: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr5: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr6: log(ta.getString(attrIndex)); break; case R.styleable.gui_attr7: log(ta.getString(attrIndex)); break; default: break; } } ta.recycle(); } private void log(String msg) { Log.v(getClass().getSimpleName(), \u0026#34;\u0026#34; + msg); } } TestView1中defStyleAttr传入R.attr.attr11，defStyleRes传入R.style.DefStyleRes。 布局文件如下：\n其中theme中引用了attr11的引用，而themestyle中引用了attr1-attr4，DefStyleRes中也引用了attr1-attr4。日志如下：\nR.styleable.gui总共长度是7，attr1用的xml中定义的，attr2是布局中定义的style中的属性，attr3和attr4取的是theme中attr11定义的attr3和attr4，由于attr5没有在attr11中的style中定义，所以取的是theme中的attr5属性。 优先级：布局中的attr\u0026gt;布局中的style中的attr\u0026gt;defStyleAttr中的attr\u0026gt;theme中的attr 此时无论怎么在DefStyleRes中定义属性，都不会在该style里面的attr取值，因为此时定义了defStyleAttr 此时如果去掉defStyleAttr，则会在DefStyleRes中取值：\n结果如下：\n总结：defStyleAttr定义了后，defStyleRes中的attr就不起作用了。\n参考：https://blog.csdn.net/GracefulGuigui/article/details/104069265\n","date":"2024-10-25T00:00:00Z","permalink":"https://example.com/p/android-context%E6%80%BB%E7%BB%93/","title":"Android context总结"}]