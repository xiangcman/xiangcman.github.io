<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>设计模式 on xiangcman</title>
        <link>https://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
        <description>Recent content in 设计模式 on xiangcman</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>Example Person</copyright>
        <lastBuildDate>Fri, 07 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>java设计原则与模式</title>
        <link>https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Fri, 07 Mar 2025 00:00:00 +0000</pubDate>
        
        <guid>https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/</guid>
        <description>&lt;h3 id=&#34;设计原则&#34;&gt;设计原则
&lt;/h3&gt;&lt;h4 id=&#34;开闭原则&#34;&gt;开闭原则
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;主要指对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节。&lt;/li&gt;
&lt;li&gt;优点：保持软件的稳定性，不影响原有业务逻辑代码。使代码更具有模块化，易于维护。提高开发效率。&lt;/li&gt;
&lt;li&gt;来源：&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000021922108&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://segmentfault.com/a/1190000021922108&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;里式替换原则&#34;&gt;里式替换原则
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;所有引用基类的地方必须能透明地使用其子类的对象&lt;/li&gt;
&lt;li&gt;原则：子类必须实现父类的抽象方法，不得重写父类的非抽象方法&lt;/li&gt;
&lt;li&gt;子类可以增加自己特有的方法&lt;/li&gt;
&lt;li&gt;子类在实现父类的方法的时候，形参要比父类的参数更加宽松。&lt;/li&gt;
&lt;li&gt;子类实现父类的方法的时候，出参要比父类更加严格。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;依赖倒置原则&#34;&gt;依赖倒置原则
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;高层模块不应该直接依赖底层模块，二者应该依赖抽象，抽象不应该依赖细节，细节应该依赖抽象。&lt;/li&gt;
&lt;li&gt;比如A类是接口，B类是实现，而C类要使用B类，那么C类不能直接使用B类，而是通过依赖A接口来实现，这样将使用谁的权交给了外界。C类更加的灵活&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;单一职业原则&#34;&gt;单一职业原则
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;一个类或者模块只负责完成一个职责。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;接口隔离原则&#34;&gt;接口隔离原则
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。和单一职责原则相比，他们都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想。两者不同在于单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。单一职责原则主要是约束类，它针对的是程序中的实现和细节。接口隔离原则主要是约束接口，主要针对抽象和程序整体框架的构建。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;迪米特法则&#34;&gt;迪米特法则
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用，目的是降低类之间的耦合度，提高模块的相对独立性。由于亲合度降低，从而提高了类的可复用率和系统的扩展性。&lt;/li&gt;
&lt;li&gt;比如A类想调用B类，但是他们又没有直接联系，而通过中间的C类来调用B类。A-&amp;gt;C-&amp;gt;B这种调用关系&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;合成复用原则&#34;&gt;合成复用原则
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;要求在软件复用时，尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用集成关系来实现。采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，从而新对象可以调用已有对象的功能。&lt;/li&gt;
&lt;li&gt;维持了类的封装性，因为成分对象的内部细节是新对象看不见的，这种复用称为黑箱复用。&lt;/li&gt;
&lt;li&gt;新旧类之间的耦合度低，这种复用所需的依赖较少，新对象存储成分对象的唯一方法是通过成分对象的接口。&lt;/li&gt;
&lt;li&gt;复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;设计模式&#34;&gt;设计模式
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;设计模式分为创建型、结构型、行为型。
&lt;ol&gt;
&lt;li&gt;创建型：用于对象的创建，提高代码的灵活性和复用性
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;设计模式&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;工厂方法模式（Factory Method）&lt;/td&gt;
          &lt;td&gt;通过工厂类提供一个创建对象的接口，而不是直接 new 一个对象，提高代码的可扩展性。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;抽象工厂模式（Abstract Factory）&lt;/td&gt;
          &lt;td&gt;提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;单例模式（Singleton）&lt;/td&gt;
          &lt;td&gt;确保一个类只有一个实例，并提供一个全局访问点。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;建造者模式（Builder）&lt;/td&gt;
          &lt;td&gt;用于创建复杂对象，将对象的构建与表示分离，以便相同的构建过程可以创建不同的表示。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;原型模式（Prototype）&lt;/td&gt;
          &lt;td&gt;通过复制（克隆）已有的实例来创建新对象，而不是通过实例化。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;结构型模式：主要用于类与对象的组合，确保系统的结构更加灵活和高效。
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;设计模式&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;适配器模式（Adapter）&lt;/td&gt;
          &lt;td&gt;让原本不兼容的接口能够协同工作，相当于“转换器”。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;桥接模式（Bridge）&lt;/td&gt;
          &lt;td&gt;分离抽象部分和实现部分，使它们可以独立变化，提高可扩展性。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;装饰器模式（Decorator）&lt;/td&gt;
          &lt;td&gt;通过动态地给对象增加额外的功能，而不会改变其结构（类似于 Java 的 IO 流）。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;组合模式（Composite）&lt;/td&gt;
          &lt;td&gt;允许将对象组合成树形结构，以表示“整体-部分”关系，适用于树形结构数据。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;外观模式（Facade）&lt;/td&gt;
          &lt;td&gt;提供一个统一的接口，用于访问子系统的一组接口，简化客户端的调用。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;享元模式（Flyweight）&lt;/td&gt;
          &lt;td&gt;通过共享对象，减少内存占用，提高性能。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;代理模式（Proxy）&lt;/td&gt;
          &lt;td&gt;通过代理对象控制对目标对象的访问，例如：静态代理、动态代理（JDK/CGLIB）。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;行为型模式：主要用于对象之间的通信和职责分配，提高代码的可维护性和可扩展性。
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;设计模式&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;策略模式（Strategy）&lt;/td&gt;
          &lt;td&gt;定义一系列算法，将每种算法封装起来，并使它们可以互换。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;观察者模式（Observer）&lt;/td&gt;
          &lt;td&gt;允许对象间建立一对多的依赖关系，当一个对象状态变化时，所有依赖它的对象都会收到通知（如 监听器 机制）。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;责任链模式（Chain of Responsibility）&lt;/td&gt;
          &lt;td&gt;将请求沿着处理链传递，直到某个对象处理请求，降低耦合度（如 Java Web 过滤器）。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;命令模式（Command）&lt;/td&gt;
          &lt;td&gt;将请求封装为对象，支持请求的撤销（Undo）和恢复（Redo）。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;备忘录模式（Memento）&lt;/td&gt;
          &lt;td&gt;保存对象的历史状态，以便以后恢复（如 撤销/恢复 操作）。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;状态模式（State）&lt;/td&gt;
          &lt;td&gt;允许对象在不同状态下改变行为，避免大量 if-else 语句。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;中介者模式（Mediator）&lt;/td&gt;
          &lt;td&gt;通过一个中介对象来协调多个对象之间的交互，避免对象间的直接通信。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;迭代器模式（Iterator）&lt;/td&gt;
          &lt;td&gt;提供一种访问集合对象元素的方法，而不暴露集合的内部表示。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;访问者模式（Visitor）&lt;/td&gt;
          &lt;td&gt;允许在不修改对象结构的情况下，向对象结构中添加新的行为（如 XML 解析）。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;解释器模式（Interpreter）&lt;/td&gt;
          &lt;td&gt;用于定义语言的语法规则，并解释相应的表达式（如 SQL 解析）。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;单例模式&#34;&gt;单例模式
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;饿汉式：类加载时机就已经把单例对象实例化出来了，所以他不存在线程安全问题。但是它会浪费内存，在还没使用的时候，就已经创建了实例。
&lt;img src=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B.png&#34;
	width=&#34;1258&#34;
	height=&#34;668&#34;
	srcset=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B_hu_8f552d015b64da7c.png 480w, https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B_hu_294090fd966a4b43.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;188&#34;
		data-flex-basis=&#34;451px&#34;
	
&gt;&lt;/li&gt;
&lt;li&gt;懒汉式（线程不安全）
&lt;img src=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8.png&#34;
	width=&#34;724&#34;
	height=&#34;522&#34;
	srcset=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8_hu_78f617843f9f1b39.png 480w, https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8_hu_ac79883fe134ac1a.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;138&#34;
		data-flex-basis=&#34;332px&#34;
	
&gt;
&lt;ul&gt;
&lt;li&gt;创建对象的时机修改为了在getInstance内部，需要时再创建，可以节约系统资源。&lt;/li&gt;
&lt;li&gt;getInstance方法在多个线程并发调用时，有可能会出现创建了多个实例，所以这是线程不安全的单例模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;懒汉式（线程安全）
&lt;img src=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E6%96%B9%E6%B3%95%E5%8A%A0%E9%94%81.png&#34;
	width=&#34;984&#34;
	height=&#34;540&#34;
	srcset=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E6%96%B9%E6%B3%95%E5%8A%A0%E9%94%81_hu_a23bae050f0c9a57.png 480w, https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E6%96%B9%E6%B3%95%E5%8A%A0%E9%94%81_hu_d9eec35aa9aa5739.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;182&#34;
		data-flex-basis=&#34;437px&#34;
	
&gt;
&lt;ul&gt;
&lt;li&gt;方法上加锁，这种加锁能保证线程安全问题，但是加锁的粒度较大，每次在调用getInstance方法的时候，都需要加锁，很显然，锁的开销很大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;懒汉式（线程安全-dcl模式）
&lt;img src=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-dcl%E6%A8%A1%E5%BC%8F.png&#34;
	width=&#34;816&#34;
	height=&#34;672&#34;
	srcset=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-dcl%E6%A8%A1%E5%BC%8F_hu_6131b6284634999c.png 480w, https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-dcl%E6%A8%A1%E5%BC%8F_hu_7938b39de945d47f.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;121&#34;
		data-flex-basis=&#34;291px&#34;
	
&gt;
&lt;ul&gt;
&lt;li&gt;双重判断，成员属性instance上，增加了volatile关键字，保障多线程对instance值的可见性以及禁止指令重排。
第一层非空判断是为了锁的开销，只有为空的时候才加锁。第二层非空判断是为了防止创建了多个实例。&lt;/li&gt;
&lt;li&gt;第一层非空判断是为了锁的开销，只有为空的时候才加锁。第二层非空判断是为了防止创建了多个实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;静态内部类中加静态变量
&lt;img src=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8A%A0%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F.png&#34;
	width=&#34;970&#34;
	height=&#34;480&#34;
	srcset=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8A%A0%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F_hu_74673bebb225bf83.png 480w, https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8A%A0%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F_hu_810020d1c3cf2ad4.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;202&#34;
		data-flex-basis=&#34;485px&#34;
	
&gt;
&lt;ul&gt;
&lt;li&gt;静态内部类可以达到双检锁的效果。将instance放在了内部类中，不会在类加载的时候就加载实例，这个和饿汉式在类加载的时候就加载有区别。他只会在getInstance的时候，才会去加载内部类，此时才会去加载单例实例。并且instance是内部类类加载的时候才进行加载，所以线程安全问题也保证了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;枚举单例
&lt;img src=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B.png&#34;
	width=&#34;542&#34;
	height=&#34;234&#34;
	srcset=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B_hu_a30663440ad5d877.png 480w, https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B_hu_9ee3e1f9c39fdfe6.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;231&#34;
		data-flex-basis=&#34;555px&#34;
	
&gt;
&lt;ul&gt;
&lt;li&gt;这种不仅能避免多线程同步问题，还自动支持序列化机制，防止反序列化重新创建新的对象，防止多次实例化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;原型模式&#34;&gt;原型模式
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Java原型模式（Prototype Pattern）是一种创建型设计模式，其目的是通过复制现有对象来创建新的对象。&lt;/li&gt;
&lt;li&gt;使用场景：
&lt;ul&gt;
&lt;li&gt;当对象创建的过程比较耗时或者比较复杂，例如需要进行复杂的计算或者涉及到网络请求等操作，可以使用原型模式来避免重复的初始化过程。&lt;/li&gt;
&lt;li&gt;当需要创建的对象需要和其他对象进行协同工作时，例如需要创建一个包含多个对象的组合对象，可以使用原型模式来复制一个已有的组合对象，然后进行修改来创建新的组合对象。&lt;/li&gt;
&lt;li&gt;当需要动态地增加或者删除一些对象时，可以使用原型模式来复制一个已有的对象，然后进行修改来创建新的对象。&lt;/li&gt;
&lt;li&gt;当需要保护对象的复杂状态时，例如当一个对象的创建需要大量的数据初始化时，可以使用原型模式来保护这些数据，避免因为对象的复制而产生意外的副作用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码实现：
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 定义一个原型接口&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Prototype&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Prototype&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;clone&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 具体的原型类&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ConcretePrototype&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Prototype&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Prototype&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;clone&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ConcretePrototype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 客户端代码&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Client&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Prototype&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prototype&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ConcretePrototype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Prototype&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;clone&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prototype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;clone&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;使用小结：
&lt;ul&gt;
&lt;li&gt;Java中的Object类实现了Cloneable接口，这就意味着Java中的任何对象都可以实现原型模式。通过实现Cloneable接口，并重写Object类中的clone()方法，可以实现原型模式。例如 ArrayList、HashMap 等集合类都实现了Cloneable 接口，可以通过复制现有对象来创建新的对象。&lt;/li&gt;
&lt;li&gt;Java中的线程池也是使用了原型模式，线程池中的每个线程都是从原型线程中复制而来，而不是每次创建新的线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;工厂模式&#34;&gt;工厂模式
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分为简单工厂模式、工厂方法模式、抽象工厂模式。定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的创建与使用相分离。创建型模式可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;简单工厂模式
&lt;img src=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png&#34;
	width=&#34;898&#34;
	height=&#34;500&#34;
	srcset=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F_hu_4d02ffd4f313328a.png 480w, https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F_hu_94695e990651a461.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;179&#34;
		data-flex-basis=&#34;431px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单工厂类会很庞大，负责创建所有产品的创建，如果要新增产品类，会修改工厂类，违背了开闭原则。并且违背了高聚合原则。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工厂方法模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在简单工厂类基础上将工厂类也进行抽象化，每个工厂类只做一件事，那就是生产对应的对象，保证了单一职责原则，并且保证了开闭原则，如果要生产不同的对象，只需要提供对应的工厂实现类就可以。
&lt;img src=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png&#34;
	width=&#34;1070&#34;
	height=&#34;684&#34;
	srcset=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F_hu_9743ce8971d2d6e6.png 480w, https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F_hu_befeb2fd12b533d5.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;156&#34;
		data-flex-basis=&#34;375px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象工厂模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和上面的工厂方法模式差不多，也是有对应的工厂实现类，区别是工厂类能生产不同级别的产品。
&lt;img src=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png&#34;
	width=&#34;1384&#34;
	height=&#34;996&#34;
	srcset=&#34;https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F_hu_b68c7303ccffee30.png 480w, https://example.com/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F_hu_7f99eaa23582d0eb.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;138&#34;
		data-flex-basis=&#34;333px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
