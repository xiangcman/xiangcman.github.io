<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>RecyclerView on xiangcman</title>
        <link>https://example.com/categories/recyclerview/</link>
        <description>Recent content in RecyclerView on xiangcman</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>Example Person</copyright>
        <lastBuildDate>Thu, 02 Jan 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://example.com/categories/recyclerview/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>RecyclerView源码走读</title>
        <link>https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/</link>
        <pubDate>Thu, 02 Jan 2025 00:00:00 +0000</pubDate>
        
        <guid>https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/</guid>
        <description>&lt;h3 id=&#34;初始化过程&#34;&gt;初始化过程
&lt;/h3&gt;&lt;p&gt;当我们app收到choregrapher的vsync信号的时候，会给主线程发送一条消息， 告诉app需要绘制了，而此时发送是通过给主线程的message设置一个callback（runnable），所以会触发handler的dispatchmessage-&amp;gt;handleCallback，接着就是触发FrameDisplayEventReceiver的doframe方法，该方法会计算丢帧数，以及执行callbackqueue数组中的callbackqueue，也就执行到了我们的performTraversal方法，该方法里面会执行到measure，最后执行到recyclerview的onMeause，recyclerview的onMeasure中会判断自己的测量模式，如果是精确的模式，则不测量子item。&lt;/p&gt;
&lt;p&gt;trace图如下：
&lt;img src =&#34;调用recyclerview的onMeasure调用链.png&#34; width =700/&gt;&lt;/p&gt;
&lt;p&gt;接着走到recyclerview的onlayout，在onlayout里面触发dispatchlayout，该方法里面会判断state的step，默认是STEP_START，因此会触发dispatchLayoutStep1和dispatchLayoutStep2，在dispatchLayoutStep1中如果有动画要处理，则会触发layoutManager的onlayoutChildren&lt;/p&gt;
&lt;img src =&#34;recyclerview在dispatchLayoutStep1.png&#34; width =700/&gt;
&lt;p&gt;有动画的条件是：
&lt;img src =&#34;recyclerview动画判断.png&#34; width =700/&gt;
有表项新增或移除、有更改的时候。默认是没有动画要处理，紧接着来到了dispatchLayout2，该方法主要是触发了layoutManager.onLayoutChildren。
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/onLayoutChildren%E8%B0%83%E7%94%A8%E9%93%BE.png&#34;
	width=&#34;730&#34;
	height=&#34;310&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/onLayoutChildren%E8%B0%83%E7%94%A8%E9%93%BE_hu5828821809185960976.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/onLayoutChildren%E8%B0%83%E7%94%A8%E9%93%BE_hu8187109392892001354.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;235&#34;
		data-flex-basis=&#34;565px&#34;
	
&gt;
调用链如下：
linearlayoutmanager.fill-&amp;gt;layoutmanager.layoutChunk-&amp;gt;layoutstate.next-&amp;gt;recycler.getviewforposition-&amp;gt;recycler.tryGeyViewHolderForPostionByDeadline-&amp;gt;adapter.createViewHolder-&amp;gt;adapter.bindViewHolder到这里一个holder的创建于bind过程就结束了，紧接着在layoutchunk中触发layoutmanager.addView和layoutmanager.measureChildWithMargin，到这里表项才会被加入到recyclerview中，但是此时不会刷新recyclerview。
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/layoutChunk%E8%B0%83%E7%94%A8.png&#34;
	width=&#34;960&#34;
	height=&#34;112&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/layoutChunk%E8%B0%83%E7%94%A8_hu18152347720928290541.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/layoutChunk%E8%B0%83%E7%94%A8_hu6142699420215196773.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;857&#34;
		data-flex-basis=&#34;2057px&#34;
	
&gt;
上面说到的layoutchunk会在一个while循环中多次执行，直到recyclerview的空间没有了才不会执行，而layoutchunk又会走recycler.next去从缓存中拿viewholder，而此时缓存中没有viewholder，因此会走createviewholder和bindviewholder，所以一开始create和bind次数是一屏能展示多少个表项的次数。&lt;/p&gt;
&lt;p&gt;接着在dispatchlayout中会调用dispatchlayoutstep3，该方法里面主要是执行scrap缓存的释放，以及动画的执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/recyclerview%E5%9C%A8dispatchLayoutStep3.png&#34;
	width=&#34;790&#34;
	height=&#34;452&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/recyclerview%E5%9C%A8dispatchLayoutStep3_hu7512520137607188626.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/recyclerview%E5%9C%A8dispatchLayoutStep3_hu10306827451365754912.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;419px&#34;
	
&gt;
到这里，测量和layout已经梳理完了，最后就剩draw了：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/recyclerview%E7%9A%84draw%E6%96%B9%E6%B3%95.png&#34;
	width=&#34;896&#34;
	height=&#34;344&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/recyclerview%E7%9A%84draw%E6%96%B9%E6%B3%95_hu15709130609700736038.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/recyclerview%E7%9A%84draw%E6%96%B9%E6%B3%95_hu15576703910561250186.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;260&#34;
		data-flex-basis=&#34;625px&#34;
	
&gt;
draw里面基本没干什么，还是沿用了viewgroup的drawchild方法，绿色表示非系统方法，因此可以看出来recyclerview是重写了该方法：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/recyclerview%E9%87%8D%E5%86%99drawChild%E6%96%B9%E6%B3%95.png&#34;
	width=&#34;1986&#34;
	height=&#34;870&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/recyclerview%E9%87%8D%E5%86%99drawChild%E6%96%B9%E6%B3%95_hu6175052918576826346.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/recyclerview%E9%87%8D%E5%86%99drawChild%E6%96%B9%E6%B3%95_hu13262063013138657709.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;228&#34;
		data-flex-basis=&#34;547px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;总结：
初始化分为onmeasure阶段：如果recyclerview设置了固定宽高，则直接跳过测量，调用到mLayout中，如果不是固定宽高，则会走dispatchLayoutStep1，dispatchLayoutStep2。其中dispatchLayoutStep1是预布局处理，如果有动画要处理才会在该阶段调用到layout的onLayoutChildren。在dispatchLayoutStep2中处理表项的测量。
在onlayout阶段：会判断step还是不是start状态，如果是的话，则再次执行dispatchLayoutStep1和dispatchLayoutStep2。最后调用dispatchLayoutStep3用来做动画执行并释放相关资源。
在draw阶段基本什么都没做，dispatchDraw本身会调用到drawChild，recyclerview只是重写了该方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;滑动过程&#34;&gt;滑动过程
&lt;/h3&gt;&lt;p&gt;滑动过程中会调用到scrollByInternal-&amp;gt;layoutmanager.scrollBy-&amp;gt;fill-&amp;gt;layoutchunck&lt;/p&gt;
&lt;p&gt;layoutchunck里面会从缓存中取数据，如果有则命中，没有则走create和bind，接着划出屏幕的表项会先加入到cache缓存中，如果cache缓存满了，则重置该表项，加入到recyclerpool中，下次所以取的时候从recyclerpool根据viewtype取需要重新bind，不需要create，所以在滑动过程中create的次数是cache的大小次数，等到recyclerpool中有缓存的时候就不需要create了。&lt;/p&gt;
&lt;p&gt;在fill过程中，会找到划出屏幕的表项，然后先调用recycleByLayoutState，接着调用到了Linearlayoutmanager.recycleChildren，接着会触发recyclerview.removeAndRecycleViewAt方法，接着就触发了adapter.onViewDetachedFromWindow(viewHolder)，接着就把viewholder缓存到cache和recyclerpool中，对应的方法是recycler.recycleView-&amp;gt;recycleViewHolderInternal,其中cache缓存中默认是2个，如果大于2的话，会把最前面的那个给放到recyclerpool中，接着再把新的viewholder放进来。&lt;/p&gt;
&lt;p&gt;在fiil过程中，会通过LayoutState.next从缓存中获取viewholder，获取的时候会先判断是不是preLayout状态，如果是则从changeScrap缓存中获取，从changeScrap中获取缓存先通过position获取，如果用position获取不到，则再用id去获取（必须adapter设置setHasStableIds为true，并且adapter重写了getItemId）。如果没获取到则从attacheScrap和cache中获取，如果从attach和cache中找不到，则继续通过id从attachScrap中获取，如果还没获取到则从viewcacheExtension中去获取，如果还获取不到则再从recyclerpool中去获取，如果还获取不到则通过create来创建viewholder，接着走bind逻辑。&lt;/p&gt;
&lt;p&gt;所以整个缓存获取顺序：
changeScrap(preLayout状态，先通过position获取，没获取到再通过id获取)-&amp;gt;attacheScrap-&amp;gt;cache-&amp;gt;attachScrap(id方式获取)-&amp;gt;viewcacheExtension-&amp;gt;recyclerpool-&amp;gt;createholder-&amp;gt;bindholder&lt;/p&gt;
&lt;p&gt;这就是layoutstate.next获取viewholder整个逻辑，上面哪些会触发createholder和bindholder&lt;/p&gt;
&lt;p&gt;如果从几个缓存中都拿不到viewholder，则会走createholder的逻辑。&lt;/p&gt;
&lt;p&gt;什么情况下会调用onBindViewHolder？
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/onBindViewHolder%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6.png&#34;
	width=&#34;1884&#34;
	height=&#34;500&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/onBindViewHolder%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6_hu10681849255634320567.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/onBindViewHolder%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6_hu13857616217112637933.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;376&#34;
		data-flex-basis=&#34;904px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不是bound状态
bound标志位：是在bindViewHolder的时候设置的，因此不是bound表示没有bind过。没有bind过有：1，createholder；2，从recyclerpool取的viewholder。
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/bindViewHolder%E5%90%8E%E8%AE%BE%E7%BD%AEbound%E7%8A%B6%E6%80%81.png&#34;
	width=&#34;1756&#34;
	height=&#34;630&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/bindViewHolder%E5%90%8E%E8%AE%BE%E7%BD%AEbound%E7%8A%B6%E6%80%81_hu16526521526694848863.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/bindViewHolder%E5%90%8E%E8%AE%BE%E7%BD%AEbound%E7%8A%B6%E6%80%81_hu9180695930292097991.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;278&#34;
		data-flex-basis=&#34;668px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;needsUpdate：该状态表示什么？什么时候才会是needUpdate()呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/needsUpdate%E6%BA%90%E7%A0%81.png&#34;
	width=&#34;810&#34;
	height=&#34;220&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/needsUpdate%E6%BA%90%E7%A0%81_hu16745625206395077354.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/needsUpdate%E6%BA%90%E7%A0%81_hu9313751603204677791.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;368&#34;
		data-flex-basis=&#34;883px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%B7%BB%E5%8A%A0update%E6%A0%87%E5%BF%97%E4%BD%8D.png&#34;
	width=&#34;1876&#34;
	height=&#34;1254&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%B7%BB%E5%8A%A0update%E6%A0%87%E5%BF%97%E4%BD%8D_hu15558857031045118622.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%B7%BB%E5%8A%A0update%E6%A0%87%E5%BF%97%E4%BD%8D_hu1326698609201363619.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;149&#34;
		data-flex-basis=&#34;359px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在viewRangeUpdate设置的。猜测是在viewholder发生变化的时候设置的，验证猜想：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/viewRangeUpdate%E8%B0%83%E7%94%A8%E9%93%BE.png&#34;
	width=&#34;1022&#34;
	height=&#34;564&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/viewRangeUpdate%E8%B0%83%E7%94%A8%E9%93%BE_hu17190880417699981030.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/viewRangeUpdate%E8%B0%83%E7%94%A8%E9%93%BE_hu15352844701357235208.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;181&#34;
		data-flex-basis=&#34;434px&#34;
	
&gt;
recyclerview.processAdapterUpdatesAndSetAnimationFlags-&amp;gt;AdapterHelper.preProcess-&amp;gt;applyUpdate-&amp;gt;postponeAndUpdateViewHolders
-&amp;gt;markViewHoldersUpdated-&amp;gt;viewRangeUpdate，所以在dispatchLayout1过程中给flag设置了update状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;isInvalid：表示什么状态？什么时候赋值的？
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%B7%BB%E5%8A%A0invalid%E6%A0%87%E5%BF%97%E4%BD%8D.png&#34;
	width=&#34;1816&#34;
	height=&#34;1336&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%B7%BB%E5%8A%A0invalid%E6%A0%87%E5%BF%97%E4%BD%8D_hu16950391817488934260.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%B7%BB%E5%8A%A0invalid%E6%A0%87%E5%BF%97%E4%BD%8D_hu10367533619850967308.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;135&#34;
		data-flex-basis=&#34;326px&#34;
	
&gt;
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%8B%BF%E5%88%B0viewholder%E5%90%8E%E9%AA%8C%E8%AF%81viewtype%E6%88%96id.png&#34;
	width=&#34;1884&#34;
	height=&#34;1456&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%8B%BF%E5%88%B0viewholder%E5%90%8E%E9%AA%8C%E8%AF%81viewtype%E6%88%96id_hu918169050588587341.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%8B%BF%E5%88%B0viewholder%E5%90%8E%E9%AA%8C%E8%AF%81viewtype%E6%88%96id_hu7861640089052609632.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;129&#34;
		data-flex-basis=&#34;310px&#34;
	
&gt;
从缓存（attachScrap、cacheview）中获取viewholder的时候，如果发现type和holder的type不一致，则会校验不通过。或者设置了stableids为true的时候，如果adapter中的id和holder的id一致，则也通过。
所以结论就是，需要bound的条件：没有bound过（createholder的holder还没有bound过）；needupdate的，holder发生更新了。invalid，从attachscrap、cache获取后， 如果type不一致也需要重新bound。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;更新表项&#34;&gt;更新表项
&lt;/h3&gt;&lt;p&gt;notifyItemChange(0)：更新表项第0的位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%9A%E8%BF%9B%E5%85%A5recyclerview%E7%9A%84%E6%97%A5%E5%BF%97.png&#34;
	width=&#34;2478&#34;
	height=&#34;1172&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%9A%E8%BF%9B%E5%85%A5recyclerview%E7%9A%84%E6%97%A5%E5%BF%97_hu91514335887064232.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%9A%E8%BF%9B%E5%85%A5recyclerview%E7%9A%84%E6%97%A5%E5%BF%97_hu6938636746900088994.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;211&#34;
		data-flex-basis=&#34;507px&#34;
	
&gt;
首先是进入页面创建了10个表项，然后更新后日志如下：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%9B%B4%E6%96%B0%E8%A1%A8%E9%A1%B90%E7%9A%84%E6%97%A5%E5%BF%97.png&#34;
	width=&#34;2440&#34;
	height=&#34;244&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%9B%B4%E6%96%B0%E8%A1%A8%E9%A1%B90%E7%9A%84%E6%97%A5%E5%BF%97_hu15013294563690583670.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%9B%B4%E6%96%B0%E8%A1%A8%E9%A1%B90%E7%9A%84%E6%97%A5%E5%BF%97_hu871190689318315447.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;1000&#34;
		data-flex-basis=&#34;2400px&#34;
	
&gt;
首先给我创建了索引为10的表项，也就是屏幕上不可见的，接着又创建了表项0，通过traceview分析：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%9B%B4%E6%96%B0%E8%A1%A8%E9%A1%B9%E7%BB%8F%E5%8E%86%E4%BA%86dispatchLayout%E6%96%B9%E6%B3%95.png&#34;
	width=&#34;2560&#34;
	height=&#34;670&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%9B%B4%E6%96%B0%E8%A1%A8%E9%A1%B9%E7%BB%8F%E5%8E%86%E4%BA%86dispatchLayout%E6%96%B9%E6%B3%95_hu124744611528498832.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%9B%B4%E6%96%B0%E8%A1%A8%E9%A1%B9%E7%BB%8F%E5%8E%86%E4%BA%86dispatchLayout%E6%96%B9%E6%B3%95_hu2147917480937809368.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;382&#34;
		data-flex-basis=&#34;917px&#34;
	
&gt;
整体看经历了rv的layout过程，分别对应了dispatchLayoutStep1、dispatchLayoutStep2、dispatchLayoutStep3。&lt;/p&gt;
&lt;h4 id=&#34;dispatchlayoutstep1&#34;&gt;dispatchLayoutStep1
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;detachAndScrapAttachedViews
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrapOrRecycleView%E8%B0%83%E7%94%A8%E5%9B%BE.png&#34;
	width=&#34;1116&#34;
	height=&#34;402&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrapOrRecycleView%E8%B0%83%E7%94%A8%E5%9B%BE_hu7324296050700314140.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrapOrRecycleView%E8%B0%83%E7%94%A8%E5%9B%BE_hu4239267430507870126.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;277&#34;
		data-flex-basis=&#34;666px&#34;
	
&gt;
共经历了10次scrapOrRecycleView：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/detachAndScrapAttachedViews%E6%BA%90%E7%A0%81.png&#34;
	width=&#34;1448&#34;
	height=&#34;434&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/detachAndScrapAttachedViews%E6%BA%90%E7%A0%81_hu13513585749035787664.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/detachAndScrapAttachedViews%E6%BA%90%E7%A0%81_hu14328154479888032833.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;333&#34;
		data-flex-basis=&#34;800px&#34;
	
&gt;
它是反向遍历页面上的view，然后添加到srap缓存中：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrapOrRecycleView%E6%BA%90%E7%A0%81.png&#34;
	width=&#34;1602&#34;
	height=&#34;1060&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrapOrRecycleView%E6%BA%90%E7%A0%81_hu4952515986636910101.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrapOrRecycleView%E6%BA%90%E7%A0%81_hu2737012357838191121.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;151&#34;
		data-flex-basis=&#34;362px&#34;
	
&gt;
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrapOrRecycleView%E7%9A%84trace%E8%B0%83%E7%94%A8.png&#34;
	width=&#34;726&#34;
	height=&#34;74&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrapOrRecycleView%E7%9A%84trace%E8%B0%83%E7%94%A8_hu10016181308022056134.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrapOrRecycleView%E7%9A%84trace%E8%B0%83%E7%94%A8_hu10819192399364155107.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;981&#34;
		data-flex-basis=&#34;2354px&#34;
	
&gt;
从scrapOrRecycleView的调用栈来看，是走了else部分，也就是往scrap缓存中加入viewholder。由于viewHolder的isInvalid为false，所以会走else。
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrapeView%E6%BA%90%E7%A0%81.png&#34;
	width=&#34;1966&#34;
	height=&#34;1094&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrapeView%E6%BA%90%E7%A0%81_hu10187188417008490168.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrapeView%E6%BA%90%E7%A0%81_hu6404884140834061296.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;179&#34;
		data-flex-basis=&#34;431px&#34;
	
&gt;
scrap缓存分两种，attachScrap和changeScrap。不是update的会放到attachScrap中，所以我们更新第0个的时候会放到changeScrap中，在detach的时候由于是反向加入到scrap缓存中的，因此我们看第10个的trace调用：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%A1%A8%E9%A1%B9%E7%9A%84scrapOrRecycleView%E8%B0%83%E7%94%A8%E9%93%BE.png&#34;
	width=&#34;2852&#34;
	height=&#34;1030&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%A1%A8%E9%A1%B9%E7%9A%84scrapOrRecycleView%E8%B0%83%E7%94%A8%E9%93%BE_hu1007847353858532735.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%A1%A8%E9%A1%B9%E7%9A%84scrapOrRecycleView%E8%B0%83%E7%94%A8%E9%93%BE_hu2341111996943070772.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;276&#34;
		data-flex-basis=&#34;664px&#34;
	
&gt;
从这里看第0个表项在detach的时候会加入到changeScrap中。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;结论：在dispatchLayout1中，先将页面上可见的viewholder从页面上分离，然后将update的viewholder放入到changeScrap中，把非update的viewholder放入到attachScrap中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;fill
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/fill%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE.png&#34;
	width=&#34;2024&#34;
	height=&#34;624&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/fill%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE_hu6293445583858693448.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/fill%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE_hu17315454615200976220.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;324&#34;
		data-flex-basis=&#34;778px&#34;
	
&gt;
fill阶段发生了layoutChunk11次，而我们刚开始列表是初始化了10个表项，那么说明dispatchLayout1阶段添加了一个新的viewholder，关于这块我们可以给出结论，如果viewhodler被设置了remove或者update标记的时候，则会给列表添加一个新的viewholder。关于这块可以看：&lt;a class=&#34;link&#34; href=&#34;https://juejin.cn/post/6890288761783975950&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://juejin.cn/post/6890288761783975950&lt;/a&gt;
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%A4%9A%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%A1%A8%E9%A1%B9%E7%9A%84%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86.png&#34;
	width=&#34;1924&#34;
	height=&#34;392&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%A4%9A%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%A1%A8%E9%A1%B9%E7%9A%84%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86_hu7686239755621698600.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%A4%9A%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%A1%A8%E9%A1%B9%E7%9A%84%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86_hu3522024776232266067.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;490&#34;
		data-flex-basis=&#34;1177px&#34;
	
&gt;
在fill的while循环中会判断remainingSpace时候大于0，而每次layoutChunk过程中会将remainingSpace减小，而layoutChunkResult.mIgnoreConsumed就是判断是否要减小，意思是如果不忽略才会减小，那什么时候会忽略呢？
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%BF%BD%E7%95%A5%E7%9A%84%E6%9D%A1%E4%BB%B6.png&#34;
	width=&#34;1312&#34;
	height=&#34;182&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%BF%BD%E7%95%A5%E7%9A%84%E6%9D%A1%E4%BB%B6_hu11796148271956042158.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%BF%BD%E7%95%A5%E7%9A%84%E6%9D%A1%E4%BB%B6_hu1743069324301611932.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;720&#34;
		data-flex-basis=&#34;1730px&#34;
	
&gt;
layoutChunk中判断viewholder如果是remove或者是change时候，才会忽略减小。所以我们会有11次的layoutChunk，而最后一次的layoutChunk会走createViewHolder，也就对应了上面的日志先添加了position=10的viewholder。从trace上看下：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E8%A1%A8%E9%A1%B9%E8%B5%B0create%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE.png&#34;
	width=&#34;1652&#34;
	height=&#34;470&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E8%A1%A8%E9%A1%B9%E8%B5%B0create%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE_hu10236812452427939999.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E8%A1%A8%E9%A1%B9%E8%B5%B0create%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE_hu9359342499526153522.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;351&#34;
		data-flex-basis=&#34;843px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;结论：
dispatchLayout1过程中，将第0个放入到changeScrap中，1-9放入到了attacheScrap中，并且创建了索引为10的viewhodler。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：
在dispatchLayout1过程中，如果viewholder经过了addView之后，则会把它从changescrap或者是attachscrap缓存中移除，所以在dispatchlayout2过程中change和attach的缓存为空的。
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E4%BB%8Escrap%E7%BC%93%E5%AD%98%E4%B8%AD%E7%A7%BB%E9%99%A4%E7%9A%84%E9%80%BB%E8%BE%91.png&#34;
	width=&#34;2938&#34;
	height=&#34;1200&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E4%BB%8Escrap%E7%BC%93%E5%AD%98%E4%B8%AD%E7%A7%BB%E9%99%A4%E7%9A%84%E9%80%BB%E8%BE%91_hu6948141193760266227.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E4%BB%8Escrap%E7%BC%93%E5%AD%98%E4%B8%AD%E7%A7%BB%E9%99%A4%E7%9A%84%E9%80%BB%E8%BE%91_hu6558568232153135207.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;244&#34;
		data-flex-basis=&#34;587px&#34;
	
&gt;
其实在dispatchLayout2过程中添加viewholder的view时候也是要从scrap缓存中移除。&lt;/p&gt;
&lt;h4 id=&#34;dispatchlayoutstep2&#34;&gt;dispatchLayoutStep2
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;detachAndScrapAttachedViews
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/detachAndScrapAttachedViews11%E6%AC%A1scrap%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE.png&#34;
	width=&#34;1556&#34;
	height=&#34;424&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/detachAndScrapAttachedViews11%E6%AC%A1scrap%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE_hu14586035892234685750.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/detachAndScrapAttachedViews11%E6%AC%A1scrap%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE_hu17397155685038326043.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;366&#34;
		data-flex-basis=&#34;880px&#34;
	
&gt;
由于在dispatchLayout1过程中创建了position=10的viewholder，因此会有11次，这11个里面第0个还是添加到了changeScrap中，1-10是添加到attachScrap中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fill
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E7%AC%AC%E4%BA%8C%E6%AC%A1fill%E8%B0%83%E7%94%A8%E9%93%BE.png&#34;
	width=&#34;1542&#34;
	height=&#34;890&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E7%AC%AC%E4%BA%8C%E6%AC%A1fill%E8%B0%83%E7%94%A8%E9%93%BE_hu10441854612835266796.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E7%AC%AC%E4%BA%8C%E6%AC%A1fill%E8%B0%83%E7%94%A8%E9%93%BE_hu9741231612223222767.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;173&#34;
		data-flex-basis=&#34;415px&#34;
	
&gt;
为什么此过程只有10次layoutChunck呢？这块其实还是回到remainingSpace的计算说起：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E4%B8%8D%E6%98%AFpre%E9%98%B6%E6%AE%B5%E7%9B%B4%E6%8E%A5%E5%87%8F%E5%B0%8FremainingSpace%E5%80%BC.png&#34;
	width=&#34;1866&#34;
	height=&#34;402&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E4%B8%8D%E6%98%AFpre%E9%98%B6%E6%AE%B5%E7%9B%B4%E6%8E%A5%E5%87%8F%E5%B0%8FremainingSpace%E5%80%BC_hu10998018353477114851.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E4%B8%8D%E6%98%AFpre%E9%98%B6%E6%AE%B5%E7%9B%B4%E6%8E%A5%E5%87%8F%E5%B0%8FremainingSpace%E5%80%BC_hu461246108867776147.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;464&#34;
		data-flex-basis=&#34;1114px&#34;
	
&gt;
所以在dispatchLayout2过程中当添加到索引等于9的时候remainingSpace就为0了，所以索引等于10的时候添加不上，因此只会有10次layoutChunck。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;layoutChunck
我们可以看到第0个走了createViewholder和bindViewholder：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%9C%A8post-layout%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%AC%AC0%E4%B8%AA%E8%A1%A8%E9%A1%B9%E8%B5%B0%E4%BA%86create%E5%92%8Cbind.png&#34;
	width=&#34;2884&#34;
	height=&#34;1250&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%9C%A8post-layout%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%AC%AC0%E4%B8%AA%E8%A1%A8%E9%A1%B9%E8%B5%B0%E4%BA%86create%E5%92%8Cbind_hu8801799141734457681.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%9C%A8post-layout%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%AC%AC0%E4%B8%AA%E8%A1%A8%E9%A1%B9%E8%B5%B0%E4%BA%86create%E5%92%8Cbind_hu5081780588629873050.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;230&#34;
		data-flex-basis=&#34;553px&#34;
	
&gt;
是由于第0个viewholder被添加到了changeScrap缓存中，而1-9的viewholder添加到了attachScrap中，而changeScrap只会在pre-layout过程中才会生效：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/changeScrap%E5%8F%AA%E5%9C%A8pre-layout%E7%94%9F%E6%95%88.png&#34;
	width=&#34;1700&#34;
	height=&#34;814&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/changeScrap%E5%8F%AA%E5%9C%A8pre-layout%E7%94%9F%E6%95%88_hu5303461125221831714.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/changeScrap%E5%8F%AA%E5%9C%A8pre-layout%E7%94%9F%E6%95%88_hu6895378180604863517.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;208&#34;
		data-flex-basis=&#34;501px&#34;
	
&gt;
所以可以看到上面日志中会走了position=0的createViewHolder和bindViewHolder。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;总结:
更新表项的时候，会经历dispatchLayout1，dispatchLayout2，其中在dispatchLayout1（pre-layout阶段）会先把可见的表项给回收到scrap缓存中，回收后，会把可见的表项从recyclerview中分离，其中需要变化的表项会加入到
changeScrap中（第1个表项），不变化的加入到attachScrap中（第2个到第10个表项）。接着在fill阶段会从scrap缓存中取表项，由于有表项更新，所以此时会去创建不可见的表项（第11个表项），最后会添加到recyclerview上。
在dispatchLayout2（post-layout阶段）同样会把dispatchLayout1添加进来的表项给添加到changeScrap（第1个表项）和attachScrap（第2个到第11个表项）缓存中，注意此时的表项会是11个表项。在fill阶段会去创建表项0，
因为post-layout阶段不会去取changeScrap中的viewholder，所以表项0会经历创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;删除表项&#34;&gt;删除表项
&lt;/h3&gt;&lt;p&gt;notifyItemRemove(0)&lt;/p&gt;
&lt;h4 id=&#34;dispatchlayout1&#34;&gt;dispatchLayout1
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;detachAndScrapAttachedViews
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9%E6%97%B6detachAndScrapAttachedViews.png&#34;
	width=&#34;2006&#34;
	height=&#34;140&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9%E6%97%B6detachAndScrapAttachedViews_hu15559714083964177442.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9%E6%97%B6detachAndScrapAttachedViews_hu3558814002079755925.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;1432&#34;
		data-flex-basis=&#34;3438px&#34;
	
&gt;
调用了10次scrapOrRecycleView
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9scrapView%E8%B0%83%E7%94%A8%E9%93%BE.png&#34;
	width=&#34;1530&#34;
	height=&#34;600&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9scrapView%E8%B0%83%E7%94%A8%E9%93%BE_hu13335460596666919717.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9scrapView%E8%B0%83%E7%94%A8%E9%93%BE_hu6133566821039666233.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;255&#34;
		data-flex-basis=&#34;612px&#34;
	
&gt;
第0个调用scrapView添加到attachScrap缓存中
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9%E8%B0%83%E7%94%A8%E7%9A%84scrapView%E6%96%B9%E6%B3%95.png&#34;
	width=&#34;1886&#34;
	height=&#34;1124&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9%E8%B0%83%E7%94%A8%E7%9A%84scrapView%E6%96%B9%E6%B3%95_hu1966757282013689752.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9%E8%B0%83%E7%94%A8%E7%9A%84scrapView%E6%96%B9%E6%B3%95_hu13840855879849957773.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;167&#34;
		data-flex-basis=&#34;402px&#34;
	
&gt;
1-9的表项也是添加到attachScrap缓存中，这个可以从trace中看到。&lt;/li&gt;
&lt;li&gt;fill
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9layoutChunk%E8%B0%83%E7%94%A8%E6%AC%A1%E6%95%B0.png&#34;
	width=&#34;1118&#34;
	height=&#34;556&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9layoutChunk%E8%B0%83%E7%94%A8%E6%AC%A1%E6%95%B0_hu14181821887712644263.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9layoutChunk%E8%B0%83%E7%94%A8%E6%AC%A1%E6%95%B0_hu12238187118200893387.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;201&#34;
		data-flex-basis=&#34;482px&#34;
	
&gt;
和update过程一样，在dispatchlayout1有11次layoutChunk，delete和update的viewholder不作为消费remainingSpace。
接着调用layoutstate.next获取viewholder，此时只有索引等于10的时候会去创建viewholder。注意了：此时创建完viewholder后，bind过程传的position=9：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9%E6%97%B6%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E8%A1%A8%E9%A1%B9%E6%97%B6bind%E8%BF%87%E7%A8%8Bposition%E8%AE%A1%E7%AE%97.png&#34;
	width=&#34;2268&#34;
	height=&#34;1372&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9%E6%97%B6%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E8%A1%A8%E9%A1%B9%E6%97%B6bind%E8%BF%87%E7%A8%8Bposition%E8%AE%A1%E7%AE%97_hu6531937130357433727.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9%E6%97%B6%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E8%A1%A8%E9%A1%B9%E6%97%B6bind%E8%BF%87%E7%A8%8Bposition%E8%AE%A1%E7%AE%97_hu11031882881033833206.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;165&#34;
		data-flex-basis=&#34;396px&#34;
	
&gt;
在bind过程中会传入postion=10，而此时的mPostponedList中有一个op是remove类型的，所以postion会减一，因此它的postion是9：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E8%A1%A8%E9%A1%B9%E7%9A%84create%E5%92%8Cbind%E6%97%A5%E5%BF%97.png&#34;
	width=&#34;2762&#34;
	height=&#34;1038&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E8%A1%A8%E9%A1%B9%E7%9A%84create%E5%92%8Cbind%E6%97%A5%E5%BF%97_hu1187624272639721065.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E8%A1%A8%E9%A1%B9%E7%9A%84create%E5%92%8Cbind%E6%97%A5%E5%BF%97_hu8025288239082785719.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;266&#34;
		data-flex-basis=&#34;638px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dispatchlayout2&#34;&gt;dispatchLayout2
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;detachAndScrapAttachedViews
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9%E6%97%B6post-layout%E8%B0%83%E7%94%A8detachAndScrapAttachedViews.png&#34;
	width=&#34;1092&#34;
	height=&#34;398&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9%E6%97%B6post-layout%E8%B0%83%E7%94%A8detachAndScrapAttachedViews_hu11849760230423166667.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9%E6%97%B6post-layout%E8%B0%83%E7%94%A8detachAndScrapAttachedViews_hu12534804983501352838.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;274&#34;
		data-flex-basis=&#34;658px&#34;
	
&gt;
此处scrapOrRecyclerview发生了11次，因为在dispatchLayout1创建了一个新的viewholder，11个viewholder都加入到了attachScrap缓存中。&lt;/li&gt;
&lt;li&gt;fill
layoutChunk调用了10次：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9post-layout%E7%9A%84fill%E9%98%B6%E6%AE%B5.png&#34;
	width=&#34;1290&#34;
	height=&#34;396&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9post-layout%E7%9A%84fill%E9%98%B6%E6%AE%B5_hu4015001145168480306.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%A0%E9%99%A4%E8%A1%A8%E9%A1%B9post-layout%E7%9A%84fill%E9%98%B6%E6%AE%B5_hu11184435817882272445.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;325&#34;
		data-flex-basis=&#34;781px&#34;
	
&gt;
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/debug%E4%B8%8B%E8%A1%A8%E9%A1%B9%E7%9A%84%E4%BF%A1%E6%81%AF.png&#34;
	width=&#34;2322&#34;
	height=&#34;918&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/debug%E4%B8%8B%E8%A1%A8%E9%A1%B9%E7%9A%84%E4%BF%A1%E6%81%AF_hu4090402503977829258.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/debug%E4%B8%8B%E8%A1%A8%E9%A1%B9%E7%9A%84%E4%BF%A1%E6%81%AF_hu13894348912378565212.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;252&#34;
		data-flex-basis=&#34;607px&#34;
	
&gt;
在第一个viewholder获取的时候获取到原来的第二个表项了，原来的第一个表项的position被置为-1了，所以我们0-9的表项都不会重新创建viewholder。也就对应上面的日志。
疑问：
此处的position赋值貌似都重新赋值了，因此我们看下是哪里重新赋值了：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/position%E9%87%8D%E6%96%B0%E8%B5%8B%E5%80%BC%E7%9A%84%E5%9C%B0%E6%96%B9.png&#34;
	width=&#34;2672&#34;
	height=&#34;1242&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/position%E9%87%8D%E6%96%B0%E8%B5%8B%E5%80%BC%E7%9A%84%E5%9C%B0%E6%96%B9_hu18302557035837899842.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/position%E9%87%8D%E6%96%B0%E8%B5%8B%E5%80%BC%E7%9A%84%E5%9C%B0%E6%96%B9_hu10553134707112358411.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;215&#34;
		data-flex-basis=&#34;516px&#34;
	
&gt;
当调用notifyItemRemove(0)的时候，在dispatchlayout1过程中会触发offsetPositionRecordsForRemove方法，该方法会通过remove的itemCount数重新给每一个页面上的viewhodler重新给赋上position的值，所以会看到上面的attachScrap缓存中最后一个viewholder的postion=-1了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;scrap缓存&#34;&gt;scrap缓存
&lt;/h3&gt;&lt;p&gt;在fill之前会把页面上的viewholder先detach掉，最终会调用到viewgroup的detachViewFromParent方法，removeView也会调用该方法，只不过viewholder的detach不会立马requestLayout。接着就是调用scrapView。
scrap缓存分两种，一种是attach、另外一种是change，如果viewholder是发生了变化（notifyItemChange），则会加入到change中，否则加入到attach中。接着在layoutChunk过程中，会从scrap缓存中找viewholder。
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrap%E7%BC%93%E5%AD%98%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA.png&#34;
	width=&#34;1840&#34;
	height=&#34;1580&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrap%E7%BC%93%E5%AD%98%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA_hu2062606384590137876.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrap%E7%BC%93%E5%AD%98%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA_hu5533808204089803104.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;116&#34;
		data-flex-basis=&#34;279px&#34;
	
&gt;
在dispatchLayout3过程中，会调用layout.removeAndRecycleScrapInt方法：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrap%E7%BC%93%E5%AD%98%E6%B8%85%E7%A9%BA%E6%97%B6%E6%9C%BA.png&#34;
	width=&#34;1494&#34;
	height=&#34;552&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrap%E7%BC%93%E5%AD%98%E6%B8%85%E7%A9%BA%E6%97%B6%E6%9C%BA_hu17972904002480082676.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/scrap%E7%BC%93%E5%AD%98%E6%B8%85%E7%A9%BA%E6%97%B6%E6%9C%BA_hu4993562920150645737.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;270&#34;
		data-flex-basis=&#34;649px&#34;
	
&gt;
里面会调用recycler.clearScrap：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/clearScrap.png&#34;
	width=&#34;1006&#34;
	height=&#34;408&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/clearScrap_hu15526074584371715853.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/clearScrap_hu11797324585153395010.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;246&#34;
		data-flex-basis=&#34;591px&#34;
	
&gt;
会清空scrap缓存。
总结：scrap缓存在每次layoutChild之前会先把页面的viewholder先放到scrap缓存中，在dispatchLayout3的时候，会把该缓存清空掉。&lt;/p&gt;
&lt;h3 id=&#34;adapteronviewattachedtowindow&#34;&gt;Adapter.onViewAttachedToWindow
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%9A%E8%BF%9B%E5%85%A5%E5%B1%8F%E5%B9%95onViewAttachedToWindow%E8%B0%83%E7%94%A8%E6%97%A5%E5%BF%97.png&#34;
	width=&#34;2704&#34;
	height=&#34;1272&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%9A%E8%BF%9B%E5%85%A5%E5%B1%8F%E5%B9%95onViewAttachedToWindow%E8%B0%83%E7%94%A8%E6%97%A5%E5%BF%97_hu2627668828657398580.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%88%9A%E8%BF%9B%E5%85%A5%E5%B1%8F%E5%B9%95onViewAttachedToWindow%E8%B0%83%E7%94%A8%E6%97%A5%E5%BF%97_hu16691033016759521706.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;212&#34;
		data-flex-basis=&#34;510px&#34;
	
&gt;
刚进入屏幕会触发onViewAttachedToWindow，从0-9都打印了。
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/onViewAttachedToWindow%E7%9A%84trace%E8%B0%83%E7%94%A8.png&#34;
	width=&#34;1768&#34;
	height=&#34;810&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/onViewAttachedToWindow%E7%9A%84trace%E8%B0%83%E7%94%A8_hu12049605815002463942.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/onViewAttachedToWindow%E7%9A%84trace%E8%B0%83%E7%94%A8_hu10079197346103463146.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;218&#34;
		data-flex-basis=&#34;523px&#34;
	
&gt;
从trace来看，初次每个viewholder都会经历onViewAttachedToWindow方法。&lt;/p&gt;
&lt;p&gt;下面看看什么时候不会调用onViewAttachedToWindow方法？
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/addViewInt%E9%80%BB%E8%BE%91.png&#34;
	width=&#34;2100&#34;
	height=&#34;1924&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/addViewInt%E9%80%BB%E8%BE%91_hu18038378171916241379.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/addViewInt%E9%80%BB%E8%BE%91_hu4756128976929391908.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;109&#34;
		data-flex-basis=&#34;261px&#34;
	
&gt;
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84addView%E5%9B%9E%E8%B0%83.png&#34;
	width=&#34;1998&#34;
	height=&#34;1218&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84addView%E5%9B%9E%E8%B0%83_hu17379212811394676140.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84addView%E5%9B%9E%E8%B0%83_hu2944803961004124996.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;164&#34;
		data-flex-basis=&#34;393px&#34;
	
&gt;
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%9C%80%E7%BB%88%E8%B0%83%E7%94%A8onViewAttachedToWindow%E6%96%B9%E6%B3%95.png&#34;
	width=&#34;1792&#34;
	height=&#34;774&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%9C%80%E7%BB%88%E8%B0%83%E7%94%A8onViewAttachedToWindow%E6%96%B9%E6%B3%95_hu9651110142362696518.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E6%9C%80%E7%BB%88%E8%B0%83%E7%94%A8onViewAttachedToWindow%E6%96%B9%E6%B3%95_hu8075067365225143754.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;231&#34;
		data-flex-basis=&#34;555px&#34;
	
&gt;
每次在layoutChunk的时候，从缓存中去拿viewholder，如果从scrap缓存中拿到了，则不触发childHelper的addView，也就不会触发adapter.onViewAttachedToWindow；如果当前view的parent是当前recyclerview的时候，也不触发childhelper的addview。如果都不满足则触发adapter.onViewAttachedToWindow。&lt;/p&gt;
&lt;p&gt;滑动的时候是否触发？
滑动过程中表项从不可见到可见会触发onViewAttachedToWindow，因为它不是从scrap缓存中获取到的，它是从cache缓存或者是recyclerpool中获取的。onViewAttachedToWindow触发不一定会触发oncreateViewHolder，也不一定会触发onBindViewholder。如果cache缓存和pool缓存中都没有该viewholder，则会触发oncreateViewHolder和onBindViewholder。如cache中有，则只触发onViewAttachedToWindow。如果从pool中拿到缓存，则会触发onBindViewholder和onViewAttachedToWindow。&lt;/p&gt;
&lt;p&gt;更新列表是否会触发？
拿上面更新表项0来看，由于在dispatchLayout1(pre-layout)过程中会创建表项10，所以会经历表项10的oncreate和onbind，并且把它添加到rv中，所以会有一次的表项10的onViewAttachedToWindow，接着会在dispatchLayout2过程中会创建表项0（因为表项0存在了changeScrap缓存中），所以会走表项0的onViewAttachedToWindow。&lt;/p&gt;
&lt;h3 id=&#34;adapteronviewdetachedfromwindow&#34;&gt;Adapter.onViewDetachedFromWindow
&lt;/h3&gt;&lt;p&gt;滑动过程中，划出屏幕的表项会调用onViewDetachedFromWindow。&lt;/p&gt;
&lt;h3 id=&#34;findviewholderforadapterposition和findviewholderforlayoutposition区别&#34;&gt;findViewHolderForAdapterPosition和findViewHolderForLayoutPosition区别：
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E8%8E%B7%E5%8F%96position%E7%9A%84%E4%BE%8B%E5%AD%90.png&#34;
	width=&#34;2332&#34;
	height=&#34;876&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E8%8E%B7%E5%8F%96position%E7%9A%84%E4%BE%8B%E5%AD%90_hu7949142580440661419.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E8%8E%B7%E5%8F%96position%E7%9A%84%E4%BE%8B%E5%AD%90_hu10979427111021457477.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;266&#34;
		data-flex-basis=&#34;638px&#34;
	
&gt;
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E8%8E%B7%E5%8F%96position%E7%9A%84%E6%97%A5%E5%BF%97.png&#34;
	width=&#34;2642&#34;
	height=&#34;412&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E8%8E%B7%E5%8F%96position%E7%9A%84%E6%97%A5%E5%BF%97_hu12858756624761729791.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E8%8E%B7%E5%8F%96position%E7%9A%84%E6%97%A5%E5%BF%97_hu13409576118497864789.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;641&#34;
		data-flex-basis=&#34;1539px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;结论：正常情况下adapterPostion和layoutPosition是相等的，当有add、remove、move的时候两者是不一样的。adapterPostion会算上要改变的表项，比如上面我要删除第一个表项，那么拿到的表项就是第二个。而layoutPostion是页面最终呈现的表项，上面例子中等到post完后，才会真正的删除掉。所以post（绘制后）后layoutposition获取到的是原来的第二个表项。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;notifydatasetchange问题&#34;&gt;notifydatasetChange问题
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E8%B0%83%E7%94%A8notifydatasetChange%E5%90%8E%E7%9A%84%E6%97%A5%E5%BF%97.png&#34;
	width=&#34;2574&#34;
	height=&#34;1490&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E8%B0%83%E7%94%A8notifydatasetChange%E5%90%8E%E7%9A%84%E6%97%A5%E5%BF%97_hu8629380768717259897.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E8%B0%83%E7%94%A8notifydatasetChange%E5%90%8E%E7%9A%84%E6%97%A5%E5%BF%97_hu9811034100351826362.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;172&#34;
		data-flex-basis=&#34;414px&#34;
	
&gt;
&lt;img src=&#34;https://example.com/%e5%8f%a6%e4%b8%80%e9%83%a8%e5%88%86%e6%97%a5%e5%bf%97-1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
&gt;
先是把页面上所有的都detach掉，然后又走了所有的viewholder的onbind过程，从索引为5的viewholder走了oncreateviewholder。下面看下trace：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/notifydataSetchange%E5%90%8E%E7%9A%84trace.png&#34;
	width=&#34;1726&#34;
	height=&#34;1086&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/notifydataSetchange%E5%90%8E%E7%9A%84trace_hu16326029826275178744.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/notifydataSetchange%E5%90%8E%E7%9A%84trace_hu417268336205723639.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;158&#34;
		data-flex-basis=&#34;381px&#34;
	
&gt;
layout过程只走了dispatchLayout2，在里面走到了linearlayoutManager.onLayoutChildren，里面会触发fill。在fill之前会走detach逻辑，里面会反向遍历可见的子view，并调用scrapOrRecylerview：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/notifydataSetchange%E5%90%8E%E9%83%BD%E8%B5%B0removeViewAt.png&#34;
	width=&#34;1500&#34;
	height=&#34;456&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/notifydataSetchange%E5%90%8E%E9%83%BD%E8%B5%B0removeViewAt_hu17858563825938736019.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/notifydataSetchange%E5%90%8E%E9%83%BD%E8%B5%B0removeViewAt_hu11808418269986258548.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;328&#34;
		data-flex-basis=&#34;789px&#34;
	
&gt;
每一个子view回收都走了removeViewAt:
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/removeViewAt%E9%80%BB%E8%BE%91.png&#34;
	width=&#34;1750&#34;
	height=&#34;1112&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/removeViewAt%E9%80%BB%E8%BE%91_hu17874290648693971679.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/removeViewAt%E9%80%BB%E8%BE%91_hu10317882271117318045.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;157&#34;
		data-flex-basis=&#34;377px&#34;
	
&gt;
此处由于所有的viewholder都是invalid状态了，因为在notifyDatasetChange在调用requestLayout之前把页面上的子view都设置成invalid状态了：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/notifydataSetchange%E5%90%8E%E7%BD%AE%E4%B8%BAinvalid_1.png&#34;
	width=&#34;1520&#34;
	height=&#34;882&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/notifydataSetchange%E5%90%8E%E7%BD%AE%E4%B8%BAinvalid_1_hu12943583134031551868.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/notifydataSetchange%E5%90%8E%E7%BD%AE%E4%B8%BAinvalid_1_hu4591628311978383744.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;172&#34;
		data-flex-basis=&#34;413px&#34;
	
&gt;
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/notifydataSetchange%E5%90%8E%E7%BD%AE%E4%B8%BAinvalid_2.png&#34;
	width=&#34;1414&#34;
	height=&#34;324&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/notifydataSetchange%E5%90%8E%E7%BD%AE%E4%B8%BAinvalid_2_hu4694049468430595453.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/notifydataSetchange%E5%90%8E%E7%BD%AE%E4%B8%BAinvalid_2_hu11369038894928021298.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;436&#34;
		data-flex-basis=&#34;1047px&#34;
	
&gt;
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/notifydataSetchange%E5%90%8E%E7%BD%AE%E4%B8%BAinvalid_3.png&#34;
	width=&#34;1962&#34;
	height=&#34;670&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/notifydataSetchange%E5%90%8E%E7%BD%AE%E4%B8%BAinvalid_3_hu15128694460051254672.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/notifydataSetchange%E5%90%8E%E7%BD%AE%E4%B8%BAinvalid_3_hu3096719542985996145.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;292&#34;
		data-flex-basis=&#34;702px&#34;
	
&gt;
所以在fill之前都会调用removeViewAt，而该方法会触发onViewDetachedFromWindow，因此可以看到前面日志中先反向打印了9-&amp;gt;0的onViewDetachedFromWindow。接着会调用recycler.recycleViewHolderInternal，该方法是把viewholder加入到cache或者是recyclerpool中：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%8A%A0%E5%85%A5cache%E6%88%96pool%E7%BC%93%E5%AD%98.png&#34;
	width=&#34;2288&#34;
	height=&#34;1208&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%8A%A0%E5%85%A5cache%E6%88%96pool%E7%BC%93%E5%AD%98_hu5523904204173320317.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%8A%A0%E5%85%A5cache%E6%88%96pool%E7%BC%93%E5%AD%98_hu10407373697528151754.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;189&#34;
		data-flex-basis=&#34;454px&#34;
	
&gt;
如果存在invalid状态，则会把viewholder加入到pool缓存中，trace验证下：
&lt;img src=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%8A%A0%E5%85%A5pool%E7%9A%84trace.png&#34;
	width=&#34;2474&#34;
	height=&#34;912&#34;
	srcset=&#34;https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%8A%A0%E5%85%A5pool%E7%9A%84trace_hu5584527474512766708.png 480w, https://example.com/p/recyclerview%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/%E5%8A%A0%E5%85%A5pool%E7%9A%84trace_hu16705963592357327366.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;271&#34;
		data-flex-basis=&#34;651px&#34;
	
&gt;
而pool缓存是5个，因此先把9-&amp;gt;5存到poo中时，发现pool满了，则把9给移除掉，因此最后只剩下5个viewholder在pool中。接着在layoutChunk阶段，会从缓存中拿viewholder的时候，只有pool中5个viewhold的缓存，取完一个remove掉一个，当索引为5的时候，pool中已经拿完了，因此5-9会去创建viewholder。&lt;/p&gt;
&lt;p&gt;参考：
&lt;a class=&#34;link&#34; href=&#34;https://juejin.cn/post/6844903778303344647&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RecyclerView 缓存机制 | 如何复用表项？&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://juejin.cn/post/6844903778303361038&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RecyclerView 缓存机制 | 回收些什么？&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://juejin.cn/post/6844903778307538958&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RecyclerView 缓存机制 | 回收到哪去？&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://juejin.cn/post/6844903780006264845&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RecyclerView缓存机制 | scrap view 的生命周期&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
