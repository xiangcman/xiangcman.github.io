<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="主要介绍java中的设计原则与模式">
<title>java设计原则与模式</title>

<link rel='canonical' href='http://xiangcman.xyz/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/'>

<link rel="stylesheet" href="/scss/style.min.6a692fd055deae459f2a9767f57f3855ba80cafd5041317f24f7360f6ca47cdf.css"><meta property='og:title' content="java设计原则与模式">
<meta property='og:description' content="主要介绍java中的设计原则与模式">
<meta property='og:url' content='http://xiangcman.xyz/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/'>
<meta property='og:site_name' content='xiangcman'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2025-03-07T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2025-03-07T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="java设计原则与模式">
<meta name="twitter:description" content="主要介绍java中的设计原则与模式">
    <link rel="shortcut icon" href="/static/logo.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/logo_hu_c5ce2387cd5c94f8.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">xiangcman</a></h1>
            <h2 class="site-description">大力出奇迹.</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/xiangcman'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>分类</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li>
      <ol>
        <li><a href="#设计原则">设计原则</a>
          <ol>
            <li><a href="#开闭原则">开闭原则</a></li>
            <li><a href="#里式替换原则">里式替换原则</a></li>
            <li><a href="#依赖倒置原则">依赖倒置原则</a></li>
            <li><a href="#单一职业原则">单一职业原则</a></li>
            <li><a href="#接口隔离原则">接口隔离原则</a></li>
            <li><a href="#迪米特法则">迪米特法则</a></li>
            <li><a href="#合成复用原则">合成复用原则</a></li>
          </ol>
        </li>
        <li><a href="#设计模式">设计模式</a>
          <ol>
            <li><a href="#单例模式">单例模式</a></li>
            <li><a href="#原型模式">原型模式</a></li>
            <li><a href="#工厂模式">工厂模式</a></li>
            <li><a href="#建造者模式">建造者模式</a></li>
            <li><a href="#静态代理模式">静态代理模式</a></li>
            <li><a href="#动态代理模式">动态代理模式</a></li>
            <li><a href="#适配器模式">适配器模式</a></li>
            <li><a href="#桥接模式">桥接模式</a></li>
            <li><a href="#装饰者模式">装饰者模式</a></li>
            <li><a href="#外观模式">外观模式</a></li>
            <li><a href="#享元模式">享元模式</a></li>
          </ol>
        </li>
        <li><a href="#参考">参考：</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/java/" >
                Java
            </a>
        
            <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" >
                设计模式
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/">java设计原则与模式</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            主要介绍java中的设计原则与模式
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2025-03-07</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 2 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h3 id="设计原则">设计原则
</h3><h4 id="开闭原则">开闭原则
</h4><ul>
<li>主要指对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节。</li>
<li>优点：保持软件的稳定性，不影响原有业务逻辑代码。使代码更具有模块化，易于维护。提高开发效率。</li>
<li>来源：<a class="link" href="https://segmentfault.com/a/1190000021922108"  target="_blank" rel="noopener"
    >https://segmentfault.com/a/1190000021922108</a></li>
</ul>
<h4 id="里式替换原则">里式替换原则
</h4><ul>
<li>所有引用基类的地方必须能透明地使用其子类的对象</li>
<li>原则：子类必须实现父类的抽象方法，不得重写父类的非抽象方法</li>
<li>子类可以增加自己特有的方法</li>
<li>子类在实现父类的方法的时候，形参要比父类的参数更加宽松。</li>
<li>子类实现父类的方法的时候，出参要比父类更加严格。</li>
</ul>
<h4 id="依赖倒置原则">依赖倒置原则
</h4><ul>
<li>高层模块不应该直接依赖底层模块，二者应该依赖抽象，抽象不应该依赖细节，细节应该依赖抽象。</li>
<li>比如A类是接口，B类是实现，而C类要使用B类，那么C类不能直接使用B类，而是通过依赖A接口来实现，这样将使用谁的权交给了外界。C类更加的灵活</li>
</ul>
<h4 id="单一职业原则">单一职业原则
</h4><ul>
<li>一个类或者模块只负责完成一个职责。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</li>
</ul>
<h4 id="接口隔离原则">接口隔离原则
</h4><ul>
<li>尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。和单一职责原则相比，他们都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想。两者不同在于单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。单一职责原则主要是约束类，它针对的是程序中的实现和细节。接口隔离原则主要是约束接口，主要针对抽象和程序整体框架的构建。</li>
</ul>
<h4 id="迪米特法则">迪米特法则
</h4><ul>
<li>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用，目的是降低类之间的耦合度，提高模块的相对独立性。由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</li>
<li>比如A类想调用B类，但是他们又没有直接联系，而通过中间的C类来调用B类。A-&gt;C-&gt;B这种调用关系</li>
</ul>
<h4 id="合成复用原则">合成复用原则
</h4><ul>
<li>要求在软件复用时，尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用集成关系来实现。采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，从而新对象可以调用已有对象的功能。</li>
<li>维持了类的封装性，因为成分对象的内部细节是新对象看不见的，这种复用称为黑箱复用。</li>
<li>新旧类之间的耦合度低，这种复用所需的依赖较少，新对象存储成分对象的唯一方法是通过成分对象的接口。</li>
<li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li>
</ul>
<h3 id="设计模式">设计模式
</h3><ul>
<li>设计模式分为创建型、结构型、行为型。
<ol>
<li>创建型：用于对象的创建，提高代码的灵活性和复用性
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>设计模式</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>工厂方法模式（Factory Method）</td>
          <td>通过工厂类提供一个创建对象的接口，而不是直接 new 一个对象，提高代码的可扩展性。</td>
      </tr>
      <tr>
          <td>抽象工厂模式（Abstract Factory）</td>
          <td>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。</td>
      </tr>
      <tr>
          <td>单例模式（Singleton）</td>
          <td>确保一个类只有一个实例，并提供一个全局访问点。</td>
      </tr>
      <tr>
          <td>建造者模式（Builder）</td>
          <td>用于创建复杂对象，将对象的构建与表示分离，以便相同的构建过程可以创建不同的表示。</td>
      </tr>
      <tr>
          <td>原型模式（Prototype）</td>
          <td>通过复制（克隆）已有的实例来创建新对象，而不是通过实例化。</td>
      </tr>
  </tbody>
</table></div>
</li>
<li>结构型模式：主要用于类与对象的组合，确保系统的结构更加灵活和高效。
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>设计模式</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>适配器模式（Adapter）</td>
          <td>让原本不兼容的接口能够协同工作，相当于“转换器”。</td>
      </tr>
      <tr>
          <td>桥接模式（Bridge）</td>
          <td>分离抽象部分和实现部分，使它们可以独立变化，提高可扩展性。</td>
      </tr>
      <tr>
          <td>装饰器模式（Decorator）</td>
          <td>通过动态地给对象增加额外的功能，而不会改变其结构（类似于 Java 的 IO 流）。</td>
      </tr>
      <tr>
          <td>组合模式（Composite）</td>
          <td>允许将对象组合成树形结构，以表示“整体-部分”关系，适用于树形结构数据。</td>
      </tr>
      <tr>
          <td>外观模式（Facade）</td>
          <td>提供一个统一的接口，用于访问子系统的一组接口，简化客户端的调用。</td>
      </tr>
      <tr>
          <td>享元模式（Flyweight）</td>
          <td>通过共享对象，减少内存占用，提高性能。</td>
      </tr>
      <tr>
          <td>代理模式（Proxy）</td>
          <td>通过代理对象控制对目标对象的访问，例如：静态代理、动态代理（JDK/CGLIB）。</td>
      </tr>
  </tbody>
</table></div>
</li>
<li>行为型模式：主要用于对象之间的通信和职责分配，提高代码的可维护性和可扩展性。
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>设计模式</th>
          <th>描述</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>策略模式（Strategy）</td>
          <td>定义一系列算法，将每种算法封装起来，并使它们可以互换。</td>
      </tr>
      <tr>
          <td>观察者模式（Observer）</td>
          <td>允许对象间建立一对多的依赖关系，当一个对象状态变化时，所有依赖它的对象都会收到通知（如 监听器 机制）。</td>
      </tr>
      <tr>
          <td>责任链模式（Chain of Responsibility）</td>
          <td>将请求沿着处理链传递，直到某个对象处理请求，降低耦合度（如 Java Web 过滤器）。</td>
      </tr>
      <tr>
          <td>命令模式（Command）</td>
          <td>将请求封装为对象，支持请求的撤销（Undo）和恢复（Redo）。</td>
      </tr>
      <tr>
          <td>备忘录模式（Memento）</td>
          <td>保存对象的历史状态，以便以后恢复（如 撤销/恢复 操作）。</td>
      </tr>
      <tr>
          <td>状态模式（State）</td>
          <td>允许对象在不同状态下改变行为，避免大量 if-else 语句。</td>
      </tr>
      <tr>
          <td>中介者模式（Mediator）</td>
          <td>通过一个中介对象来协调多个对象之间的交互，避免对象间的直接通信。</td>
      </tr>
      <tr>
          <td>迭代器模式（Iterator）</td>
          <td>提供一种访问集合对象元素的方法，而不暴露集合的内部表示。</td>
      </tr>
      <tr>
          <td>访问者模式（Visitor）</td>
          <td>允许在不修改对象结构的情况下，向对象结构中添加新的行为（如 XML 解析）。</td>
      </tr>
      <tr>
          <td>解释器模式（Interpreter）</td>
          <td>用于定义语言的语法规则，并解释相应的表达式（如 SQL 解析）。</td>
      </tr>
  </tbody>
</table></div>
</li>
</ol>
</li>
</ul>
<h4 id="单例模式">单例模式
</h4><ul>
<li>饿汉式：类加载时机就已经把单例对象实例化出来了，所以他不存在线程安全问题。但是它会浪费内存，在还没使用的时候，就已经创建了实例。
<img src="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B.png"
	width="1258"
	height="668"
	srcset="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B_hu_af8df2075006ae73.png 480w, /p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B_hu_ebe76a76cdbc55c6.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="188"
		data-flex-basis="451px"
	
></li>
<li>懒汉式（线程不安全）
<img src="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8.png"
	width="724"
	height="522"
	srcset="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8_hu_789b9096ce4b3fda.png 480w, /p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8_hu_9f8fa5afa8dedb2.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="138"
		data-flex-basis="332px"
	
>
<ul>
<li>创建对象的时机修改为了在getInstance内部，需要时再创建，可以节约系统资源。</li>
<li>getInstance方法在多个线程并发调用时，有可能会出现创建了多个实例，所以这是线程不安全的单例模式。</li>
</ul>
</li>
<li>懒汉式（线程安全）
<img src="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E6%96%B9%E6%B3%95%E5%8A%A0%E9%94%81.png"
	width="984"
	height="540"
	srcset="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E6%96%B9%E6%B3%95%E5%8A%A0%E9%94%81_hu_f0b8f1b7c618a273.png 480w, /p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E6%96%B9%E6%B3%95%E5%8A%A0%E9%94%81_hu_9120ce7cec34fa3a.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="182"
		data-flex-basis="437px"
	
>
<ul>
<li>方法上加锁，这种加锁能保证线程安全问题，但是加锁的粒度较大，每次在调用getInstance方法的时候，都需要加锁，很显然，锁的开销很大。</li>
</ul>
</li>
<li>懒汉式（线程安全-dcl模式）
<img src="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-dcl%E6%A8%A1%E5%BC%8F.png"
	width="816"
	height="672"
	srcset="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-dcl%E6%A8%A1%E5%BC%8F_hu_b085753e91b2e171.png 480w, /p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%87%92%E6%B1%89%E5%BC%8F-dcl%E6%A8%A1%E5%BC%8F_hu_6e7f7aae8281fee7.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="121"
		data-flex-basis="291px"
	
>
<ul>
<li>双重判断，成员属性instance上，增加了volatile关键字，保障多线程对instance值的可见性以及禁止指令重排。</li>
<li>第一层空判断是为了锁的开销，只有为空的时候才加锁。第二层空判断是为了防止创建了多个实例。</li>
</ul>
</li>
<li>静态内部类中加静态变量
<img src="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8A%A0%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F.png"
	width="970"
	height="480"
	srcset="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8A%A0%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F_hu_d3ff7c0f8e520ca1.png 480w, /p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8A%A0%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F_hu_7c597baab9b919dc.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="202"
		data-flex-basis="485px"
	
>
<ul>
<li>静态内部类可以达到双检锁的效果。将instance放在了内部类中，不会在类加载的时候就加载实例，这个和饿汉式在类加载的时候就加载有区别。他只会在getInstance的时候，才会去加载内部类，此时才会去加载单例实例。并且instance是内部类类加载的时候才进行加载，所以线程安全问题也保证了。</li>
</ul>
</li>
<li>枚举单例</br>
<img src="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B.png"
	width="542"
	height="234"
	srcset="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B_hu_b8183b12785b71d5.png 480w, /p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B_hu_17b3f05f19c6bb5f.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="231"
		data-flex-basis="555px"
	
>
<ul>
<li>这种不仅能避免多线程同步问题，还自动支持序列化机制，防止反序列化重新创建新的对象，防止多次实例化。</li>
</ul>
</li>
</ul>
<h4 id="原型模式">原型模式
</h4><ul>
<li>Java原型模式（Prototype Pattern）是一种创建型设计模式，其目的是通过复制现有对象来创建新的对象。</li>
<li>使用场景：
<ul>
<li>当对象创建的过程比较耗时或者比较复杂，例如需要进行复杂的计算或者涉及到网络请求等操作，可以使用原型模式来避免重复的初始化过程。</li>
<li>当需要创建的对象需要和其他对象进行协同工作时，例如需要创建一个包含多个对象的组合对象，可以使用原型模式来复制一个已有的组合对象，然后进行修改来创建新的组合对象。</li>
<li>当需要动态地增加或者删除一些对象时，可以使用原型模式来复制一个已有的对象，然后进行修改来创建新的对象。</li>
<li>当需要保护对象的复杂状态时，例如当一个对象的创建需要大量的数据初始化时，可以使用原型模式来保护这些数据，避免因为对象的复制而产生意外的副作用。</li>
</ul>
</li>
<li>代码实现：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 定义一个原型接口</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">interface</span> <span class="nc">Prototype</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Prototype</span><span class="w"> </span><span class="nf">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="c1">// 具体的原型类</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">ConcretePrototype</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Prototype</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Prototype</span><span class="w"> </span><span class="nf">clone</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConcretePrototype</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="c1">// 客户端代码</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Client</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Prototype</span><span class="w"> </span><span class="n">prototype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConcretePrototype</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Prototype</span><span class="w"> </span><span class="n">clone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prototype</span><span class="p">.</span><span class="na">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>使用小结：
<ul>
<li>Java中的Object类实现了Cloneable接口，这就意味着Java中的任何对象都可以实现原型模式。通过实现Cloneable接口，并重写Object类中的clone()方法，可以实现原型模式。例如 ArrayList、HashMap 等集合类都实现了Cloneable 接口，可以通过复制现有对象来创建新的对象。</li>
<li>Java中的线程池也是使用了原型模式，线程池中的每个线程都是从原型线程中复制而来，而不是每次创建新的线程。</li>
</ul>
</li>
</ul>
<h4 id="工厂模式">工厂模式
</h4><ul>
<li>
<p>分为简单工厂模式、工厂方法模式、抽象工厂模式。定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的创建与使用相分离。创建型模式可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。</p>
</li>
<li>
<p>简单工厂模式
<img src="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png"
	width="898"
	height="500"
	srcset="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F_hu_43007dcf34cc078c.png 480w, /p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F_hu_c1b8fa2e2ed3efbb.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="179"
		data-flex-basis="431px"
	
></p>
<ul>
<li>简单工厂类会很庞大，负责创建所有产品的创建，如果要新增产品类，会修改工厂类，违背了开闭原则。并且违背了高聚合原则。</li>
</ul>
</li>
<li>
<p>工厂方法模式</p>
<ul>
<li>在简单工厂类基础上将工厂类也进行抽象化，每个工厂类只做一件事，那就是生产对应的对象，保证了单一职责原则，并且保证了开闭原则，如果要生产不同的对象，只需要提供对应的工厂实现类就可以。
<img src="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png"
	width="1070"
	height="684"
	srcset="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F_hu_72544dbdc530714.png 480w, /p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F_hu_59f75db880c71176.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="156"
		data-flex-basis="375px"
	
></li>
</ul>
</li>
<li>
<p>抽象工厂模式</p>
<ul>
<li>和上面的工厂方法模式差不多，也是有对应的工厂实现类，区别是工厂类能生产不同级别的产品。
<img src="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png"
	width="1384"
	height="996"
	srcset="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F_hu_de4287adf9e6fa9a.png 480w, /p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F_hu_99068be0b0b2a0dc.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="138"
		data-flex-basis="333px"
	
></li>
</ul>
</li>
</ul>
<h4 id="建造者模式">建造者模式
</h4><ul>
<li>将一个复杂对象的构建与它的表示分离，使同样的构建过程可以创建不同的表示。将一个复杂对象进行一步步的构建而成，扩展性好，可以灵活配置的属性，来生成不同的对象。</li>
<li>构建指的是对象的创建过程，通过一步步组装的形式最终创建对象，而客户端在此过程中只需要提供组装的属性，而无需关心组装的过程</li>
<li>表示指的是对象创建完后的形态或结构，创建完后，对象就形成不可变的结构。此时客户端可以放心使用该对象。</li>
</ul>
<h4 id="静态代理模式">静态代理模式
</h4><ul>
<li>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</li>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用。</li>
<li>代理对象可以扩展目标对象的功能</li>
<li>其中静态代理要求代理类和被代理类实现同样的接口，旨在想扩展被代理类的某些功能，比如想添加些日志等行为</li>
</ul>
<h4 id="动态代理模式">动态代理模式
</h4><p>动态代理模式和静态代理模式的区别是，静态代理在编译期就已经确定了代理类和被代理类的关系，而动态代理是在运行时通过Proxy创建了代理类，在代理类中通过反射动态调用了InvokeHandler接口的实现类的invoke方法，最后在invoke中统一调用被代理类的方法。</p>
<blockquote>
<p>总结：
代理模式主要是通过代理类来控制对象的访问，主要涉及到访问权限、延迟加载、日志记录。比如有一个用户角色权限比较低，不能访问数据库，此时在调用对象的时候，判断权限而抛异常。再者比如在代理类中，可以延迟初始化被代理类。再比如可以通过日志记录被代理类的访问。</p>
</blockquote>
<h4 id="适配器模式">适配器模式
</h4><ul>
<li>将一个类的接口转换成客户希望的另外一个接口，使得原本是由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式。类结构型模式的耦合度比后者高。
<ul>
<li>优点：客户端通过适配器可以透明地调用目标接口，复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>
<li>角色：目标类，它是真正被调用的类；适配者类，它是被访问和适配的现存组件库中的组件接口；适配器类：它是一个转换器，把适配者接口转换成目标接口，让客户能通过适配者调用目标接口。</li>
<li>类适配器模式：
<img src="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png"
	width="1094"
	height="1428"
	srcset="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F_hu_5836efb86c0b5318.png 480w, /p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F_hu_3a70287a3bf2e8b3.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="76"
		data-flex-basis="183px"
	
>
在上面Adaptee是业务要被适配的类，适配器类ClassAdapter通过继承自Adaptee和被适配器类耦合，不方便扩展，最好的方案是将被适配器类交给调用方自己传进来。</li>
<li>对象适配器模式：
<img src="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png"
	width="1082"
	height="1274"
	srcset="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F_hu_edde1cd7e211eb6c.png 480w, /p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F_hu_971d7c845c7cd15b.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="84"
		data-flex-basis="203px"
	
>
<ul>
<li>从这里可以看出，对象适配模式更加的符合开闭原则，并且更加容易扩展。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="桥接模式">桥接模式
</h4><ul>
<li>强调的是抽象与实现分离，使它们可以独立变化。使用组合关系代替继承关系来实现。降低了抽象和实现两个可变维度的耦合度。和上面适配器模式不同，这里强调的是多种抽象的组合。它是有以下角色：
<ul>
<li>抽象化角色：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>
<li>实现化角色：定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li>具体实现化角色：给出实现化角色接口的具体实现。</li>
<li>实现化角色在这里是依附于抽象化角色上的，也就是最终是被扩展化角色所使用。
<img src="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BE%8B%E5%AD%90.png"
	width="962"
	height="2374"
	srcset="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BE%8B%E5%AD%90_hu_e090d49e04f00c55.png 480w, /p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BE%8B%E5%AD%90_hu_b4889bd01e87b77.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="40"
		data-flex-basis="97px"
	
></li>
<li>上面的color是一个实现化角色，其中具体实现化角色分为红色和黄色。抽象化角色是Bag类，它的扩展抽象化角色有Wallet和HandBag。他们使用了color这个实现化角色。</li>
</ul>
</li>
</ul>
<h4 id="装饰者模式">装饰者模式
</h4><ul>
<li>在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</li>
<li>有以下角色：
<ul>
<li>抽象构件角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。
<img src="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.png"
	width="1324"
	height="3107"
	srcset="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F_hu_c26ac243f0dea695.png 480w, /p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F_hu_20d04df89ce1833b.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="42"
		data-flex-basis="102px"
	
></li>
<li>上面ConcreteDecorator是具体的的装饰角色，它是持有了具体的构件角色ConcreteComponent，在调用具体的构建角色方法外，还调用了自己的另外一个方法，这个是和桥接模式的一个区别之处。并且装饰者模式的抽象的装饰角色实现了抽象构件角色，但是桥接模式中，抽象化构件角色中是不实现实现化角色接口的。</li>
</ul>
</li>
</ul>
<h4 id="外观模式">外观模式
</h4><ul>
<li>是迪米特法则的体现，比如一个系统想调用子系统的某个方法的时候，为了降低客户端调用系统的时候，将调用子系统的方法，通过统一的中心来调用子系统。分为以下角色：
<img src="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89.png"
	width="1324"
	height="264"
	srcset="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89_hu_5123e2d039dda65d.png 480w, /p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89_hu_7c8da007086e2431.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="501"
		data-flex-basis="1203px"
	
></li>
</ul>
<h4 id="享元模式">享元模式
</h4><ul>
<li>相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</li>
<li>具体有如下角色：
<ul>
<li>抽象享元角色：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。</li>
<li>具体享元角色：实现抽象享元角色中所规定的接口。</li>
<li>非享元角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。</li>
<li>享元工厂角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。
<img src="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.png"
	width="1518"
	height="3346"
	srcset="/p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F_hu_dc4ded1e295514d2.png 480w, /p/java%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F_hu_9464f979ae4eee2d.png 1024w"
	loading="lazy"
	
		alt="alt text"
	
	
		class="gallery-image" 
		data-flex-grow="45"
		data-flex-basis="108px"
	
>
上面享元工厂通过key来管理不同的享元角色，而享元角色持有了非享元角色的接口引用。上面例子中前3次获取的是同一个享元角色，后两次获取的是同一个享元角色。</li>
</ul>
</li>
</ul>
<h3 id="参考">参考：
</h3><ul>
<li><a class="link" href="https://juejin.cn/post/7198700701952983100"  target="_blank" rel="noopener"
    >Java常用设计模式(一)</a></li>
<li><a class="link" href="https://juejin.cn/post/7199907126688825400"  target="_blank" rel="noopener"
    >Java常用设计模式(二)</a></li>
<li><a class="link" href="https://juejin.cn/post/7202820042688528445"  target="_blank" rel="noopener"
    >Java常用设计模式(三)</a></li>
</ul>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="xiangcman/blog_comment"
        issue-term="pathname"
        
        label="none"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    let utterancesLoaded = false;

    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;

        
        utterancesLoaded = true;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        if (!utterancesLoaded) return;
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2025 xiangcheng
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
