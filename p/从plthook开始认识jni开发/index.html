<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="plthook技术在native的hook代码上起到关键的作用，native的函数调用分为内部调用和外部调用。内部调用指的是so内部的方法调用，当so被打包好后，so内部的方法都会被分配一个偏移地址，所以如果是内部函数的调用，那么直接通过编译期间给函数分配偏移地址就能去调用内部的其它方法。 如果是外部调用，也就是调用其它so的方法，就只能通过绝对地址来调用了，也就是该外部so的首地址+函数的偏移地址。我们通过一个例子来说明外部调用的过程：\n1 2 3 4 5 6 extern &#34;C&#34; JNIEXPORT void JNICALL Java_com_example_nativelib_MainActivity_MallocLeak(JNIEnv *env, jobject thiz) { malloc(88 * 1000 * 1000); __android_log_print(ANDROID_LOG_DEBUG, &#34;hookMallocByPLTHook&#34;, &#34;原来的malloc函数被调用&#34;); } 这里我在jni的方法MallocLeak方法中调用了malloc方法，它是lic.so库中的方法，所以我们认为它是一个外部调用的方法。 jni方法解释：extern &ldquo;C&rdquo;，告诉c++编译器，该方法是一个jni的方法，你不能混淆该方法，要不然java层找不到该方法的签名。下面的__android_log_print是调用了android库的log方法，用该方法的时候需要导入android/log.h，JNIEXPORT void JNICALL是一个跨平台的两个宏定义。一般在windows平台上如何没有该宏会报错。在jni方法参数上有两个，一个jni环境的方法，它是一个指针变量，第二个参数是java层谁调用的对象，比如我示例中是通过MainActivity调用的，那么此处的jobject就是MainActivity对象。 在java层就应该有该native方法的定义。\n1 external fun MallocLeak() 在kotlin代码中没有native关键字，用external关键字定义native方法。下面我们再来看下CMakeLists.txt文件，它是用来定义会构建哪几个so库，以及每一个so库是由那些c层代码构建的。以及每一个so库它所需要依赖的其它三方库有哪些：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //定义cmake的编译版本 cmake_minimum_required(VERSION 3.22.1) //用来定义native项目的名字，我感觉没有实际意义 project(&#34;nativelib&#34;) #查找并引入一个外部库bytehook，要求必须找到它（REQUIRED），并且以Config模式查找（寻找 bytehookConfig.cmake或类似文件） find_package(bytehook REQUIRED CONFIG) #此处的CMAKE_PROJECT_NAME就是project中定义nativelib字符串 #声明要编译生成一个库，库的名字是CMAKE_PROJECT_NAME，也就是nativelib.so #SHARED：表示生成一个 共享库（.so 文件）；如果是 STATIC，则为 .a 静态库。 #native-lib.cpp：要参与编译的源文件 add_library(${CMAKE_PROJECT_NAME} SHARED native-lib.cpp) #为你生成的库添加链接依赖 #此处总共添加3个依赖库 #android:链接Android NDK提供的libandroid.so #log:链接Android日志库liblog.so，用于 __android_log_print() 等函数 #bytehook::bytehook:链接bytehook这个第三方库（前提是已通过find_package引入） target_link_libraries(${CMAKE_PROJECT_NAME} android log bytehook::bytehook) #生成一个anr_monitor.so的库 add_library(anr_monitor SHARED signal-anr.cpp) target_link_libraries(anr_monitor android log bytehook::bytehook) 上面的cmake构建文件中，我定义了要构建两个so，其中一个so叫nativelib.so，另外一个叫anr_monitor.so。在定义之前我定义了一个find_package方法，用来引入一个外部库bytehook。add_library方法表示要构建的so由哪些c/c++类。target_link_libraries方法表示该so库需要哪些三方库的支持，比如android log bytehook::bytehook是我们要在c++代码中使用的三方库。如果要生成更多的so，依次类推。 在上面的nativelib.so的构建过程中，参与编译的文件是native-lib.cpp，前面我们已经介绍过jni方法Java_com_example_nativelib_MainActivity_MallocLeak。在它里面调用了外部so的方法malloc来申请内存，malloc方法是lic.so外部库的方法，我们的目的是通过plthook技术来实现malloc方法的监听，从而做自己的事情。前面已经讲过plthook技术其实是通过拦截外部so的方法调用，具体它是通过so内部的plt表跳转到外部的函数对应的got表的代码段，而在got表中记录了外部函数的地址。在程序运行时，动态链接器会根据函数的符号信息，将函数的真实地址回写到got表中，从而实现函数的动态调用。而plthook技术其实就是修改got表中记录的真实地址，改为我们的自定义方法的地址。而在自定义方法中，通过调用原函数的地址来实现原函数的调用。 下面我们通过bhook框架来实现外部函数调用的拦截：\n">
<title>从plthook开始认识jni开发</title>

<link rel='canonical' href='http://xiangcman.xyz/p/%E4%BB%8Eplthook%E5%BC%80%E5%A7%8B%E8%AE%A4%E8%AF%86jni%E5%BC%80%E5%8F%91/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="从plthook开始认识jni开发">
<meta property='og:description' content="plthook技术在native的hook代码上起到关键的作用，native的函数调用分为内部调用和外部调用。内部调用指的是so内部的方法调用，当so被打包好后，so内部的方法都会被分配一个偏移地址，所以如果是内部函数的调用，那么直接通过编译期间给函数分配偏移地址就能去调用内部的其它方法。 如果是外部调用，也就是调用其它so的方法，就只能通过绝对地址来调用了，也就是该外部so的首地址+函数的偏移地址。我们通过一个例子来说明外部调用的过程：\n1 2 3 4 5 6 extern &#34;C&#34; JNIEXPORT void JNICALL Java_com_example_nativelib_MainActivity_MallocLeak(JNIEnv *env, jobject thiz) { malloc(88 * 1000 * 1000); __android_log_print(ANDROID_LOG_DEBUG, &#34;hookMallocByPLTHook&#34;, &#34;原来的malloc函数被调用&#34;); } 这里我在jni的方法MallocLeak方法中调用了malloc方法，它是lic.so库中的方法，所以我们认为它是一个外部调用的方法。 jni方法解释：extern &ldquo;C&rdquo;，告诉c++编译器，该方法是一个jni的方法，你不能混淆该方法，要不然java层找不到该方法的签名。下面的__android_log_print是调用了android库的log方法，用该方法的时候需要导入android/log.h，JNIEXPORT void JNICALL是一个跨平台的两个宏定义。一般在windows平台上如何没有该宏会报错。在jni方法参数上有两个，一个jni环境的方法，它是一个指针变量，第二个参数是java层谁调用的对象，比如我示例中是通过MainActivity调用的，那么此处的jobject就是MainActivity对象。 在java层就应该有该native方法的定义。\n1 external fun MallocLeak() 在kotlin代码中没有native关键字，用external关键字定义native方法。下面我们再来看下CMakeLists.txt文件，它是用来定义会构建哪几个so库，以及每一个so库是由那些c层代码构建的。以及每一个so库它所需要依赖的其它三方库有哪些：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //定义cmake的编译版本 cmake_minimum_required(VERSION 3.22.1) //用来定义native项目的名字，我感觉没有实际意义 project(&#34;nativelib&#34;) #查找并引入一个外部库bytehook，要求必须找到它（REQUIRED），并且以Config模式查找（寻找 bytehookConfig.cmake或类似文件） find_package(bytehook REQUIRED CONFIG) #此处的CMAKE_PROJECT_NAME就是project中定义nativelib字符串 #声明要编译生成一个库，库的名字是CMAKE_PROJECT_NAME，也就是nativelib.so #SHARED：表示生成一个 共享库（.so 文件）；如果是 STATIC，则为 .a 静态库。 #native-lib.cpp：要参与编译的源文件 add_library(${CMAKE_PROJECT_NAME} SHARED native-lib.cpp) #为你生成的库添加链接依赖 #此处总共添加3个依赖库 #android:链接Android NDK提供的libandroid.so #log:链接Android日志库liblog.so，用于 __android_log_print() 等函数 #bytehook::bytehook:链接bytehook这个第三方库（前提是已通过find_package引入） target_link_libraries(${CMAKE_PROJECT_NAME} android log bytehook::bytehook) #生成一个anr_monitor.so的库 add_library(anr_monitor SHARED signal-anr.cpp) target_link_libraries(anr_monitor android log bytehook::bytehook) 上面的cmake构建文件中，我定义了要构建两个so，其中一个so叫nativelib.so，另外一个叫anr_monitor.so。在定义之前我定义了一个find_package方法，用来引入一个外部库bytehook。add_library方法表示要构建的so由哪些c/c++类。target_link_libraries方法表示该so库需要哪些三方库的支持，比如android log bytehook::bytehook是我们要在c++代码中使用的三方库。如果要生成更多的so，依次类推。 在上面的nativelib.so的构建过程中，参与编译的文件是native-lib.cpp，前面我们已经介绍过jni方法Java_com_example_nativelib_MainActivity_MallocLeak。在它里面调用了外部so的方法malloc来申请内存，malloc方法是lic.so外部库的方法，我们的目的是通过plthook技术来实现malloc方法的监听，从而做自己的事情。前面已经讲过plthook技术其实是通过拦截外部so的方法调用，具体它是通过so内部的plt表跳转到外部的函数对应的got表的代码段，而在got表中记录了外部函数的地址。在程序运行时，动态链接器会根据函数的符号信息，将函数的真实地址回写到got表中，从而实现函数的动态调用。而plthook技术其实就是修改got表中记录的真实地址，改为我们的自定义方法的地址。而在自定义方法中，通过调用原函数的地址来实现原函数的调用。 下面我们通过bhook框架来实现外部函数调用的拦截：\n">
<meta property='og:url' content='http://xiangcman.xyz/p/%E4%BB%8Eplthook%E5%BC%80%E5%A7%8B%E8%AE%A4%E8%AF%86jni%E5%BC%80%E5%8F%91/'>
<meta property='og:site_name' content='xiangcman'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2025-08-06T19:20:53&#43;08:00'/><meta property='article:modified_time' content='2025-08-06T19:20:53&#43;08:00'/>
<meta name="twitter:title" content="从plthook开始认识jni开发">
<meta name="twitter:description" content="plthook技术在native的hook代码上起到关键的作用，native的函数调用分为内部调用和外部调用。内部调用指的是so内部的方法调用，当so被打包好后，so内部的方法都会被分配一个偏移地址，所以如果是内部函数的调用，那么直接通过编译期间给函数分配偏移地址就能去调用内部的其它方法。 如果是外部调用，也就是调用其它so的方法，就只能通过绝对地址来调用了，也就是该外部so的首地址+函数的偏移地址。我们通过一个例子来说明外部调用的过程：\n1 2 3 4 5 6 extern &#34;C&#34; JNIEXPORT void JNICALL Java_com_example_nativelib_MainActivity_MallocLeak(JNIEnv *env, jobject thiz) { malloc(88 * 1000 * 1000); __android_log_print(ANDROID_LOG_DEBUG, &#34;hookMallocByPLTHook&#34;, &#34;原来的malloc函数被调用&#34;); } 这里我在jni的方法MallocLeak方法中调用了malloc方法，它是lic.so库中的方法，所以我们认为它是一个外部调用的方法。 jni方法解释：extern &ldquo;C&rdquo;，告诉c++编译器，该方法是一个jni的方法，你不能混淆该方法，要不然java层找不到该方法的签名。下面的__android_log_print是调用了android库的log方法，用该方法的时候需要导入android/log.h，JNIEXPORT void JNICALL是一个跨平台的两个宏定义。一般在windows平台上如何没有该宏会报错。在jni方法参数上有两个，一个jni环境的方法，它是一个指针变量，第二个参数是java层谁调用的对象，比如我示例中是通过MainActivity调用的，那么此处的jobject就是MainActivity对象。 在java层就应该有该native方法的定义。\n1 external fun MallocLeak() 在kotlin代码中没有native关键字，用external关键字定义native方法。下面我们再来看下CMakeLists.txt文件，它是用来定义会构建哪几个so库，以及每一个so库是由那些c层代码构建的。以及每一个so库它所需要依赖的其它三方库有哪些：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //定义cmake的编译版本 cmake_minimum_required(VERSION 3.22.1) //用来定义native项目的名字，我感觉没有实际意义 project(&#34;nativelib&#34;) #查找并引入一个外部库bytehook，要求必须找到它（REQUIRED），并且以Config模式查找（寻找 bytehookConfig.cmake或类似文件） find_package(bytehook REQUIRED CONFIG) #此处的CMAKE_PROJECT_NAME就是project中定义nativelib字符串 #声明要编译生成一个库，库的名字是CMAKE_PROJECT_NAME，也就是nativelib.so #SHARED：表示生成一个 共享库（.so 文件）；如果是 STATIC，则为 .a 静态库。 #native-lib.cpp：要参与编译的源文件 add_library(${CMAKE_PROJECT_NAME} SHARED native-lib.cpp) #为你生成的库添加链接依赖 #此处总共添加3个依赖库 #android:链接Android NDK提供的libandroid.so #log:链接Android日志库liblog.so，用于 __android_log_print() 等函数 #bytehook::bytehook:链接bytehook这个第三方库（前提是已通过find_package引入） target_link_libraries(${CMAKE_PROJECT_NAME} android log bytehook::bytehook) #生成一个anr_monitor.so的库 add_library(anr_monitor SHARED signal-anr.cpp) target_link_libraries(anr_monitor android log bytehook::bytehook) 上面的cmake构建文件中，我定义了要构建两个so，其中一个so叫nativelib.so，另外一个叫anr_monitor.so。在定义之前我定义了一个find_package方法，用来引入一个外部库bytehook。add_library方法表示要构建的so由哪些c/c++类。target_link_libraries方法表示该so库需要哪些三方库的支持，比如android log bytehook::bytehook是我们要在c++代码中使用的三方库。如果要生成更多的so，依次类推。 在上面的nativelib.so的构建过程中，参与编译的文件是native-lib.cpp，前面我们已经介绍过jni方法Java_com_example_nativelib_MainActivity_MallocLeak。在它里面调用了外部so的方法malloc来申请内存，malloc方法是lic.so外部库的方法，我们的目的是通过plthook技术来实现malloc方法的监听，从而做自己的事情。前面已经讲过plthook技术其实是通过拦截外部so的方法调用，具体它是通过so内部的plt表跳转到外部的函数对应的got表的代码段，而在got表中记录了外部函数的地址。在程序运行时，动态链接器会根据函数的符号信息，将函数的真实地址回写到got表中，从而实现函数的动态调用。而plthook技术其实就是修改got表中记录的真实地址，改为我们的自定义方法的地址。而在自定义方法中，通过调用原函数的地址来实现原函数的调用。 下面我们通过bhook框架来实现外部函数调用的拦截：\n">
    <link rel="shortcut icon" href="/static/logo.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/logo_hu_221c4e8ad5e24f52.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">xiangcman</a></h1>
            <h2 class="site-description">大力出奇迹.</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/xiangcman'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>分类</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>Dark Mode</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    

            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/jni/" >
                Jni
            </a>
        
            <a href="/categories/c&#43;&#43;/" >
                C&#43;&#43;
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E4%BB%8Eplthook%E5%BC%80%E5%A7%8B%E8%AE%A4%E8%AF%86jni%E5%BC%80%E5%8F%91/">从plthook开始认识jni开发</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2025-08-06</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    3 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <p>plthook技术在native的hook代码上起到关键的作用，native的函数调用分为内部调用和外部调用。内部调用指的是so内部的方法调用，当so被打包好后，so内部的方法都会被分配一个偏移地址，所以如果是内部函数的调用，那么直接通过编译期间给函数分配偏移地址就能去调用内部的其它方法。
如果是外部调用，也就是调用其它so的方法，就只能通过绝对地址来调用了，也就是该外部so的首地址+函数的偏移地址。我们通过一个例子来说明外部调用的过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">extern</span> <span class="s">&#34;C&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span>
</span></span><span class="line"><span class="cl"><span class="n">Java_com_example_nativelib_MainActivity_MallocLeak</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">thiz</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">malloc</span><span class="p">(</span><span class="mi">88</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">__android_log_print</span><span class="p">(</span><span class="n">ANDROID_LOG_DEBUG</span><span class="p">,</span> <span class="s">&#34;hookMallocByPLTHook&#34;</span><span class="p">,</span> <span class="s">&#34;原来的malloc函数被调用&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里我在jni的方法MallocLeak方法中调用了malloc方法，它是lic.so库中的方法，所以我们认为它是一个外部调用的方法。
jni方法解释：extern &ldquo;C&rdquo;，告诉c++编译器，该方法是一个jni的方法，你不能混淆该方法，要不然java层找不到该方法的签名。下面的__android_log_print是调用了android库的log方法，用该方法的时候需要导入<code>android/log.h</code>，JNIEXPORT void JNICALL是一个跨平台的两个宏定义。一般在windows平台上如何没有该宏会报错。在jni方法参数上有两个，一个jni环境的方法，它是一个指针变量，第二个参数是java层谁调用的对象，比如我示例中是通过MainActivity调用的，那么此处的jobject就是MainActivity对象。
在java层就应该有该native方法的定义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">external</span><span class="w"> </span><span class="n">fun</span><span class="w"> </span><span class="nf">MallocLeak</span><span class="p">()</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在kotlin代码中没有native关键字，用external关键字定义native方法。下面我们再来看下CMakeLists.txt文件，它是用来定义会构建哪几个so库，以及每一个so库是由那些c层代码构建的。以及每一个so库它所需要依赖的其它三方库有哪些：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">//定义cmake的编译版本</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">cmake_minimum_required</span><span class="p">(</span><span class="n">VERSION</span><span class="w"> </span><span class="n">3</span><span class="p">.</span><span class="na">22</span><span class="p">.</span><span class="na">1</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//用来定义native项目的名字，我感觉没有实际意义</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">project</span><span class="p">(</span><span class="s">&#34;nativelib&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="n">查找并引入一个外部库bytehook</span><span class="err">，</span><span class="n">要求必须找到它</span><span class="err">（</span><span class="n">REQUIRED</span><span class="err">），</span><span class="n">并且以Config模式查找</span><span class="err">（</span><span class="n">寻找</span><span class="w"> </span><span class="n">bytehookConfig</span><span class="p">.</span><span class="na">cmake或类似文件</span><span class="err">）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">find_package</span><span class="p">(</span><span class="n">bytehook</span><span class="w"> </span><span class="n">REQUIRED</span><span class="w"> </span><span class="n">CONFIG</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="n">此处的CMAKE_PROJECT_NAME就是project中定义nativelib字符串</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="n">声明要编译生成一个库</span><span class="err">，</span><span class="n">库的名字是CMAKE_PROJECT_NAME</span><span class="err">，</span><span class="n">也就是nativelib</span><span class="p">.</span><span class="na">so</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="n">SHARED</span><span class="err">：</span><span class="n">表示生成一个</span><span class="w"> </span><span class="n">共享库</span><span class="err">（</span><span class="p">.</span><span class="na">so</span><span class="w"> </span><span class="n">文件</span><span class="err">）；</span><span class="n">如果是</span><span class="w"> </span><span class="n">STATIC</span><span class="err">，</span><span class="n">则为</span><span class="w"> </span><span class="p">.</span><span class="na">a</span><span class="w"> </span><span class="n">静态库</span><span class="err">。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="kd">native</span><span class="o">-</span><span class="n">lib</span><span class="p">.</span><span class="na">cpp</span><span class="err">：</span><span class="n">要参与编译的源文件</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">add_library</span><span class="p">(</span><span class="n">$</span><span class="p">{</span><span class="n">CMAKE_PROJECT_NAME</span><span class="p">}</span><span class="w"> </span><span class="n">SHARED</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">native</span><span class="o">-</span><span class="n">lib</span><span class="p">.</span><span class="na">cpp</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="n">为你生成的库添加链接依赖</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="n">此处总共添加3个依赖库</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="n">android</span><span class="p">:</span><span class="n">链接Android</span><span class="w"> </span><span class="n">NDK提供的libandroid</span><span class="p">.</span><span class="na">so</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="n">log</span><span class="p">:</span><span class="n">链接Android日志库liblog</span><span class="p">.</span><span class="na">so</span><span class="err">，</span><span class="n">用于</span><span class="w"> </span><span class="nf">__android_log_print</span><span class="p">()</span><span class="w"> </span><span class="n">等函数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="n">bytehook</span><span class="p">::</span><span class="n">bytehook</span><span class="p">:</span><span class="n">链接bytehook这个第三方库</span><span class="err">（</span><span class="n">前提是已通过find_package引入</span><span class="err">）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">target_link_libraries</span><span class="p">(</span><span class="n">$</span><span class="p">{</span><span class="n">CMAKE_PROJECT_NAME</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">android</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">log</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">bytehook</span><span class="p">::</span><span class="n">bytehook</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">#</span><span class="n">生成一个anr_monitor</span><span class="p">.</span><span class="na">so的库</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">add_library</span><span class="p">(</span><span class="n">anr_monitor</span><span class="w"> </span><span class="n">SHARED</span><span class="w"> </span><span class="n">signal</span><span class="o">-</span><span class="n">anr</span><span class="p">.</span><span class="na">cpp</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">target_link_libraries</span><span class="p">(</span><span class="n">anr_monitor</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">android</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">log</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">bytehook</span><span class="p">::</span><span class="n">bytehook</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面的cmake构建文件中，我定义了要构建两个so，其中一个so叫nativelib.so，另外一个叫anr_monitor.so。在定义之前我定义了一个find_package方法，用来引入一个外部库bytehook。add_library方法表示要构建的so由哪些c/c++类。target_link_libraries方法表示该so库需要哪些三方库的支持，比如android log bytehook::bytehook是我们要在c++代码中使用的三方库。如果要生成更多的so，依次类推。
在上面的nativelib.so的构建过程中，参与编译的文件是native-lib.cpp，前面我们已经介绍过jni方法Java_com_example_nativelib_MainActivity_MallocLeak。在它里面调用了外部so的方法malloc来申请内存，malloc方法是lic.so外部库的方法，我们的目的是通过plthook技术来实现malloc方法的监听，从而做自己的事情。前面已经讲过plthook技术其实是通过拦截外部so的方法调用，具体它是通过so内部的plt表跳转到外部的函数对应的got表的代码段，而在got表中记录了外部函数的地址。在程序运行时，动态链接器会根据函数的符号信息，将函数的真实地址回写到got表中，从而实现函数的动态调用。而plthook技术其实就是修改got表中记录的真实地址，改为我们的自定义方法的地址。而在自定义方法中，通过调用原函数的地址来实现原函数的调用。
下面我们通过bhook框架来实现外部函数调用的拦截：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">JNIEXPORT</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">JNICALL</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">Java_com_example_nativelib_MainActivity_loadAddress</span><span class="p">(</span><span class="n">JNIEnv</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">jobject</span><span class="w"> </span><span class="n">thiz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">bytehook_stub_t</span><span class="w"> </span><span class="n">stub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bytehook_hook_single</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;libnativelib.so&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">nullptr</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;malloc&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">malloc_hook_by_plt</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">hacker_bytehook_strlen_hooked</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">nullptr</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里我定义了一个jni的方法，它的调用需要在上面jni方法Java_com_example_nativelib_MainActivity_MallocLeak之前。因为只有先监听，后面调用的时候才能监听到。bytehook_hook_single方法是bhook框架中的方法，它是<a class="link" href="https://github.com/bytedance/bhook/blob/main/README.zh-CN.md"  target="_blank" rel="noopener"
    >bhook</a>框架中的方法，用于hook进程中的单个调用者动态库的某个方法。第一个参数指定作用于在哪个so上，此处的malloc方法拦截是在libnativelib.so库中的Java_com_example_nativelib_MainActivity_MallocLeak方法调用的。第二个参数是被调用so的名字，此处我传的是nullptr，其实它是lic.so的方法，此处如果有多个库中出现了malloc方法，该参数需要制定。第三个参数是方法名。第四个参数是被hook时候的方法指针，此处要求类型是void *，在c++/c中表示指向未知类型的指针，也叫通用指针。而reinterpret_cast是c++/c中的强转。
下面来了解下c++中的几种强转：</p>
<ul>
<li>static_cast<T>(expr)
<ul>
<li>做类型之间的转换，作用于编译期检查，运行时不检查。比如基础类型之间转换（int-&gt;double）</li>
<li>有继承关系的指针或引用之间的转换(向上转型安全，向下转型需自己保证安全)</li>
<li>void* ↔ 具体类型</li>
<li>举例说明：
<ul>
<li>基本类型转换</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="c1">//int-&gt;double类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">&#34;数值是:&#34;</span><span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>void*转成具体类型</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span><span class="c1">//将i的地址给到指针p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="c1">//将p的指针强转成int类型的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;pi指针存储的值是 = &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">pi</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//取值操作
</span></span></span></code></pre></td></tr></table>
</div>
</div>那什么是编译期检查的类型呢？我们通过下面一个例子来说明:
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{};</span>
</span></span></code></pre></td></tr></table>
</div>
</div>这里我定义了一个父类和一个子类，然后通过static_cast能将子类类型指向父类类型：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">Derived</span><span class="o">*</span> <span class="n">derived</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Base</span><span class="o">*</span> <span class="n">base</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">derived</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div>这里直接能将子类指针指向父类指针。下面举个不能被指向的例子：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">A</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">B</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">B</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>   <span class="c1">// ❌ 报错：没有 A* -&gt; B* 的转换规则
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>dynamic_cast<T>(expr)
<ul>
<li>运行时类型安全转换，主要用于多态类（含有 虚函数表 的类）。向下转换时，会在运行时检查，失败则返回nullptr（指针情况），或抛出std::bad_cast（引用情况）。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">Base</span><span class="p">{</span><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">fun</span><span class="p">(){}};</span>
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="n">Base</span><span class="o">*</span> <span class="n">base</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">Derived</span><span class="o">*</span> <span class="n">derived</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">&#34;转换后的结果：&#34;</span><span class="o">&lt;&lt;</span> <span class="n">derived</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">derived</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;转换成功&#34;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>上面可以通过dynamic_cast转换将子类类型的指针转换成父类类型的指针。上面如果Base中没有定义虚函数，则在dynamic_cast编译期就会提示错误。在上面例子中derived不会为空，什么叫运行时安全转换呢？下面通过一个不是继承关系来说明问题：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span><span class="p">{</span><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">fun</span><span class="p">(){}};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="n">Base</span><span class="o">*</span> <span class="n">base</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Base</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">Derived</span><span class="o">*</span> <span class="n">derived</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">&#34;转换后的结果：&#34;</span><span class="o">&lt;&lt;</span> <span class="n">derived</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">derived</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;转换后为空&#34;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>在上面代码中，Derived不是继承自Base，并且在用dynamic_cast时候，编译期不会报错，如果用上面的static_cast就会报错了。但是在编译期得到的结果就是nullptr。</li>
<li>const_cast<T>(expr)
<ul>
<li>去除或添加 const、volatile 修饰符</li>
<li>唯一能去掉 const 的 cast</li>
<li>不能用于不同类型之间的转换</li>
<li>如果原对象本身是 const 的，去掉 const 后修改会导致 未定义行为。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;a=&#34;</span><span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="c1">//a=10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;p=&#34;</span><span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="c1">//p=20
</span></span></span></code></pre></td></tr></table>
</div>
</div>此处定义了const a等于10，在后面虽然把p指针指向a，改变p的值后，对a没有影响。</li>
<li>reinterpret_cast<T>(expr)
<ul>
<li>底层二进制级别的重新解释。</li>
<li>不安全，不检查类型。</li>
<li>常用于指针之间的的转换、指针和整数之间的转换。</li>
<li>只是简单地“解释”比特位，没有语义上的转换。
<ul>
<li>举个指针转化成long类型的例子：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;p2=&#34;</span><span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p2</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;p2的地址值=&#34;</span><span class="o">&lt;&lt;</span> <span class="n">p2</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">s</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;s的值是:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div>p2指向了变量i的地址，接着使用reinterpret_cast将p2这个指针转化成long类型。
再来举一个指针变成另外一个指针的例子：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">    <span class="n">Base</span><span class="o">*</span> <span class="n">base2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Base</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;base2:&#34;</span><span class="o">&lt;&lt;</span><span class="n">base2</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Derived</span><span class="o">*</span> <span class="n">derived2</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">base2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;derived2:&#34;</span><span class="o">&lt;&lt;</span> <span class="n">derived2</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div>上面使用reinterpret_cast能直接将base2的指针直接强转到derived2上，从结果来看，base2和derived2的指针值都是一样的，在上面讲的const_cast它是得到一个默认指针，也就是nullptr。</li>
</ul>
</li>
</ul>
<p>回到上面jni的拦截方法里面，它是将malloc_hook_by_plt这个函数通过取址符(&amp;)来获取到函数的地址，接着通过reinterpret_cast强转操作符转化成void*类型的指针，它是c/c++中的任何指针类型。我们来看下malloc_hook_by_plt函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">size_t</span> <span class="nf">malloc_hook_by_plt</span><span class="p">(</span><span class="n">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">__android_log_print</span><span class="p">(</span><span class="n">ANDROID_LOG_DEBUG</span><span class="p">,</span> <span class="s">&#34;hookMallocByPLTHook&#34;</span><span class="p">,</span> <span class="s">&#34;origin malloc size:%d&#34;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">__android_log_print</span><span class="p">(</span><span class="n">ANDROID_LOG_DEBUG</span><span class="p">,</span> <span class="s">&#34;hookMallocByPLTHook&#34;</span><span class="p">,</span> <span class="s">&#34;do somethings&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//堆栈打印
</span></span></span><span class="line"><span class="cl"><span class="c1">//        printNativeStack();
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//调用原来的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">hacker_orig_strlen</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先该函数的返回值类型是size_t，它表示的是无符号的int值，在32位机器上，它是4字节，64位机器上，它是8字节，一般用来表示地址值。接着函数的参数也是一个size_t值，它是和我们的malloc函数的参数对应，表示申请的内存大小。接着我们输出android的log，如果申请的内存大于20M的时候，也输出android的log，最后返回原来函数的地址值。我们看下hacker_orig_strlen函数，它是一个函数指针类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="nf">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">hacker_strlen_t</span><span class="p">)(</span><span class="k">const</span> <span class="n">size_t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">hacker_strlen_t</span> <span class="n">hacker_orig_strlen</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>此处使用typedef是给当前函数指针起一个别名，名字叫hacker_strlen_t，函数的返回值是size_t，第二行定义了一个hacker_strlen_t类型的函数。此处为什么要这样定义函数指针呢？我们回到上面的调用就知道了，malloc_hook_by_plt方法需要一个size_t用来表示new_func的地址，参数和malloc方法的参数一致。这个在hock的时候需要知道申请的内存大小，hacker_orig_strlen函数指针是什么时候初始化的呢？它是在hacker_bytehook_strlen_hooked方法中被赋值的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">hacker_bytehook_strlen_hooked</span><span class="p">(</span><span class="n">bytehook_stub_t</span> <span class="n">task_stub</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status_code</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                          <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">caller_path_name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sym_name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                          <span class="kt">void</span> <span class="o">*</span><span class="n">new_func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">prev_func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">hacker_orig_strlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">hacker_strlen_t</span><span class="p">)</span> <span class="n">prev_func</span><span class="p">;</span><span class="c1">//此处当hook的之后，将原始函数的指针赋值给hacker_orig_strlen变量，这是c风格的强制转换，不太推荐这种转换，因为这种无法区分用途，不安全，不明确，可能绕过类型检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//caller_path_name此处会输出libnativelib.so的完整路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">__android_log_print</span><span class="p">(</span><span class="n">ANDROID_LOG_DEBUG</span><span class="p">,</span> <span class="s">&#34;hookMallocByPLTHook&#34;</span><span class="p">,</span> <span class="s">&#34;caller_path_name:%s&#34;</span><span class="p">,</span> <span class="n">caller_path_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//sym_name此处会输出malloc函数名字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">__android_log_print</span><span class="p">(</span><span class="n">ANDROID_LOG_DEBUG</span><span class="p">,</span> <span class="s">&#34;hookMallocByPLTHook&#34;</span><span class="p">,</span> <span class="s">&#34;sym_name:%s&#34;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它是bhook中bytehook_hook_single方法的hooked参数被调用的，它表示plthook过程中被hooked时候调用的方法，下面来分析下该方法：</p>
<ul>
<li>该函数的定义是用于hook成功后保存原始函数指针</li>
<li>static表示该函数只能在当前源文件中可见（局部链接）</li>
<li>task_stub：hook操作的句柄，bhook用来标识一次hook任务</li>
<li>status_code：状态码，表示hook是否成功，在bytehook.h中定义了BYTEHOOK_STATUS_CODE_OK，表示hook成功</li>
<li>caller_path_name：这是一个指向常量字符的指针，在c和c++中，字符串不是一个单独的类型，而是由字符数组实现的，而指针可以用来指向一串字符的指针，所以次数用char *，前面加const表示该函数中不能修改该字符串，调用者模块的路径,是谁调用了被hook的函数</li>
<li>sym_name：被hook的符号名</li>
<li>new_func：新的函数地址，此处使用void *，表示的是泛型指针，表示任意类型的指针，即一个没有具体类型的内存地址，hook框架不知道你hook函数到底是什么签名，所以只返回一个地址，让你自行转换为对应函数指针类型</li>
<li>prev_func：被替换掉的原函数地址（可通过它调用原函数）</li>
<li>arg：你 hook 时传入的自定义参数，可传 hook 时的上下文等</li>
</ul>
<p>在函数里面将prev_func的void*类型指针直接强转成hacker_strlen_t函数指针，其实这种小括号的强转不够规范，应该用上面的reinterpret_cast来进行指针类型的强转。最后输出了android log，整个过程就结束了。</p>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="xiangcman/blog_comment"
        issue-term="pathname"
        
        label="none"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    let utterancesLoaded = false;

    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;

        
        utterancesLoaded = true;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        if (!utterancesLoaded) return;
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2025 xiangcheng
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
